<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kavience</title>
  
  <subtitle>blog</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://www.kavience.com/"/>
  <updated>2021-05-18T07:51:15.324Z</updated>
  <id>http://www.kavience.com/</id>
  
  <author>
    <name>Kavience</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang语言初探三</title>
    <link href="http://www.kavience.com/backend/a-preliminary-study-of-golang-language3.html"/>
    <id>http://www.kavience.com/backend/a-preliminary-study-of-golang-language3.html</id>
    <published>2021-05-18T01:55:55.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>关于 golang 入门的笔记。</p><ul><li><a href="/backend/a-preliminary-study-of-golang-language1.html">golang语言初探一</a></li><li><a href="/backend/a-preliminary-study-of-golang-language2.html">golang语言初探二</a></li><li>golang语言初探三</li></ul><h2 id="why">why</h2><p>周末的时候研究了一下 golang 相关的文档，根据自己的工作经验，我觉得这门语言在未来一定会大放异彩，其实现在也比较热门了。主要有以下几个特点：</p><ul><li>语法简单，golang 的关键字才 25 个，入门也非常简单</li><li>天然支持高并发，适用于大型微服务应用</li><li>跨平台，可编译出支持各大主流平台的应用，且毫无依赖</li></ul><p>经过对 golang 的这些了解，顿时感觉有点兴趣了，在这里记录一些入门的资料。</p><h2 id="how">how</h2><h3 id="基本流程控制">基本流程控制</h3><h4 id="if-语句">if 语句</h4><p>if 语句一般会由关键字 if 、条件表达式和由花括号包裹的代码块组成。所谓代码块，即是包含了若干表达式和语句的序列。在 Go 语言中，代码块必须由花括号包裹。另外，这里的条件表达式是指其结果类型是 bool 的表达式。一条最简单的 if 语句可以是：</p><pre><code class="highlight go"><span class="keyword">if</span> <span class="number">100</span> &gt; number &#123;     number += <span class="number">3</span>&#125;</code></pre><p>这里的标识符 number 可以代表一个 int 类型的值。这条 if 语句的意思是：如果 number 的值小于 100 ，那么就把其值增加 3 。我还可以在此之上添加 else 分支，就像这样：</p><pre><code class="highlight go"><span class="keyword">if</span> <span class="number">100</span> &gt; number &#123;    number += <span class="number">3</span>&#125; <span class="keyword">else</span> &#123;    number -= <span class="number">2</span>&#125;</code></pre><p>else 分支的含义是，提供在条件不成立（具体到这里是 number 的值不小于 100 ）的情况下需要执行的操作。除此之外， if 语句还支持串联。请看下面的例子：</p><pre><code class="highlight go"><span class="keyword">if</span> <span class="number">100</span> &gt; number &#123;    number += <span class="number">3</span>&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">100</span> &lt; number &#123;    number -= <span class="number">2</span>&#125; <span class="keyword">else</span> &#123;    fmt.Println(<span class="string">"OK!"</span>)&#125;</code></pre><p>可以看到，上述代码很像是把多条 if 语句串接在一起了一样。这样的 if 语句用于对多个条件的综合判断。上述语句的意思是，若 number 的值小于 100 则将其加 3 ，若 number 的值大于 100 则将其减 2 ，若 number 的值等于 100 则打印 OK! 。</p><blockquote><p>注意，我们至此还未对 number 变量进行声明。上面的示例也因此不能通过编译。</p></blockquote><p>我们可以用单独的语句来声明该变量并为它赋值。但是我们也可以把这样的变量赋值直接加入到 if 子句中。示例如下：</p><pre><code class="highlight go"><span class="keyword">if</span> number := <span class="number">4</span>; <span class="number">100</span> &gt; number &#123;    number += <span class="number">3</span>&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">100</span> &lt; number &#123;    number -= <span class="number">2</span>&#125; <span class="keyword">else</span> &#123;    fmt.Println(<span class="string">"OK!"</span>)&#125;</code></pre><p>这里的 <code>number := 4</code> 被叫做 if 语句的初始化子句。它应被放置在 if 关键字和条件表达式之间，并与前者由空格分隔、与后者由英文分号;分隔。注意，我们在这里使用了短变量声明语句，即：在声明变量 number 的同时为它赋值。这意味着这里的 number 被视为一个新的变量。它的作用域仅在这条 i 语句所代表的代码块中。也可以说，变量 number 对于该 if 语句之外的代码来说是不可见的。我们若要在该 if 语句以外使用 number 变量就会造成编译错误。</p><p>另外还要注意，即使我们已经在这条if语句所代表的代码块之外声明了 number 变量，这里的语句 number := 4 也是合法的。请看这个例子：</p><pre><code class="highlight go"><span class="keyword">var</span> number <span class="keyword">int</span><span class="keyword">if</span> number := <span class="number">4</span>; <span class="number">100</span> &gt; number &#123;    number += <span class="number">3</span>&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">100</span> &lt; number &#123;    number -= <span class="number">2</span>&#125; <span class="keyword">else</span> &#123;    fmt.Println(<span class="string">"OK!"</span>)&#125;</code></pre><p>这种写法有一个专有名词，叫做：标识符的重声明。实际上，只要对同一个标识符的两次声明各自所在的代码块之间存在包含的关系，就会形成对该标识符的重声明。具体到这里，第一次声明的 number 变量所在的是该 if 语句的外层代码块，而 number := 4 所声明的 number 变量所在的是该if语句的代表代码块。它们之间存在包含关系。因此对 number 的重声明就形成了。</p><p>这种情况造成的结果就是， if 语句内部对 number 的访问和赋值都只会涉及到第二次声明的那个 number 变量。这种现象也被叫做标识符的遮蔽。上述代码被执行完毕之后，第二次声明的 number 变量的值会是7，而第一次声明的 number 变量的值仍会是 0 。</p><h4 id="switch-语句">switch 语句</h4><p>与串联的 if 语句类似， switch 语句提供了一个多分支条件执行的方法。不过在这里用一个专有名词来代表分支——<code>case</code>。每一个 case 可以携带一个表达式或一个类型说明符。前者又可被简称为 case 表达式。因此， <strong>Go 语言的 switch 语句又分为表达式 switch 语句和类型 switch 语句</strong>。</p><p>先说表达式 switch 语句。在此类 switch 语句中，每个 case 会携带一个表达式。与 if 语句中的条件表达式不同，这里的 case 表达式的结果类型并不一定是 bool 。不过，它们的结果类型需要与 switch 表达式的结果类型一致。所谓 switch 表达式是指 switch 语句中要被判定的那个表达式。 switch 语句会依据该表达式的结果与各个 case 表达式的结果是否相同来决定执行哪个分支。请看下面的示例：</p><pre><code class="highlight go"><span class="keyword">var</span> name <span class="keyword">string</span><span class="comment">// 省略若干条语句</span><span class="keyword">switch</span> name &#123;<span class="keyword">case</span> <span class="string">"Golang"</span>:    fmt.Println(<span class="string">"A programming language from Google."</span>)<span class="keyword">case</span> <span class="string">"Rust"</span>:    fmt.Println(<span class="string">"A programming language from Mozilla."</span>)<span class="keyword">default</span>:    fmt.Println(<span class="string">"Unknown!"</span>)&#125;</code></pre><p>可以看到，在上述 switch 语句中， name 充当了 switch 表达式，而&quot; Go “和” Rust &quot;充当了 case 表达式。它们的结果类型是一致的，都是 string 。顺便说一句，可以有只包含一个字面量或标识符的表达式。它们是最简单的表达式，属于基本表达式的一种。</p><p>请大家注意 switch 语句的写法。 switch 表达式必须紧随 switch 关键字出现。在后面的花括号中，一个关键字 case、case 表达式、冒号以及后跟的若干条语句组成为一条 case 语句。在 switch 语句中可以有若干条 case 语句。 Go 语言会依照从上至下的顺序对每一条 case 语句中 case 表达式进行求值。只要被发现其表达式与 switch 表达式的结果相同，该 case 语句就会被选中。它包含的那些语句就会被执行。而其余的 case 语句则会被忽略。</p><p>switch 语句中还可以存在一个特殊的 <strong>case——default case</strong> 。顾名思义，当没有一个常规的 case 被选中的时候，default case 就会被选中。上面示例中就存在一个default case 。它由关键字 default 、冒号和后跟的一条语句组成。实际上， default case 不一定被追加在最后。它可以是第一个 case ，或者出现在任意顺位上。</p><p>另外，与 if 语句一样， switch 语句还可以包含初始化子句，且其出现位置和写法也如出一辙。如：</p><pre><code class="highlight go">names := []<span class="keyword">string</span>&#123;<span class="string">"Golang"</span>, <span class="string">"Java"</span>, <span class="string">"Rust"</span>, <span class="string">"C"</span>&#125;<span class="keyword">switch</span> name := names[<span class="number">0</span>]; name &#123;<span class="keyword">case</span> <span class="string">"Golang"</span>:    fmt.Println(<span class="string">"A programming language from Google."</span>)<span class="keyword">case</span> <span class="string">"Rust"</span>:    fmt.Println(<span class="string">"A programming language from Mozilla."</span>)<span class="keyword">default</span>:    fmt.Println(<span class="string">"Unknown!"</span>)&#125;</code></pre><p>另一个类型 switch 语句。它与一般形式有两点差别。第一点，紧随 case 关键字的不是表达式，而是类型说明符。类型说明符由若干个类型字面量组成，且多个类型字面量之间由英文逗号分隔。第二点，它的 switch 表达式是非常特殊的。这种特殊的表达式也起到了类型断言的作用，但其表现形式很特殊，如：v.(type)，其中 v 必须代表一个接口类型的值。注意，该类表达式只能出现在类型 switch 语句中，且只能充当 switch 表达式。一个类型 switch 语句的示例如下：</p><pre><code class="highlight go">v := <span class="number">11</span><span class="keyword">switch</span> i := <span class="keyword">interface</span>&#123;&#125;(v).(<span class="keyword">type</span>) &#123;<span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>:    fmt.Printf(<span class="string">"A signed integer: %d. The type is %T. \n"</span>, i, i)<span class="keyword">case</span> <span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>:    fmt.Printf(<span class="string">"A unsigned integer: %d. The type is %T. \n"</span>, i, i)<span class="keyword">default</span>:    fmt.Println(<span class="string">"Unknown!"</span>)&#125;</code></pre><p>请注意，我们在这里把 switch 表达式的结果赋给了一个变量。如此一来，我们就可以在该 switch 语句中使用这个结果了。这段代码被执行后，标准输出上会打印出 <code>A signed integer: 11. The type is int.</code>。</p><p>最后，我们来说一下 fallthrough 。它既是一个关键字，又可以代表一条语句。 fallthrough 语句可被包含在表达式 switch 语句中的 case 语句中。它的作用是使控制权流转到下一个 case 。不过要注意， fallthrough 语句仅能作为 case 语句中的最后一条语句出现。并且，包含它的 case 语句不能是其所属 switch 语句的最后一条 case 语句。</p><h4 id="for-语句">for 语句</h4><p>for 语句代表着循环。一条语句通常由关键字 for 、初始化子句、条件表达式、后置子句和以花括号包裹的代码块组成。其中，初始化子句、条件表达式和后置子句之间需用分号分隔。示例如下：</p><pre><code class="highlight go"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;    fmt.Print(i, <span class="string">" "</span>)&#125;</code></pre><p>我们可以省略掉初始化子句、条件表达式、后置子句中的任何一个或多个，不过起到分隔作用的分号一般需要被保留下来，除非在仅有条件表达式或三者全被省略时分号才可以被一同省略。</p><p>我们可以把上述的初始化子句、条件表达式、后置子句合称为for子句。实际上，for语句还有另外一种编写方式，那就是用 range 子句替换掉 for 子句。 range 子句包含一个或两个迭代变量（用于与迭代出的值绑定）、特殊标记 := 或 = 、关键字 range 以及 range 表达式。其中， range 表达式的结果值的类型应该是能够被迭代的，包括：字符串类型、数组类型、数组的指针类型、切片类型、字典类型和通道类型。例如：</p><pre><code class="highlight go"><span class="keyword">for</span> i, v := <span class="keyword">range</span> <span class="string">"Go语言"</span> &#123;    fmt.Printf(<span class="string">"%d: %c\n"</span>, i, v)&#125;</code></pre><p>对于字符串类型的被迭代值来说，for语句每次会迭代出两个值。第一个值代表第二个值在字符串中的索引，而第二个值则代表该字符串中的某一个字符。迭代是以索引递增的顺序进行的。例如，上面的 for 语句被执行后会在标准输出上打印出：</p><pre><code class="highlight plain">0: G1: o2: 语5: 言</code></pre><p>可以看到，这里迭代出的索引值并不是连续的。下面我们简单剖析一下此表象的本质。我们知道，字符串的底层是以字节数组的形式存储的。而在 Go 语言中，字符串到字节数组的转换是通过对其中的每个字符进行 UTF-8 编码来完成的。字符串&quot;Go语言&quot;中的每一个字符与相应的字节数组之间的对应关系如下：</p><p><img src="/img/blog_img/golang-for.jpeg" alt="for"></p><blockquote><p>注意，一个中文字符在经过 UTF-8 编码之后会表现为三个字节。所以，我们用 <code>语[0]、语[1]和、语[2]</code> 分别表示字符’语’经编码后的第一、二、三个字节。对于字符’言’，我们如法炮制。</p></blockquote><p>对照这张表格，我们就能够解释上面那条 for 语句打印出的内容了，即：<strong>每次迭代出的第一个值所代表的是第二个字符值经编码后的第一个字节在该字符串经编码后的字节数组中的索引值</strong>。</p><p>对于数组值、数组的指针值和切片之来说，range 子句每次也会迭代出两个值。其中，第一个值会是第二个值在被迭代值中的索引，而第二个值则是被迭代值中的某一个元素。同样的，迭代是以<strong>索引递增</strong>的顺序进行的。</p><p>对于字典值来说，range 子句每次仍然会迭代出两个值。显然，第一个值是字典中的某一个键，而第二个值则是该键对应的那个值。</p><blockquote><p>注意，对字典值上的迭代， Go 语言是不保证其顺序的。</p></blockquote><p>携带 range 子句的 for 语句还可以应用于一个通道值之上。其作用是不断地从该通道值中接收数据，不过每次只会接收一个值。注意，如果通道值中没有数据，那么 for 语句的执行会处于阻塞状态。无论怎样，这样的循环会一直进行下去。直至该通道值被关闭，for 语句的执行才会结束。</p><p>最后，我们来说一下 break 语句和 continue 语句。它们都可以被放置在 for 语句的代码块中。前者被执行时会使其所属的 for 语句的执行立即结束，而后者被执行时会使当次迭代被中止（当次迭代的后续语句会被忽略）而直接进入到下一次迭代。</p><h4 id="select-语句">select 语句</h4><p>select 语句属于条件分支流程控制方法，<strong>不过它只能用于通道</strong>。它可以包含若干条 case 语句，并根据条件选择其中的一个执行。进一步说， select 语句中的 case 关键字只能后跟<strong>用于通道的发送操作的表达式以及接收操作的表达式或语句</strong>。示例如下：</p><pre><code class="highlight go">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)<span class="comment">// 省略若干条语句</span><span class="keyword">select</span> &#123;<span class="keyword">case</span> e1 := &lt;-ch1:    fmt.Printf(<span class="string">"1th case is selected. e1=%v.\n"</span>, e1)<span class="keyword">case</span> e2 := &lt;-ch2:    fmt.Printf(<span class="string">"2th case is selected. e2=%v.\n"</span>, e2)<span class="keyword">default</span>:    fmt.Println(<span class="string">"No data!"</span>)&#125;</code></pre><p>如果该 select 语句被执行时通道 ch1 和 ch2 中都没有任何数据，那么肯定只有 default case 会被执行。但是，只要有一个通道在当时有数据就不会轮到 default case 执行了。显然，对于包含通道接收操作的 case 来讲，其执行条件就是通道中存在数据（或者说通道未空）。如果在当时有数据的通道多于一个，那么 Go 语言会通过一种伪随机的算法来决定哪一个 case 将被执行。</p><p>另一方面，对于包含通道发送操作的 case 来讲，其执行条件就是通道中至少还能缓冲一个数据（或者说通道未满）。类似的，当有多个 case 中的通道未满时，它们会被随机选择。请看下面的示例：</p><pre><code class="highlight go">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)<span class="comment">// 省略若干条语句</span><span class="keyword">select</span> &#123;<span class="keyword">case</span> ch3 &lt;- <span class="number">1</span>:    fmt.Printf(<span class="string">"Sent %d\n"</span>, <span class="number">1</span>)<span class="keyword">case</span> ch3 &lt;- <span class="number">2</span>:    fmt.Printf(<span class="string">"Sent %d\n"</span>, <span class="number">2</span>)<span class="keyword">default</span>:    fmt.Println(<span class="string">"Full channel!"</span>)&#125;</code></pre><p>该条 select 语句的两个 case 中包含的都是针对通道 ch3 的发送操作。如果我们把这条语句置于一个循环中，那么就相当于用有限范围的随机整数集合去填满一个通道。</p><blockquote><p>请注意，如果一条 select 语句中不存在 default case ， 并且在被执行时其中的所有 case 都不满足执行条件，那么它的执行将会被阻塞！当前流程的进行也会因此而停滞。直到其中一个 case 满足了执行条件，执行才会继续。我们一直在说 case 执行条件的满足与否取决于其操作的通道在当时的状态。这里特别强调一点，即：未被初始化的通道会使操作它的 case 永远满足不了执行条件。对于针对它的发送操作和接收操作来说都是如此。</p></blockquote><p>最后提一句， break 语句也可以被包含在 select 语句中的 case 语句中。它的作用是立即结束当前的 select 语句的执行，不论其所属的 case 语句中是否还有未被执行的语句。</p><h3 id="更多流程控制">更多流程控制</h3><h4 id="defer-语句">defer 语句</h4><p>与 select 语句一样， Go 语言中的 defer 语句也非常独特，而且比前者有过之而无不及。 defer 语句仅能被放置在函数或方法中。它由关键字 defer 和一个调用表达式组成。注意，这里的调用表达式所表示的既不能是对 Go 语言内建函数的调用也不能是对 Go 语言标准库代码包 unsafe 中的那些函数的调用。实际上，满足上述条件的调用表达式被称为表达式语句。请看下面的示例：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;    file, err := os.Open(path)    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;        <span class="keyword">return</span> <span class="literal">nil</span>, err    &#125;    <span class="keyword">defer</span> file.Close()    <span class="keyword">return</span> ioutil.ReadAll(file)&#125;</code></pre><p>函数 readFile 的功能是读出指定文件或目录（以下统称为文件）本身的内容并将其返回，同时当有错误发生时立即向调用方报告。其中， os 和 ioutil （导入路径是 io/ioutil ）代表的都是 Go 语言标准库中的代码包。请注意这个函数中的倒数第二条语句。我们在打开指定文件且未发现有错误发生之后，紧跟了一条 defer 语句。其中携带的表达式语句表示的是对被打开文件的关闭操作。注意，当这条 defer 语句被执行的时候，其中的这条表达式语句并不会被立即执行。它的确切的执行时机是在其所属的函数（这里是 readFile ）的执行即将结束的那个时刻。也就是说，在 readFile 函数真正结束执行的前一刻， file.Close() 才会被执行。这也是 defer 语句被如此命名的原因。我们在结合上下文之后就可以看出，语句 defer file.Close() 的含义是在打开文件并读取其内容后及时地关闭它。该语句可以保证在 readFile 函数将结果返回给调用方之前，那个文件或目录一定会被关闭。这实际上是一种非常便捷和有效的保险措施。</p><p>更为关键的是，无论 readFile 函数正常地返回了结果还是由于在其执行期间有运行时恐慌发生而被剥夺了流程控制权，其中的 file.Close() 都会在该函数即将退出那一刻被执行。这就更进一步地保证了资源的及时释放。</p><p>注意，当一个函数中存在多个 defer 语句时，它们携带的表达式语句的执行顺序一定是它们的出现顺序的倒序。下面的示例可以很好的证明这一点：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">deferIt</span><span class="params">()</span></span> &#123;    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        fmt.Print(<span class="number">1</span>)    &#125;()    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        fmt.Print(<span class="number">2</span>)    &#125;()    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        fmt.Print(<span class="number">3</span>)    &#125;()    fmt.Print(<span class="number">4</span>)&#125;</code></pre><p>deferIt 函数的执行会使标准输出上打印出 4321 。请大家猜测下面这个函数被执行时向标准输出打印的内容，并真正执行它以验证自己的猜测。最后论证一下自己的猜测为什么是对或者错的。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">deferIt2</span><span class="params">()</span></span> &#123;    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">5</span>; i++ &#123;        <span class="keyword">defer</span> fmt.Print(i)    &#125;&#125;</code></pre><p>最后，对于 defer 语句，我还有两个特别提示：</p><ol><li>defer 携带的表达式语句代表的是对某个函数或方法的调用。这个调用可能会有参数传入，比如：fmt.Print(i + 1) 。如果代表传入参数的是一个表达式，那么在 defer 语句被执行的时候该表达式就会被求值了。注意，这与被携带的表达式语句的执行时机是不同的。请揣测下面这段代码的执行：</li></ol><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">deferIt3</span><span class="params">()</span></span> &#123;    f := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;        fmt.Printf(<span class="string">"%d "</span>,i)        <span class="keyword">return</span> i * <span class="number">10</span>    &#125;    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">5</span>; i++ &#123;        <span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, f(i))    &#125;&#125;</code></pre><p>它在被执行之后，标准输出上打印出1 2 3 4 40 30 20 10 。</p><ol start="2"><li>如果 defer 携带的表达式语句代表的是对匿名函数的调用，那么我们就一定要非常警惕。请看下面的示例：</li></ol><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">deferIt4</span><span class="params">()</span></span> &#123;    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">5</span>; i++ &#123;        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;            fmt.Print(i)        &#125;()    &#125;&#125;</code></pre><p>deferIt4 函数在被执行之后标出输出上会出现 5555 ，而不是 4321 。原因是 defer 语句携带的表达式语句中的那个匿名函数包含了对外部（确切地说，是该 defer 语句之外）的变量的使用。注意，等到这个匿名函数要被执行（且会被执行 4 次）的时候，包含该 defer 语句的那条 for 语句已经执行完毕了。此时的变量 i 的值已经变为了 5 。因此该匿名函数中的打印函数只会打印出 5 。正确的用法是：把要使用的外部变量作为参数传入到匿名函数中。修正后的 deferIt4 函数如下：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">deferIt4</span><span class="params">()</span></span> &#123;    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">5</span>; i++ &#123;        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;            fmt.Print(n)        &#125;(i)    &#125;&#125;</code></pre><h4 id="异常处理-error">异常处理 error</h4><p>Go 语言的函数可以一次返回多个结果。这就为我们温和地报告错误提供了语言级别的支持。实际上，这也是 Go 语言中处理错误的惯用法之一。</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;    file, err := os.Open(path)    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;        <span class="keyword">return</span> <span class="literal">nil</span>, err    &#125;    <span class="keyword">defer</span> file.Close()    <span class="keyword">return</span> ioutil.ReadAll(file)&#125;</code></pre><p>函数 readFile 有两个结果声明。第二个结果声明的类型是 error 。 error 是 Go 语言内置的一个接口类型。它的声明是这样的：</p><pre><code class="highlight go"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;     Error() <span class="keyword">string</span>&#125;</code></pre><p>显然，只要一个类型的方法集合包含了名为 Error 、无参数声明且仅声明了一个 string 类型的结果的方法，就相当于实现了 error 接口。 os.Open 函数的第二个结果值就的类型就是这样的。我们把它赋给了变量 err 。也许你已经意识到，在 Go 语言中，函数与其调用方之间温和地传递错误的方法即是如此。</p><p>在调用了 os.Open 函数并取得其结果之后，我们判断 err 是否为 nil 。如果答案是肯定的，那么就直接把该错误（这里由 err 代表）返回给调用方。这条 if 语句实际上是一条卫述语句。这样的语句会检查流程中的某个步骤是否存在异常，并在必要时中止流程并报告给上层的程序（这里是调用方）。在 Go 语言的标准库以及很多第三方库中，我们经常可以看到这样的代码。我们也建议大家在自己的程序中善用这样的卫述语句。</p><p>现在我们把目光聚焦到 readFile 函数中的最后一条语句上。这是一条 return 语句。它把对 ioutil.ReadAll 函数的调用的结果直接作为 readFile 函数的结果返回了。实际上， ioutil.ReadAll 函数的结果声明列表与 readFile 的结果声明列表是一致的。也就是说，它们声明的结果的数量、类型和顺序都是相同的。因此，我们才能够做这种返回结果上的“嫁接”。这又是一个 Go 语言编码中的惯用法。</p><p>好了，在知晓怎样在传递错误之后，让我们来看看怎样创造错误。没错，在很多时候，我们需要创造出错误（即 error 类型的值）并把它传递给上层程序。这很简单。只需调用标准库代码包 errors 的 New 函数即可。例如，我们只要在 readFile 函数的开始处加入下面这段代码就可以更快的在参数值无效时告知调用方：</p><pre><code class="highlight go"><span class="keyword">if</span> path == <span class="string">""</span> &#123;    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"The parameter is invalid!"</span>)&#125;</code></pre><p>errors.New 是一个很常用的函数。在 Go 语言标准库的代码包中有很多由此函数创建出来的错误值，比如 os.ErrPermission 、 io.EOF 等变量的值。我们可以很方便地用操作符 == 来判断一个 error 类型的值与这些变量的值是否相等，从而来确定错误的具体类别。就拿 io.EOF 来说，它代表了一个信号。该信号用于通知数据读取方已无更多数据可读。我们在得到这样一个错误的时候不应该把它看成一个真正的错误，而应该只去结束相应的读取操作。请看下面的示例：</p><pre><code class="highlight go">br := bufio.NewReader(file)<span class="keyword">var</span> buf bytes.Buffer<span class="keyword">for</span> &#123;    ba, isPrefix, err := br.ReadLine()    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;        <span class="keyword">if</span> err == io.EOF &#123;            <span class="keyword">break</span>        &#125;        fmt.Printf(<span class="string">"Error: %s\n"</span>, err)        <span class="keyword">break</span>    &#125;    buf.Write(ba)    <span class="keyword">if</span> !isPrefix &#123;        buf.WriteByte(<span class="string">'\n'</span>)    &#125;&#125;</code></pre><p>可以看到，这段代码使用到了前面示例中的变量 file 。它的功能是把 file 代表的文件中的所有内容都读取到一个缓冲器（由变量 buf 代表）中。请注意，该示例中的第 6 ~ 8 行代码。如果判定 err 代表的错误值等于 io.EOF 的值（即它们是同一个值），那么我们只需退出当前的循环以使读取操作结束即可。</p><p>总之，只要能够善用 error 接口、 errors.New 函数和比较操作符==，我们就可以玩儿转 Go 语言中的一般错误处理。</p><h4 id="异常处理-panic">异常处理 panic</h4><p>panic 可被意译为运行时恐慌。因为它只有在程序运行的时候才会被“抛出来”。并且，恐慌是会被扩散的。当有运行时恐慌发生时，它会被迅速地向调用栈的上层传递。如果我们不显式地处理它的话，程序的运行瞬间就会被终止。这里有一个专有名词——程序崩溃。内建函数 panic 可以让我们人为地产生一个运行时恐慌。不过，这种致命错误是可以被恢复的。在 Go 语言中，内建函数 recover 就可以做到这一点。</p><p>实际上，内建函数 panic 和 recover 是天生的一对。前者用于产生运行时恐慌，而后者用于“恢复”它。不过要注意， recover 函数必须要在 defer 语句中调用才有效。因为一旦有运行时恐慌发生，当前函数以及在调用栈上的所有代码都是失去对流程的控制权。只有 defer 语句携带的函数中的代码才可能在运行时恐慌迅速向调用栈上层蔓延时“拦截到”它。这里有一个可以起到此作用的 defer 语句的示例：</p><pre><code class="highlight go"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;    <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;        fmt.Printf(<span class="string">"Fatal error: %s\n"</span>, p)    &#125;&#125;()</code></pre><p>在这条 defer 语句中，我们调用了 recover 函数。该函数会返回一个 interface{} 类型的值。还记得吗？ interface{} 代表空接口。 Go 语言中的任何类型都是它的实现类型。我们把这个值赋给了变量 p 。如果 p 不为 nil ，那么就说明当前确有运行时恐慌发生。这时我们需根据情况做相应处理。注意，一旦 defer 语句中的 recover 函数调用被执行了，运行时恐慌就会被恢复，不论我们是否进行了后续处理。所以，我们一定不要只“拦截”不处理。</p><p>我们下面来反观 panic 函数。该函数可接受一个 interface{} 类型的值作为其参数。也就是说，我们可以在调用 panic 函数的时候可以传入任何类型的值。不过，我建议大家在这里只传入 error 类型的值。这样它表达的语义才是精确的。更重要的是，当我们调用 recover 函数来“恢复”由于调用 panic 函数而引发的运行时恐慌的时候，得到的值正是调用后者时传给它的那个参数。因此，有这样一个约定是很有必要的。</p><p>总之，运行时恐慌代表程序运行过程中的致命错误。我们只应该在必要的时候引发它。人为引发运行时恐慌的方式是调用 panic 函数。 recover 函数是我们常会用到的。因为在通常情况下，我们肯定不想因为运行时恐慌的意外发生而使程序崩溃。最后，在“恢复”运行时恐慌的时候，大家一定要注意处理措施的得当。</p><h4 id="go-语句">go 语句</h4><p>go 语句和通道类型是 Go 语言的并发编程理念的最终体现。相比之下， go 语句在用法上要比通道简单很多。与 defer 语句相同， go 语句也可以携带一条表达式语句。</p><blockquote><p>注意，go 语句的执行会很快结束，并不会对当前流程的进行造成阻塞或明显的延迟。一个简单的示例如下：</p></blockquote><pre><code class="highlight go"><span class="keyword">go</span> fmt.Println(<span class="string">"Go!"</span>)</code></pre><p>可以看到， go 语句仅由一个关键字 go 和一条表达式语句构成。同样的， go 语句的执行与其携带的表达式语句的执行在时间上没有必然联系。这里能够确定的仅仅是后者会在前者完成之后发生。在 go 语句被执行时，其携带的函数（也被称为 go 函数）以及要传给它的若干参数（如果有的话）会被封装成一个实体（即 Goroutine ），并被放入到相应的待运行队列中。 Go 语言的运行时系统会适时的从队列中取出待运行的 Goroutine 并执行相应的函数调用操作。注意，对传递给这里的函数的那些参数的求值会在 go 语句被执行时进行。这一点也是与 defer 语句类似的。</p><p>正是由于 go 函数的执行时间的不确定性，所以 Go 语言提供了很多方法来帮助我们协调它们的执行。其中最简单粗暴的方法就是调用 time.Sleep 函数。请看下面的示例：</p><pre><code class="highlight go"><span class="keyword">package</span> main<span class="keyword">import</span> (    <span class="string">"fmt"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">go</span> fmt.Println(<span class="string">"Go!"</span>)&#125;</code></pre><p>这样一个命令源码文件被运行时，标准输出上不会有任何内容出现。因为还没等 Go 语言运行时系统调度那个 go 函数执行，主函数 main 就已经执行完毕了。函数 main 的执行完毕意味着整个程序的执行的结束。因此，这个 go 函数根本就没有执行的机会。</p><p>但是，当我们在上述 go 语句的后面添加一条对 time.Sleep 函数的调用语句之后情况就会不同了：</p><pre><code class="highlight go"><span class="keyword">package</span> main<span class="keyword">import</span> (    <span class="string">"fmt"</span>    <span class="string">"time"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">go</span> fmt.Println(<span class="string">"Go!"</span>)    time.Sleep(<span class="number">100</span> * time.Millisecond)&#125;</code></pre><p>语句 time.Sleep(100 * time.Millisecond) 会把 main 函数的执行结束时间向后延迟 100 毫秒。 100 毫秒虽短暂，但足够 go 函数被调度执行的了。上述命令源码文件在被运行时会如我们所愿地在标准输出上打印出 Go! 。</p><p>另一个比较绅士的做法是在 main 函数的最后调用 <code>runtime.Gosched</code> 函数。相应的程序版本如下：</p><pre><code class="highlight go"><span class="keyword">package</span> main<span class="keyword">import</span> (    <span class="string">"fmt"</span>    <span class="string">"runtime"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">go</span> fmt.Println(<span class="string">"Go!"</span>)    runtime.Gosched()&#125;</code></pre><p>runtime.Gosched 函数的作用是让当前正在运行的 Goroutine （这里是运行 main 函数的那个 Goroutine ）暂时“休息”一下，而让 Go 运行时系统转去运行其它的 Goroutine （这里是与 <code>go fmt.Println(&quot;Go!&quot;)</code> 对应并会封装 <code>fmt.Println(&quot;Go!&quot;)</code> 的那个 Goroutine ）。如此一来，我们就更加精细地控制了对几个 Goroutine 的运行的调度。</p><p>当然，我们还有其它方法可以满足上述需求。并且，如果我们需要去左右更多的 Goroutine 的运行时机的话，下面这种方法也许更合适一些。请看代码：</p><pre><code class="highlight go"><span class="keyword">package</span> main<span class="keyword">import</span> (    <span class="string">"fmt"</span>    <span class="string">"sync"</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">var</span> wg sync.WaitGroup    wg.Add(<span class="number">3</span>)    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        fmt.Println(<span class="string">"Go!"</span>)        wg.Done()    &#125;()    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        fmt.Println(<span class="string">"Go!"</span>)        wg.Done()    &#125;()    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        fmt.Println(<span class="string">"Go!"</span>)        wg.Done()    &#125;()    wg.Wait()&#125;</code></pre><p>sync.WaitGroup 类型有三个方法可用—— Add、 Done 和 Wait 。 Add 会使其所属值的一个内置整数得到相应增加， Done 会使那个整数减 1 ，而 Wait 方法会使当前 Goroutine（这里是运行 main 函数的那个 Goroutine ）阻塞直到那个整数为 0 。这下你应该明白上面这个示例所采用的方法了。我们在 main 函数中启用了三个 Goroutine 来封装三个 go 函数。每个匿名函数的最后都调用了 wg.Done 方法，并以此表达当前的 go 函数会立即执行结束的情况。当这三个 go 函数都调用过 wg.Done 函数之后，处于 main 函数最后的那条 wg.Wait() 语句的阻塞作用将会消失， main 函数的执行将立即结束。</p><h2 id="总结">总结</h2><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;关于 golang 入门的笔记。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/backend/a-preliminary-study-of-golang-language1.html&quot;&gt;golang语言初探一&lt;/a&gt;&lt;/li
      
    
    </summary>
    
    
      <category term="backend" scheme="http://www.kavience.com/categories/backend/"/>
    
    
      <category term="golang" scheme="http://www.kavience.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang语言初探二</title>
    <link href="http://www.kavience.com/backend/a-preliminary-study-of-golang-language2.html"/>
    <id>http://www.kavience.com/backend/a-preliminary-study-of-golang-language2.html</id>
    <published>2021-05-18T01:54:55.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>关于 golang 入门的笔记。</p><ul><li><a href="/backend/a-preliminary-study-of-golang-language1.html">golang语言初探一</a></li><li>golang语言初探二</li><li><a href="/backend/a-preliminary-study-of-golang-language3.html">golang语言初探三</a></li></ul><h2 id="why">why</h2><p>周末的时候研究了一下 golang 相关的文档，根据自己的工作经验，我觉得这门语言在未来一定会大放异彩，其实现在也比较热门了。主要有以下几个特点：</p><ul><li>语法简单，golang 的关键字才 25 个，入门也非常简单</li><li>天然支持高并发，适用于大型微服务应用</li><li>跨平台，可编译出支持各大主流平台的应用，且毫无依赖</li></ul><p>经过对 golang 的这些了解，顿时感觉有点兴趣了，在这里记录一些入门的资料。</p><h2 id="how">how</h2><h3 id="高级数据类型">高级数据类型</h3><h4 id="数组类型">数组类型</h4><p>个数组（Array）就是一个可以容纳若干类型相同的元素的容器。这个容器的大小（即数组的长度）是固定的，且是体现在数组的类型字面量之中的。比如，我们声明了一个数组类型：</p><pre><code class="highlight go"><span class="keyword">type</span> MyNumbers [<span class="number">3</span>]<span class="keyword">int</span></code></pre><blockquote><p>注：类型声明语句由关键字type、类型名称和类型字面量组成。</p></blockquote><blockquote><p>所谓类型字面量，就是用于表示某个类型的字面表示（或称标记方法）。相对的，用于表示某个类型的值的字面表示可被称为值字面量，或简称为字面量。比如之前提到过的3.7E-2就可被称为浮点数字面量。 类型字面量[3]int由两部分组成。第一部分是由方括号包裹的数组长度，即[3]。这也意味着，一个数组的长度是该数组的类型的组成部分，是固定不变的。该类型字面量的第二个组成部分是int。它代表了该数组可以容纳的元素的类型。说到这里，上面这条类型声明语句实际上是为数组类型[3]int声明了一个别名类型。这使得我们可以把 MyNumbers 当做数组类型[3]int来使用。</p></blockquote><p>我们表示这样一个数组类型的值的时候，应该把该类型的类型字面量写在最左边，然后用花括号包裹该值包含的若干元素。各元素之间以（英文半角）逗号分隔，即：</p><pre><code class="highlight go">[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre><p>现在，我们把这个数组字面量赋给一个名为 numbers 的变量：</p><pre><code class="highlight go"><span class="keyword">var</span> numbers = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre><blockquote><p>注：这是一条变量声明语句。它在声明变量的同时为该变量赋值。</p></blockquote><p>另一种便捷方法是，在其中的类型字面量中省略代表其长度的数字，像这样：</p><pre><code class="highlight go"><span class="keyword">var</span> numbers = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre><p>这样就可以免去我们为填入那个数字而数出元素个数的工作了。</p><p>接下来，我们可以很方便地使用索引表达式来访问该变量的值中的任何一个元素，例如：</p><pre><code class="highlight go">numbers[<span class="number">0</span>] <span class="comment">// 会得到第一个元素</span>numbers[<span class="number">1</span>] <span class="comment">// 会得到第二个元素</span>numbers[<span class="number">2</span>] <span class="comment">// 会得到第三个元素</span></code></pre><blockquote><p>注：索引表达式由字符串、数组、切片或字典类型的值（或者代表此类值的变量或常量）和由方括号包裹的索引值组成。在这里，索引值的有效范围是[0, 3)。也就是说，对于数组来说，索引值既不能小于0也不能大于或等于数组值的长度。另外要注意，索引值的最小有效值总是 0，而不是 1 。</p></blockquote><p>相对的，如果我们想修改数组值中的某一个元素值，那么可以使用赋值语句直接达到目的。例如，我们要修改 numbers 中的第二个元素的话，如此即可：</p><pre><code class="highlight go">numbers[<span class="number">1</span>] = <span class="number">4</span></code></pre><p>虽然数组的长度已经体现在了它的类型字面量，但是我们在很多时候仍然需要明确的获得它，像这样：</p><pre><code class="highlight go"><span class="keyword">var</span> length = <span class="built_in">len</span>(numbers)</code></pre><blockquote><p>注：len是Go语言的内建函数的名称。该函数用于获取字符串、数组、切片、字典或通道类型的值的长度。我们可以在Go语言源码文件中直接使用它。</p></blockquote><p>最后，要注意，如果我们只声明一个数组类型的变量而不为它赋值，那么该变量的值将会是指定长度的、其中各元素均为元素类型的零值（或称默认值）的数组值。例如，若有这样一个变量：</p><pre><code class="highlight go"><span class="keyword">var</span> numbers2 [<span class="number">5</span>]<span class="keyword">int</span></code></pre><p>则它的值会是</p><pre><code class="highlight go">[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</code></pre><h4 id="切片类型">切片类型</h4><p>切片（Slice）与数组一样，也是可以容纳若干类型相同的元素的容器。与数组不同的是，无法通过切片类型来确定其值的长度。每个切片值都会将数组作为其底层数据结构。我们也把这样的数组称为切片的底层数组。表示切片类型的字面量如：</p><pre><code class="highlight go">[]<span class="keyword">int</span><span class="comment">// 或</span>[]<span class="keyword">string</span></code></pre><p>可以看到，它们与数组的类型字面量的唯一不同是不包含代表其长度的信息。因此，不同长度的切片值是有可能属于同一个类型的。相对的，不同长度的数组值必定属于不同类型。对一个切片类型的声明可以这样：</p><pre><code class="highlight go"><span class="keyword">type</span> MySlice []<span class="keyword">int</span></code></pre><p>这时，类型 MySlice 即为切片类型 []int 的一个别名类型。除此之外，对切片值的表示也与数组值也极其相似，如：</p><pre><code class="highlight go">[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</code></pre><p>这样的字面量与数组（值）的字面量的区别也只在于最左侧的类型字面量。</p><p>操作数组值的方法也同样适用于切片值。不过，还有一种操作数组值的方法，这种操作的名称就叫“切片”。实施切片操作的方式就是切片表达式。举例如下：</p><pre><code class="highlight go"><span class="keyword">var</span> numbers3 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;<span class="keyword">var</span> slice1 = numbers3[<span class="number">1</span>:<span class="number">4</span>]</code></pre><p>请注意第二条赋值语句中在“ = ”右边那个部分。切片表达式一般由字符串、数组或切片的值以及由方括号包裹且由英文冒号“:”分隔的两个正整数组成。这两个正整数分别表示元素下界索引和元素上界索引。在本例中，切片表达式numbers3[1:4]的求值结果为[]int{2, 3, 4}。可见，切片表达式的求值结果相当于以元素下界索引和元素上界索引作为依据从被操作对象上“切下”而形成的新值。注意，被“切下”的部分不包含元素上界索引指向的元素。另外，切片表达式的求值结果会是切片类型的，且其元素类型与被“切片”的值的元素类型一致。实际上，slice1 这个切片值的底层数组正是 numbers3 的值。</p><p>实际上，我们也可以在一个切片值上实施切片操作。操作的方式与上述无异。请看下面这个例子：</p><pre><code class="highlight go"><span class="keyword">var</span> slice2 = slice1[<span class="number">1</span>:<span class="number">3</span>]</code></pre><p>据此，slice2 的值为[]int{3, 4}。注意，作为切片表达式求值结果的切片值的长度总是为元素上界索引与元素下界索引的差值。</p><p>除了长度，切片值以及数组值还有另外一个属性——容量。数组值的容量总是等于其长度。而切片值的容量则往往与其长度不同。</p><p><img src="/img/blog_img/golang-slice.jpeg" alt="slice"></p><p>如图所示，一个切片值的容量即为它的第一个元素值在其底层数组中的索引值与该数组长度的差值的绝对值。为了获取数组、切片或通道类型的值的容量，我们可以使用内建函数cap，如：</p><pre><code class="highlight go"><span class="keyword">var</span> capacity2 <span class="keyword">int</span> = <span class="built_in">cap</span>(slice2)</code></pre><p>最后，要注意，切片类型属于引用类型。它的零值即为 nil ，即空值。如果我们只声明一个切片类型的变量而不为它赋值，那么该变量的值将会是 nil 。例如，若有这样一个变量：</p><pre><code class="highlight go"><span class="keyword">var</span> slice3 []<span class="keyword">int</span></code></pre><p>则它的值会是 nil 。</p><p>在有些时候，我们还可以在方括号中放入第三个正整数，如下所示：</p><pre><code class="highlight go">numbers3[<span class="number">1</span>:<span class="number">4</span>:<span class="number">4</span>]</code></pre><p>这第三个正整数被称为容量上界索引。它的意义在于可以把作为结果的切片值的容量设置得更小。换句话说，它可以限制我们通过这个切片值对其底层数组中的更多元素的访问。下面举个例子。 numbers3 和 slice1 ，针对它们的赋值语句是这样的：</p><pre><code class="highlight go"><span class="keyword">var</span> numbers3 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;<span class="keyword">var</span> slice1 = numbers3[<span class="number">1</span>:<span class="number">4</span>]</code></pre><p>这时，变量 slice1 的值是 []int{2, 3, 4} 。但是我们可以通过如下操作将其长度延展得与其容量相同：</p><p>slice1 = slice1[:cap(slice1)]<br>通过此操作，变量 slice1 的值变为了 []int{2, 3, 4, 5} ，且其长度和容量均为 4 。现在，numbers3 的值中的索引值在 [1,5) 范围内的元素都被体现在了 slice1 的值中。这是以 numbers3 的值是 slice1 的值的底层数组为前提的。这意味着，我们可以轻而易举地通过切片值访问其底层数组中对应索引值更大的更多元素。如果我们编写的函数返回了这样一个切片值，那么得到它的程序很可能会通过这种技巧访问到本不应该暴露给它的元素。这是确确实实是一个安全隐患。</p><p>如果我们在切片表达式中加入了第三个索引（即容量上界索引），如：</p><pre><code class="highlight go"><span class="keyword">var</span> slice1 = numbers3[<span class="number">1</span>:<span class="number">4</span>:<span class="number">4</span>]</code></pre><p>那么在这之后，无论我们怎样做都无法通过 slice1 访问到 numbers3 的值中的第五个元素。因为这超出了我们刚刚设定的 slice1 的容量。如果我们指定的元素上界索引或容量上界索引超出了被操作对象的容量，那么就会引发一个运行时恐慌（程序异常的一种），而不会有求值结果返回。因此，这是一个有力的访问控制手段。</p><p>虽然切片值在上述方面受到了其容量的限制，但是我们却可以通过另外一种手段对其进行不受任何限制地扩展。这需要使用到内建函数append。append会对切片值进行扩展并返回一个新的切片值。使用方法如下：</p><pre><code class="highlight go">slice1 = <span class="built_in">append</span>(slice1, <span class="number">6</span>, <span class="number">7</span>)</code></pre><p>通过上述操作，slice1的值变为了[]int{2, 3, 4, 6, 7}。注意，一旦扩展操作超出了被操作的切片值的容量，那么该切片的底层数组就会被自动更换。这也使得通过设定容量上界索引来对其底层数组进行访问控制的方法更加严谨了。</p><p>我们要介绍的最后一种操作切片值的方法是“复制”。该操作的实施方法是调用 copy 函数。该函数接受两个类型相同的切片值作为参数，并会把第二个参数值中的元素复制到第一个参数值中的相应位置（索引值相同）上。这里有两点需要注意：</p><ol><li>这种复制遵循最小复制原则，即：被复制的元素的个数总是等于长度较短的那个参数值的长度。</li><li>与 append 函数不同， copy 函数会直接对其第一个参数值进行修改。</li></ol><p>举例如下：</p><pre><code class="highlight go"><span class="keyword">var</span> slice4 = []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;<span class="built_in">copy</span>(slice4, slice1)</code></pre><p>通过上述复制操作， slice4 会变为 []int{2, 3, 4, 6, 7, 0, 0} 。</p><h4 id="字典类型">字典类型</h4><p>Go语言的字典（ Map ）类型其实是哈希表（ Hash Table ）的一个实现。字典用于存储键-元素对（更通俗的说法是键-值对）的无序集合。</p><blockquote><p>注意，同一个字典中的每个键都是唯一的。如果我们在向字典中放入一个键值对的时候其中已经有相同的键的话，那么与此键关联的那个值会被新值替换。</p></blockquote><p>字典类型的字面量是 <code>map[K]T</code> 其中，“ K ”意为键的类型，而“ T ”则代表元素（或称值）的类型。如果我们要描述一个键类型为 int 、值类型为 string 的字典类型的话，应该这样写： <code>map[int]string</code></p><blockquote><p>注意，字典的键类型必须是可比较的，否则会引起错误。也就是说，它不能是切片、字典或函数类型。</p></blockquote><p>字典值的字面量表示法实际上与数组和切片的字面量表示法很相似。首先，最左边仍然是类型字面量，右边紧挨着由花括号包裹且有英文逗号分隔的键值对。每个键值对的键和值之间由英文冒号分隔。以字典类型map[int]string为例，它的值的字面量可以是这样的：</p><pre><code class="highlight go"><span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span>&#125;</code></pre><p>我们可以把这个值赋给一个变量：</p><pre><code class="highlight go">mm := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span>&#125;</code></pre><p>然后运用索引表达式取出字典中的值，就像这样：</p><pre><code class="highlight go">b := mm[<span class="number">2</span>]</code></pre><blockquote><p>注意，在这里，我们放入方括号中的不再是索引值（实际上，字典中的键值对也没有索引），而是与我们要取出的值对应的那个键。在上例中变量b的值必是字符串&quot; b &quot;。当然，也可以利用索引表达式来赋值，比如这样：</p></blockquote><pre><code class="highlight go">mm[<span class="number">2</span>] = b + <span class="string">"2"</span></code></pre><p>这使得字典 mm 中与键 2 对应的值变为了&quot; b2 &quot;。现在我们再来向 mm 添加一个键值对：<code>mm[4] = &quot;&quot;</code> 之后，在从中取出与 <code>4</code> 和 <code>5</code> 对应的值：</p><pre><code class="highlight go">d := mm[<span class="number">4</span>]e := mm[<span class="number">5</span>]</code></pre><p>此时，变量 d 和 e 的值都会是多少呢？答案是都为&quot;&quot;，即空字符串。对于变量 d 来说，由于在字典 mm 中与 4 对应的值就是&quot;&quot;，所以索引表达式 mm[4] 的求值结果必为&quot;&quot;。这理所应当。但是 mm[5] 的求值结果为什么也是空字符串呢？原因是，在 Go 语言中有这样一项规定，即：对于字典值来说，如果其中不存在索引表达式欲取出的键值对，那么就以它的值类型的空值（或称默认值）作为该索引表达式的求值结果。由于字符串类型的空值为&quot;&quot;，所以 mm[5] 的求值结果即为&quot;&quot;。</p><p>在不知道 mm 的确切值的情况下，我们无法得知 mm[5] 的求值结果意味着什么？它意味着 5 对应的值就是一个空字符串？还是说 mm 中根本就没有键为 5 的键值对？这无所判别。为了解决这个问题， Go 语言为我们提供了另外一个写法，即：</p><pre><code class="highlight go">e, ok := mm[<span class="number">5</span>]</code></pre><p>针对字典的索引表达式可以有两个求值结果。第二个求值结果是 bool 类型的。它用于表明字典值中是否存在指定的键值对。在上例中，变量 ok 必为 false 。因为 mm 中不存在以 5 为键的键值对。</p><p>从字典中删除键值对的方法非常简单，仅仅是调用内建函数 delete 而已，就像这样：</p><pre><code class="highlight go"><span class="built_in">delete</span>(mm, <span class="number">4</span>)</code></pre><p>无论 mm 中是否存在以 4 为键的键值对， delete 都会“无声”地执行完毕。我们用“有则删除，无则不做”可以很好地概括它的行为。</p><p>最后，与切片类型相同，字典类型属于引用类型。它的零值即为 nil 。</p><h4 id="通道类型">通道类型</h4><p>通道（ Channel ）是 Go 语言中一种非常独特的数据结构。它可用于在不同 Goroutine 之间传递类型化的数据，并且是并发安全的。相比之下，我们之前介绍的那些数据类型都不是并发安全的。这一点需要特别注意。</p><p>Goroutine（也称为 Go 程序）可以被看做是承载可被并发执行的代码块的载体。它们由 Go 语言的运行时系统调度，并依托操作系统线程（又称内核线程）来并发地执行其中的代码块。</p><p>通道类型的表示方法很简单，仅由<code>chan T</code>两部分组成。</p><p>在这个类型字面量中，左边是代表通道类型的关键字 chan ，而右边则是一个可变的部分，即代表该通道类型允许传递的数据的类型（或称通道的元素类型）。</p><p>与其它的数据类型不同，我们无法表示一个通道类型的值。因此，我们也无法用字面量来为通道类型的变量赋值。我们只能通过调用内建函数 make 来达到目的。 make 函数可接受两个参数。第一个参数是代表了将被初始化的值的类型的字面量（比如 chan int ），而第二个参数则是值的长度。例如，若我们想要初始化一个长度为 5 且元素类型为 int 的通道值，则需要这样写：</p><pre><code class="highlight go"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</code></pre><blockquote><p>实际上 make 函数也可以被用来初始化切片类型或字典类型的值。</p></blockquote><p>确切地说，通道值的长度应该被称为其缓存的尺寸。换句话说，它代表着通道值中可以暂存的数据的个数。注意，暂存在通道值中的数据是先进先出的。</p><p>下面，我们声明一个通道类型的变量，并为其赋值：</p><pre><code class="highlight go">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">5</span>)</code></pre><p>这样一来，我们就可以使用接收操作符 <code>&lt;-</code> 向通道值发送数据了。当然，也可以使用它从通道值接收数据。例如，如果我们要向通道 ch1 发送字符串 “value1” ，那么应该这样做：</p><pre><code class="highlight go">ch1 &lt;- <span class="string">"value1"</span></code></pre><p>另一方面，我们若想从ch1那里接收字符串，则要这样：</p><pre><code class="highlight go">value := &lt;- ch1</code></pre><p>与针对字典值的索引表达式一样，针对通道值的接收操作也可以有第二个结果值。</p><pre><code class="highlight go">value, ok := &lt;- ch1</code></pre><p>这样做的目的同样是为了消除与零值有关的歧义。这里的变量 ok 的值同样是 bool 类型的。它代表了通道值的状态， true 代表通道值有效，而 false 则代表通道值已无效（或称已关闭）。更深层次的原因是，如果在接收操作进行之前或过程中通道值被关闭了，则接收操作会立即结束并返回一个该通道值的元素类型的零值。按照上面的第一种写法，我们无从判断接收到零值的原因是什么。不过，有了第二个结果值之后，这种判断就好做了。</p><p>说到关闭通道值，我们可以通过调用内建函数 close 来达到目的，就像这样：</p><pre><code class="highlight go"><span class="built_in">close</span>(ch1)</code></pre><blockquote><p>注意，对通道值的重复关闭会引发运行时恐慌。这会使程序崩溃。所以一定要避免这种情况的发生。另外，在通道值有效的前提下，针对它的发送操作会在通道值已满（其中缓存的数据的个数已等于它的长度）时被阻塞。而向一个已被关闭的通道值发送数据会引发运行时恐慌。另一方面，针对有效通道值的接收操作会在它已空（其中没有缓存任何数据）时被阻塞。除此之外，还有几条与通道的发送和接收操作有关的规则。不过在这里我们记住上面这三条就可以了。</p></blockquote><p>通道有带缓冲和非缓冲之分。我们已经说过，缓冲通道中可以缓存 N 个数据。我们在初始化一个通道值的时候必须指定这个 N 。<strong>相对的，非缓冲通道不会缓存任何数据。发送方在向通道值发送数据的时候会立即被阻塞，直到有某一个接收方已从该通道值中接收了这条数据</strong>。非缓冲的通道值的初始化方法如下：</p><pre><code class="highlight go"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)</code></pre><p>注意，在这里，给予 make 函数的第二个参数值是 0 。</p><p>除了上述分类方法，我们还可以<strong>以数据在通道中的传输方向为依据来划分通道</strong>。默认情况下，通道都是双向的，即双向通道。如果数据只能在通道中单向传输，那么该通道就被称作单向通道。我们在初始化一个通道值的时候不能指定它为单向。但是，在编写类型声明的时候，我们却是可以这样做的。例如：</p><pre><code class="highlight go"><span class="keyword">type</span> Receiver &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></code></pre><p>类型 Receiver 代表了一个只可从中接收数据的单向通道类型。这样的通道也被称为接收通道。在关键字 chan 左边的接收操作符 <code>&lt;-</code> 形象地表示出了数据的流向。相对应的，如果我们想声明一个发送通道类型，那么应该这样：</p><pre><code class="highlight go"><span class="keyword">type</span> Sender <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></code></pre><p>这次 <code>&lt;-</code> 被放在了 chan 的右边，并且“箭头”直指“通道”。想必不用多说你也能明白了。我们可以把一个双向通道值赋予上述类型的变量，就像这样：</p><pre><code class="highlight go"><span class="keyword">var</span> myChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)<span class="keyword">var</span> sender Sender = myChannel<span class="keyword">var</span> receiver Receiver = myChannel</code></pre><p>但是，反之则是不行的。像下面这样的代码是通不过编译的：</p><pre><code class="highlight go"><span class="keyword">var</span> myChannel1 <span class="keyword">chan</span> <span class="keyword">int</span> = sender</code></pre><p>单向通道的主要作用是约束程序对通道值的使用方式。比如，我们调用一个函数时给予它一个发送通道作为参数，以此来约束它只能向该通道发送数据。又比如，一个函数将一个接收通道作为结果返回，以此来约束调用该函数的代码只能从这个通道中接收数据。这属于 API 设计的范畴。</p><p>最后，与切片和字典类型相同，通道类型属于引用类型。它的零值即为 nil 。</p><h4 id="函数">函数</h4><p>在 Go 语言中，函数是一等（ first-class ）类型。这意味着，我们可以把函数作为值来传递和使用。函数代表着这样一个过程：它接受若干输入（参数），并经过一些步骤（语句）的执行之后再返回输出（结果）。<strong>特别的是， Go 语言中的函数可以返回多个结果</strong>。</p><p>函数类型的字面量由关键字 func 、由圆括号包裹参数声明列表、空格以及可以由圆括号包裹的结果声明列表组成。其中，参数声明列表中的单个参数声明之间是由英文逗号分隔的。每个参数声明由参数名称、空格和参数类型组成。参数声明列表中的参数名称是可以被统一省略的。结果声明列表的编写方式与此相同。结果声明列表中的结果名称也是可以被统一省略的。并且，在只有一个无名称的结果声明时还可以省略括号。示例如下：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span><span class="params">(input1 <span class="keyword">string</span> ,input2 <span class="keyword">string</span>)</span> <span class="title">string</span></span></code></pre><p>这一类型字面量表示了一个接受两个字符串类型的参数且会返回一个字符串类型的结果的函数。如果我们在它的左边加入 type 关键字和一个标识符作为名称的话，那就变成了一个函数类型声明，就像这样：</p><pre><code class="highlight go"><span class="keyword">type</span> MyFunc <span class="function"><span class="keyword">func</span><span class="params">(input1 <span class="keyword">string</span> ,input2 <span class="keyword">string</span>)</span> <span class="title">string</span></span></code></pre><p>函数值（或简称函数）的写法与此不完全相同。编写函数的时候需要先写关键字 func 和函数名称，后跟参数声明列表和结果声明列表，最后是由花括号包裹的语句列表。例如：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(part1 <span class="keyword">string</span>, part2 <span class="keyword">string</span>)</span> <span class="params">(result <span class="keyword">string</span>)</span></span> &#123;    result = part1 + part2    <span class="keyword">return</span>&#125;</code></pre><p>我们在这里用到了一个小技巧：如果结果声明是带名称的，那么它就相当于一个已被声明但未被显式赋值的变量。我们可以为它赋值且在 return 语句中省略掉需要返回的结果值。显然，该函数还有一种更常规的写法：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(part1 <span class="keyword">string</span>, part2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;    <span class="keyword">return</span> part1 + part2&#125;</code></pre><blockquote><p>注意，函数 myFunc 是函数类型 MyFunc 的一个实现。<strong>实际上，只要一个函数的参数声明列表和结果声明列表中的数据类型的顺序和名称与某一个函数类型完全一致</strong>，前者就是后者的一个实现。请大家回顾上面的示例并深刻理解这句话。</p></blockquote><p>我们可以声明一个函数类型的变量，如：</p><pre><code class="highlight go"><span class="keyword">var</span> splice <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> <span class="title">string</span> // 等价于 <span class="title">var</span> <span class="title">splice</span> <span class="title">MyFunc</span></span></code></pre><p>然后把函数myFunc赋给它：</p><pre><code class="highlight go">splice = myFunc</code></pre><p>如此一来，我们就可以在这个变量之上实施调用动作了：</p><pre><code class="highlight go">splice(<span class="string">"1"</span>, <span class="string">"2"</span>)</code></pre><p>实际上，这是一个调用表达式。它由代表函数的标识符（这里是 splice ）以及代表调用动作的、由圆括号包裹的参数值列表组成。</p><p>如果你觉得上面对 splice 变量声明和赋值有些啰嗦，那么可以这样来简化它：</p><pre><code class="highlight go"><span class="keyword">var</span> splice = <span class="function"><span class="keyword">func</span><span class="params">(part1 <span class="keyword">string</span>, part2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;    <span class="keyword">return</span> part1 + part2&#125;</code></pre><p>在这个示例中，我们直接使用了一个<strong>匿名函数</strong>来初始化 splice 变量。顾名思义，匿名函数就是不带名称的函数值。匿名函数直接由函数类型字面量和由花括号包裹的语句列表组成。</p><blockquote><p>注意，这里的函数类型字面量中的参数名称是不能被忽略的。</p></blockquote><p>其实，我们还可以进一步简化——索性省去 splice 变量。既然我们可以在代表函数的变量上实施调用表达式，那么在匿名函数上肯定也是可行的。因为它们的本质是相同的。后者的示例如下：</p><pre><code class="highlight go"><span class="keyword">var</span> result = <span class="function"><span class="keyword">func</span><span class="params">(part1 <span class="keyword">string</span>, part2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;    <span class="keyword">return</span> part1 + part2&#125;(<span class="string">"1"</span>, <span class="string">"2"</span>)</code></pre><p>可以看到，在这个匿名函数之后的即是代表调用动作的参数值列表。注意，这里的 result 变量的类型不是函数类型，而与后面的匿名函数的结果类型是相同的。</p><p>最后，函数类型的零值是 nil 。这意味着，一个未被显式赋值的、函数类型的变量的值必为 nil 。</p><h4 id="结构体和方法">结构体和方法</h4><p>Go 语言的结构体类型（ Struct ）比函数类型更加灵活。它可以封装属性和操作。前者即是结构体类型中的字段，而后者则是结构体类型所拥有的方法。</p><p>结构体类型的字面量由关键字 type 、类型名称、关键字 struct ，以及由花括号包裹的若干字段声明组成。其中，每个字段声明独占一行并由字段名称（可选）和字段类型组成。示例如下：</p><pre><code class="highlight go"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;    Name   <span class="keyword">string</span>    Gender <span class="keyword">string</span>    Age    <span class="keyword">uint8</span>&#125;</code></pre><p>结构体类型 Person 中有三个字段，分别是 Name 、 Gender 和 Age 。我们可以用字面量创建出一个该类型的值，像这样：</p><pre><code class="highlight go">Person&#123;Name: <span class="string">"Robert"</span>, Gender: <span class="string">"Male"</span>, Age: <span class="number">33</span>&#125;</code></pre><p>可以看到，结构体值的字面量（或简称结构体字面量）由其类型的名称和由花括号包裹的若干键值对组成。</p><blockquote><p>注意，这里的键值对与字典字面量中的键值对的写法相似，但不相同。这里的键是其类型中的某个字段的名称（注意，它不是字符串字面量），而对应的值则是欲赋给该字段的那个值。另外，如果这里的键值对的顺序与其类型中的字段声明完全相同的话，我们还可以统一省略掉所有字段的名称，就像这样：</p></blockquote><pre><code class="highlight go">Person&#123;<span class="string">"Robert"</span>, <span class="string">"Male"</span>, <span class="number">33</span>&#125;</code></pre><p>当然，我们在编写某个结构体类型的值字面量时可以只对它的部分字段赋值，甚至不对它的任何字段赋值。这时，<strong>未被显式赋值的字段的值则为其类型的零值</strong>。注意，在上述两种情况下，字段的名称是不能被省略的。</p><p>与代表函数值的字面量类似，我们在编写一个结构体值的字面量时不需要先拟好其类型。这样的结构体字面量被称为匿名结构体。与匿名函数类似，我们在编写匿名结构体的时候需要先写明其类型特征（包含若干字段声明），再写出它的值初始化部分。下面，我们依照结构体类型 Person 创建一个匿名结构体：</p><pre><code class="highlight go">p := <span class="keyword">struct</span> &#123;    Name   <span class="keyword">string</span>    Gender <span class="keyword">string</span>    Age    <span class="keyword">uint8</span>&#125;&#123;<span class="string">"Robert"</span>, <span class="string">"Male"</span>, <span class="number">33</span>&#125;</code></pre><p>匿名结构体最大的用处就是在内部临时创建一个结构以封装数据，而不必正式为其声明相关规则。而在涉及到对外的场景中，<strong>强烈建议使用正式的结构体类型</strong>。</p><p>结构体类型可以拥有若干方法（<strong>注意，匿名结构体是不可能拥有方法的</strong>）。所谓方法，其实就是一种特殊的函数。它可以依附于某个自定义类型。方法的特殊在于它的声明包含了一个接收者声明。这里的接收者指代它所依附的那个类型。我们仍以结构体类型 Person 为例。下面是依附于它的一个名为 Grow 的方法的声明：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="params">(person *Person)</span> <span class="title">Grow</span><span class="params">()</span></span> &#123;    person.Age++&#125;</code></pre><p>如上所示，在关键字 func 和名称 Grow 之间的那个圆括号及其包含的内容就是接收者声明。其中的内容由两部分组成。第一部分是代表它依附的那个类型的值的标识符。第二部分是它依附的那个类型的名称。<strong>后者表明了依附关系</strong>，而前者则使得在该方法中的代码可以使用到该类型的值（也称为当前值）。代表当前值的那个标识符可被称为接收者标识符，或简称为接收者。请看下面的示例：</p><pre><code class="highlight go">p := Person&#123;<span class="string">"Robert"</span>, <span class="string">"Male"</span> <span class="number">33</span>&#125;p.Grow()</code></pre><p>我们可以直接在 Person 类型的变量 p 之上应用调用表达式来调用它的方法 Grow 。注意，此时方法 Grow 的接收者标识符 person 指代的正是变量 p 的值。这也是“当前值”这个词的由来。在 Grow 方法中，我们通过使用选择表达式选择了当前值的字段 Age ，并使其自增。因此，在语句 p.Grow() 被执行之后， p 所代表的那个人就又年长了一岁（ p 的 Age 字段的值已变为 34 ）。</p><blockquote><p>需要注意的是，在 Grow 方法的接收者声明中的那个类型是 *Person ，而不是 Person 。实际上，前者是后者的指针类型。这也使得 person 指代的是 p 的指针，而不是它本身。</p></blockquote><p>说到这里，熟悉面向对象编程的同学可能已经意识到，包含若干字段和方法的结构体类型就相当于一个把属性和操作封装在一起的对象。不过要注意，与对象不同的是，结构体类型（以及任何类型）之间都不可能存在继承关系。<strong>实际上，在 Go 语言中并没有继承的概念</strong>。</p><p>最后，结构体类型属于值类型。它的零值并不是 nil ，而是其中字段的值均为相应类型的零值的值。举个例子，结构体类型 Person 的零值若用字面量来表示的话则为 Person{} 。</p><h4 id="接口">接口</h4><p>在 Go 语言中，一个接口类型总是代表着某一种类型（即所有实现它的类型）的行为。一个接口类型的声明通常会包含关键字 type 、类型名称、关键字 interface 以及由花括号包裹的若干方法声明。示例如下：</p><pre><code class="highlight go"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;    Grow()    Move(<span class="keyword">string</span>) <span class="keyword">string</span>&#125;</code></pre><p>注意，接口类型中的方法声明是普通的方法声明的简化形式。它们只包括方法名称、参数声明列表和结果声明列表。其中的参数的名称和结果的名称都可以被省略。不过，出于文档化的目的，我还是建议大家在这里写上它们。因此， Move 方法的声明至少应该是这样的：</p><pre><code class="highlight go">Move(<span class="built_in">new</span> <span class="keyword">string</span>) (old <span class="keyword">string</span>)</code></pre><p>如果一个数据类型所拥有的方法集合中包含了某一个接口类型中的所有方法声明的实现，那么就可以说这个数据类型实现了那个接口类型。所谓实现一个接口中的方法是指，具有与该方法相同的声明并且添加了实现部分（由花括号包裹的若干条语句）。相同的方法声明意味着完全一致的名称、参数类型列表和结果类型列表。其中，参数类型列表即为参数声明列表中除去参数名称的部分。一致的参数类型列表意味着其长度以及顺序的完全相同。对于结果类型列表也是如此。</p><p>*Person 类型（注意，不是Person类型）拥有一个 Move 方法。该方法会是Animal接口的 Move 方法的一个实现。再加上我们在之前为它编写的那个 Grow 方法，*Person类型就可以被看做是 Animal 接口的一个实现类型了。</p><p>你可能已经意识到，我们无需在一个数据类型中声明它实现了哪个接口。只要满足了“方法集合为其超集”的条件，就建立了“实现”关系。这是<strong>典型的无侵入式的接口实现方法</strong>。</p><p>好了，现在我们已经认为 *Person 类型实现了 Animal 接口。但是 Go 语言编译器是否也这样认为呢？这显然需要一种显式的判定方法。在 Go 语言中，这种判定可以用类型断言来实现。不过，在这里，我们是不能在一个非接口类型的值上应用类型断言来判定它是否属于某一个接口类型的。我们必须先把前者转换成空接口类型的值。这又涉及到了 Go 语言的<strong>类型转换</strong>。</p><p>Go 语言的类型转换规则定义了是否能够以及怎样可以把一个类型的值转换另一个类型的值。另一方面，所谓空接口类型即是不包含任何方法声明的接口类型，用 interface{} 表示，常简称为空接口。正因为空接口的定义，Go 语言中的包含预定义的任何数据类型都可以被看做是空接口的实现。我们可以直接使用类型转换表达式把一个*Person类型转换成空接口类型的值，就像这样：</p><pre><code class="highlight go">p := Person&#123;<span class="string">"Robert"</span>, <span class="string">"Male"</span>, <span class="number">33</span>, <span class="string">"Beijing"</span>&#125;v := <span class="keyword">interface</span>&#123;&#125;(&amp;p)</code></pre><p>请注意第二行。在类型字面量后跟由圆括号包裹的值（或能够代表它的变量、常量或表达式）就构成了一个类型转换表达式，意为将后者转换为前者类型的值。在这里，我们把表达式 &amp;p 的求值结果转换成了一个空接口类型的值，并由变量 v 代表。</p><blockquote><p>注意，表达式 &amp;p（ &amp; 是取址操作符）的求值结果是一个 *Person 类型的值，即 p 的指针。</p></blockquote><p>在这之后，我们就可以在 v 上应用类型断言了，即：</p><pre><code class="highlight go">h, ok := v.(Animal)</code></pre><p>类型断言表达式 v.(Animal) 的求值结果可以有两个。第一个结果是被转换后的那个目标类型（这里是 Animal ）的值，而第二个结果则是转换操作成功与否的标志。显然， ok 代表了一个 bool 类型的值。它也是这里判定实现关系的重要依据。</p><p>至此，我们掌握了接口类型、实现类型以及实现关系判定的重要知识和技巧。</p><h4 id="指针">指针</h4><p>我们在前面多次提到过指针及指针类型。例如，*Person 是Person的指针类型。又例如，表达式 &amp;p 的求值结果是 p 的指针。方法的接收者类型的不同会给方法的功能带来什么影响？该方法所属的类型又会因此发生哪些潜移默化的改变？</p><p>指针操作涉及到两个操作符—— &amp; 和 *。这两个操作符均有多个用途。但是当它们作为地址操作符出现时，前者的作用是取址，而后者的作用是取值。更通俗地讲，当地址操作符 &amp; 被应用到一个值上时会取出指向该值的指针值，而当地址操作符 * 被应用到一个指针值上时会取出该指针指向的那个值。它们可以被视为相反的操作。</p><p>除此之外，当 * 出现在一个类型之前（如 *Person 和 *[3]string ）时就不能被看做是操作符了，而应该被视为一个符号。如此组合而成的标识符所表达的含义是作为第二部分的那个类型的指针类型。我们也可以把其中的第二部分所代表的类型称为基底类型。例如，*[3]string 是数组类型 [3]string 的指针类型，而 [3]string 是 *[3]string 的基底类型。</p><p>好了，我们现在回过头去再看结构体类型 Person 。它及其两个方法的完整声明如下：</p><pre><code class="highlight go"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;    Name    <span class="keyword">string</span>    Gender  <span class="keyword">string</span>    Age     <span class="keyword">uint8</span>    Address <span class="keyword">string</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(person *Person)</span> <span class="title">Grow</span><span class="params">()</span></span> &#123;    person.Age++&#125;<span class="function"><span class="keyword">func</span> <span class="params">(person *Person)</span> <span class="title">Move</span><span class="params">(newAddress <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;    old := person.Address    person.Address = newAddress    <span class="keyword">return</span> old&#125;</code></pre><p>注意， Person 的两个方法 Grow 和 Move 的接收者类型都是 *Person，而不是 Person。只要一个方法的接收者类型是其所属类型的指针类型而不是该类型本身，那么我就可以称该方法为一个指针方法。上面的 Grow 方法和 Move 方法都是 Person 类型的指针方法。</p><p>相对的，如果一个方法的接收者类型就是其所属的类型本身，那么我们就可以把它叫做值方法。我们只要微调一下 Grow 方法的接收者类型就可以把它从指针方法变为值方法：</p><pre><code class="highlight go"><span class="function"><span class="keyword">func</span> <span class="params">(person Person)</span> <span class="title">Grow</span><span class="params">()</span></span> &#123;    person.Age++&#125;</code></pre><p>那指针方法和值方法到底有什么区别呢？我们在保留上述修改的前提下编写如下代码：</p><pre><code class="language-go">p := Person{&quot;Robert&quot;, &quot;Male&quot;, 33, &quot;Beijing&quot;}p.Grow()fmt.Printf(&quot;%v\n&quot;, p)   </code></pre><p>这段代码被执行后，标准输出会打印出什么内容呢？直觉上， 34 会被打印出来，但是被打印出来的却是 33 。这是怎么回事呢？ Grow 方法的功能失效了？！</p><p>解答这个问题需要引出一条定论：方法的接收者标识符所代表的是该方法当前所属的那个值的一个副本，而不是该值本身。例如，在上述代码中， Person 类型的 Grow 方法的接收者标识符 person 代表的是 p 的值的一个拷贝，而不是 p 的值。我们在调用 Grow 方法的时候， Go 语言会将 p 的值复制一份并将其作为此次调用的当前值。正因为如此， Grow 方法中的 person.Age++ 语句的执行会使这个副本的 Age 字段的值变为 34 ，而 p 的 Age 字段的值却依然是33。这就是问题所在。</p><p>只要我们把 Grow 变回指针方法就可以解决这个问题。原因是，这时的 person 代表的是 p 的值的指针的副本。指针的副本仍会指向 p 的值。另外，之所以选择表达式 person.Age 成立，是因为如果 Go 语言发现 person 是指针并且指向的那个值有 Age 字段，那么就会把该表达式视为( *person).Age 。其实，这时的 person.Age 正是 (*person).Age 的速记法。</p><p>如果一个数据类型所拥有的方法集合中包含了某一个接口类型中的所有方法声明的实现，那么就可以说这个数据类型实现了那个接口类型。要获知一个数据类型都包含哪些方法并不难。但是要注意指针方法与值方法的区别。</p><p>拥有指针方法 Grow 和 Move 的指针类型 *Person 是接口类型 Animal 的实现类型，但是它的基底类型 Person 却不是。这样的表象隐藏着另一条规则：一个指针类型拥有以它以及以它的基底类型为接收者类型的所有方法，而它的基底类型却只拥有以它本身为接收者类型的方法。</p><p>以 Person 类型为例。即使我们把 Grow 和 Move 都改为值方法，*Person 类型也仍会是 Animal 接口的实现类型。另一方面， Grow 和 Move 中只要有一个是指针方法， Person 类型就不可能是 Animal 接口的实现类型。</p><p>另外，还有一点需要大家注意，我们在基底类型的值上仍然可以调用它的指针方法。例如，若我们有一个 Person 类型的变量 bp ，则调用表达式 bp.Grow() 是合法的。这是因为，如果 Go 语言发现我们调用的 Grow 方法是 bp 的指针方法，那么它会把该调用表达式视为 (&amp;bp).Grow() 。实际上，这时的 bp.Grow() 是 (&amp;bp).Grow() 的速记法。</p><h2 id="总结">总结</h2><p>本篇结束，篇幅较长，请看<a href="/backend/a-preliminary-study-of-golang-language3.html">下一篇</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;关于 golang 入门的笔记。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/backend/a-preliminary-study-of-golang-language1.html&quot;&gt;golang语言初探一&lt;/a&gt;&lt;/li
      
    
    </summary>
    
    
      <category term="backend" scheme="http://www.kavience.com/categories/backend/"/>
    
    
      <category term="golang" scheme="http://www.kavience.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang语言初探一</title>
    <link href="http://www.kavience.com/backend/a-preliminary-study-of-golang-language1.html"/>
    <id>http://www.kavience.com/backend/a-preliminary-study-of-golang-language1.html</id>
    <published>2021-05-18T01:53:55.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>关于 golang 入门的笔记。</p><ul><li>golang语言初探一</li><li><a href="/backend/a-preliminary-study-of-golang-language2.html">golang语言初探二</a></li><li><a href="/backend/a-preliminary-study-of-golang-language3.html">golang语言初探三</a></li></ul><h2 id="why">why</h2><p>周末的时候研究了一下 golang 相关的文档，根据自己的工作经验，我觉得这门语言在未来一定会大放异彩，其实现在也比较热门了。主要有以下几个特点：</p><ul><li>语法简单，golang 的关键字才 25 个，入门也非常简单</li><li>天然支持高并发，适用于大型微服务应用</li><li>跨平台，可编译出支持各大主流平台的应用，且毫无依赖</li></ul><p>经过对 golang 的这些了解，顿时感觉有点兴趣了，在这里记录一些入门的资料。</p><h2 id="how">how</h2><h3 id="设置-golang-镜像代理">设置 golang 镜像代理</h3><pre><code class="highlight plain">go env -w GO111MODULE&#x3D;ongo env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct</code></pre><h3 id="基本数据类型">基本数据类型</h3><h4 id="程序实体与关键字">程序实体与关键字</h4><p>任何Go语言源码文件都由若干个程序实体组成的。在 Go 语言中，变量、常量、函数、结构体和接口被统称为“程序实体”，而它们的名字被统称为“标识符”。</p><p>标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”。不过，首字母不能是数字或下划线。</p><blockquote><p>注意：在 Go 语言中，我们对程序实体的访问权限控制只能通过它们的名字来实现。名字首字母为大写的程序实体可以被任何代码包中的代码访问到。而名字首字母为小写的程序实体则只能被同一个代码包中的代码所访问。</p></blockquote><p>Go 语言还规定了一些特定的字符序列。它们被称为“关键字”。编程人员不能把关键字作为标识符。 Go 语言的关键字如下图：</p><p><img src="/img/blog_img/golang-vars.jpeg" alt="关键字"></p><h4 id="变量和常量">变量和常量</h4><p>用于声明变量的关键字 var ，以及用于声明常量的关键字 const 。</p><pre><code class="highlight go"><span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">1</span> <span class="keyword">var</span> num2, num3 <span class="keyword">int</span> = <span class="number">2</span>, <span class="number">3</span> <span class="comment">// 注释：平行赋值    </span><span class="keyword">var</span> ( <span class="comment">// 注释：多行赋值</span>    num4 <span class="keyword">int</span> = <span class="number">4</span>    num5 <span class="keyword">int</span> = <span class="number">5</span>)</code></pre><blockquote><p>要注意，对于常量不能出现只声明不赋值的情况。</p></blockquote><h4 id="整数类型">整数类型</h4><p>Go语言的整数类型一共有10个。</p><p>其中计算架构相关的整数类型有两个，即：有符号的整数类型 int 和无符号的整数类型 uint 。</p><blockquote><p>有符号的整数类型会使用最高位的比特（bit）表示整数的正负。显然，这会对它能表示的整数的范围有一定的损耗（使其缩小）。而无符号的整数类型会使用所有的比特位来表示数值。如此类型的值均为正数。这也是用“无符号的”来形容它们的原因。</p></blockquote><p>在不同的计算架构的计算机之上，它们体现的宽度是不同的。请看下表。</p><p><img src="/img/blog_img/golang-int.jpeg" alt="golang-int"></p><p>除了这两个计算架构相关的整数类型之外，还有8个可以显式表达自身宽度的整数类型。如下表所示。</p><p><img src="/img/blog_img/golang-moreint.jpeg" alt="golang-int"></p><p>它们的宽度意味着其自身的范围：</p><p><img src="/img/blog_img/golang-int-desc.jpeg" alt="golang-int"></p><p>除十进制外，还有八进制、十六进制的表示方法</p><pre><code class="highlight go"><span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">12</span>num1 = <span class="number">014</span> <span class="comment">// 用“0”作为前缀以表明这是8进制表示法。</span>num1 = <span class="number">0xC</span> <span class="comment">// 用“0x”作为前缀以表明这是16进制表示法。</span></code></pre><h4 id="浮点数类型">浮点数类型</h4><p>浮点数类型有两个，即 float32 和 float64 。存储这两个类型的值的空间分别需要 4 个字节和 8 个字节。<br>浮点数类型的值一般由整数部分、小数点“.”和小数部分组成。其中，整数部分和小数部分均由 10 进制表示法表示。不过还有另一种表示方法。那就是在其中加入指数部分。指数部分由“ E ”或“ e ”以及一个带正负号的 10 进制数组成。比如，3.7E-2 表示浮点数 0.037 。又比如，3.7E+1 表示浮点数 37 。</p><p>有时候，浮点数类型值的表示也可以被简化。比如，37.0 可以被简化为 37 。又比如， 0.037 可以被简化为 .037 。</p><blockquote><p>有一点需要注意，在 Go 语言里，浮点数的相关部分只能由 10 进制表示法表示，而不能由 8 进制表示法或 16 进制表示法表示。比如，03.7 表示的一定是浮点数 3.7 。</p></blockquote><h4 id="复数类型">复数类型</h4><p>复数类型同样有两个，即 complex64 和 complex128 。存储这两个类型的值的空间分别需要 8 个字节和 16 个字节。实际上，complex64 类型的值会由两个 float32 类型的值分别表示复数的实数部分和虚数部分。而 complex128 类型的值会由两个 float64 类型的值分别表示复数的实数部分和虚数部分。</p><p>复数类型的值一般由浮点数表示的实数部分、加号“+”、浮点数表示的虚数部分，以及小写字母“i”组成。比如，3.7E+1 + 5.98E-2i。正因为复数类型的值由两个浮点数类型值组成，所以其表示法的规则自然需遵从浮点数类型的值表示法的相关规则。</p><pre><code class="highlight go"><span class="keyword">var</span> num3 = <span class="number">3.7E+1</span> + <span class="number">5.98E-2i</span><span class="comment">// 37+0.0598i</span></code></pre><h4 id="byte-与-rune">byte 与 rune</h4><p>byte 与 rune 类型有一个共性，即：它们都属于别名类型。 byte 是 uint8 的别名类型，而 rune 则是 int32 的别名类型。<br>一个 rune 类型的值即可表示一个 Unicode 字符。 Unicode 是一个可以表示世界范围内的绝大部分字符的编码规范。关于它的详细信息，大家可以参看其官网（<a href="http://unicode.org/%EF%BC%89%E4%B8%8A%E7%9A%84%E6%96%87%E6%A1%A3%EF%BC%8C%E6%88%96%E5%9C%A8" target="_blank" rel="noopener">http://unicode.org/）上的文档，或在</a> Google 上搜索。用于代表 Unicode 字符的编码值也被称为 Unicode 代码点。一个 Unicode 代码点通常由“ U+ ”和一个以十六进制表示法表示的整数表示。例如，英文字母“ A ”的 Unicode 代码点为“ U+0041 ”。<br>rune 类型的值需要由单引号“ ’ ”包裹。例如，’ A ‘或’ 郝 '。这种表示方法一目了然。不过，我们还可以用另外几种形式表示 rune 类型值。</p><p><img src="/img/blog_img/golang-rune.jpeg" alt="golang-int"></p><p>另外，在 rune 类型值的表示中支持几种特殊的字符序列，即：转义符。它们由“ \ ”和一个单个英文字符组成。</p><p><img src="/img/blog_img/golang-rune2.jpeg" alt="golang-int"></p><h4 id="字符串类型">字符串类型</h4><p>一个字符串类型的值可以代表一个字符序列。这些字符必须是被 Unicode 编码规范支持的。虽然从表象上来说是字符序列，但是在底层，一个字符串值却是由若干个字节来表现和存储的。一个字符串（也可以说字符序列）会被 Go 语言用 Unicode 编码规范中的 UTF-8 编码格式编码为字节数组。</p><blockquote><p>注意，我们在一个字符串值或者一个字符串类型的变量之上应用 Go 语言的内置函数 len 将会得到代表它的那个字节数组的长度。这可能与我们看到的表象是不同的。</p></blockquote><p>字符串的表示法有两种，即：原生表示法和解释型表示法。若用原生表示法，需用反引号“ ` ”把字符序列包裹起来。若用解释型表示法，则需用双引号“ &quot; ”包裹字符序列。</p><p>二者的区别是，前者表示的值是所见即所得的（除了回车符）。在那对反引号之间的内容就是该字符串值本身。而后者所表示的值中的转义符会起作用并在程序编译期间被转义。所以，如此表示的字符串值的实际值可能会与我们看到的表象不相同。</p><h2 id="总结">总结</h2><p>本篇结束，篇幅较长，请看<a href="/backend/a-preliminary-study-of-golang-language2.html">下一篇</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;关于 golang 入门的笔记。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;golang语言初探一&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/backend/a-preliminary-study-of-golang-language2.html
      
    
    </summary>
    
    
      <category term="backend" scheme="http://www.kavience.com/categories/backend/"/>
    
    
      <category term="golang" scheme="http://www.kavience.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>[转载]创业后的一些反思</title>
    <link href="http://www.kavience.com/think/reprint-some-reflections-after-starting-a-business.html"/>
    <id>http://www.kavience.com/think/reprint-some-reflections-after-starting-a-business.html</id>
    <published>2021-05-10T08:51:29.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明">说明</h2><p>这是原作者经历创业后的一些反思，觉得很好，转载至此。原文链接: <a href="http://jafeney.com/2017/08/03/20170803/" target="_blank" rel="noopener">http://jafeney.com/2017/08/03/20170803/</a></p><h2 id="原文">原文</h2><p>大众创业，万众创新。从大学开始一直有个创业的梦想，去年也终于打开步子去做了。然而这一年下来，从0到1 感受了太大的心酸苦楚，有时克服一个困难紧接着新的麻烦又会接踵而至。在这种高压下奔跑是怎样一种感受，只有经历过的人才会懂。</p><p>杭州每年都上千个互联网注册，同样也有上百个公司倒闭，以前一直觉得是骇人听闻，现在也渐渐明白过来。创业不是件容易的事，没有任何人，任何理由让你一定能成功，更多的则是失败。细细回想，下面这些对互联网型创业至关重要：</p><h3 id="创业要选对合伙人">创业要选对合伙人</h3><p>创业绝对不是一个的战斗，做任何事情都需要一个Team，而对于互联网型创业，最好的合伙人组合就是 一个有领导能力和全局观的CEO，一个技术精湛善于团队管理的CTO，一个对市场和运营颇有经验的COO。有了这个互补的铁三角，如果再找到一个财大气粗的投资方，那前期的工作会非常顺利。</p><h3 id="合伙人缺失怎么办">合伙人缺失怎么办</h3><p>上面说的四者关系，任何一个缺失都会导致相应的问题。很多公司初创时都不太可能集齐这4颗龙珠，而一般的做法都是身兼数职，现学现卖。比如我们公司，我和我的CEO都是技术出身，尤其我的CEO对技术还特别痴迷，遇到技术难题经常喜欢钻牛角尖，好在都能钻出解决方案来，但一来二去也会花费大量的时间。而对技术痴迷的人 往往大局观比较差，尤其是项目规划能力。这也是 为什么技术专家很少 能做一个合格的CEO，而一个牛逼的CEO到后来也不做一线开发一样。</p><p>至于怎么办？我觉得前期可以身兼数职，现学现卖成功的人也不少。但如果做不好或达不到要求，还是趁早去招聘合适的人比较好，千万不要瞎搞，公司初创期越折腾越容易夭折。</p><h3 id="合伙人要实际出资">合伙人要实际出资</h3><p>公司股权是公司的核心，领导班子的股权分配决定一个公司的发展方向。我觉得最合理的比例应该是CEO占主导权，其他几位合伙人根据出资情况占股。对，必须实际出资，千万别搞什么干股，或者技术入股啥的。人都是一样，花的不是自己的钱，就不会真正珍惜。一旦公司出现危机情况，就容易置身事外，或者撂挑子跑路。</p><h3 id="创业要有可持续赢利的项目">创业要有可持续赢利的项目</h3><p>如果创业初期没有一个靠谱的、且可以持续赢利的项目，那没必要创业，公司没有收入就没有存在的必要。除非你的商业计划书得到了不错的风险投资，允许公司至少3个月不盈利，但压力会越来越大。</p><p>值得一提的是，这种靠风头起家而一直没有可持续赢利的项目公司很容易丧失主导权，容易被投资方牵着鼻子走，甚至成为投资人的狗腿子。公司一旦丧失主导权，领导班子在员工面前就容易丧失权威。作为CEO，你应该时时刻刻让员工明白到底是在为谁打工，树立自己的权威，能高效调动手底下一切力量，这是企业的灵魂。</p><h3 id="创业要有清晰的规划">创业要有清晰的规划</h3><p>作为CEO，必须要有大局观，对公司发展和项目的生命周期要有一个清晰的规划。这绝不是写个商业计划书那么简单，实际推进的过程中会遇到各式各样的问题，这些问题很可能打断公司原有的发展计划，这个时候就需要一个清晰的大脑来调整方案，重新规划，而不是继续埋头苦干，闭门造车。</p><h3 id="创业不是埋头苦干">创业不是埋头苦干</h3><p>很多人会有这样的感觉，创业只要努力就能取得成功。事实上没有一个创业者是不努力的，加班加点也是家常便饭，但真正取得成功的公司却不在多数。创业不是埋头苦干，而是找对方向做对的事。</p><p>说得具体点，我们在创业的时候应该阶段性地做反思和讨论，对成功的要肯定，对失败的要批评和改正。领导班子内部也要经常开讨论会，沟通有无很重要。对于未知的事情，多几次头脑风暴，多几个角度思考问题，调整方向，这对事情取得成功越有帮助。</p><h3 id="创业要善于拥抱变化">创业要善于拥抱变化</h3><p>创业最大的忌讳就是痴迷存量，而不敢去拥抱变化。趋利避害，见好就收，这其实是人的天性。从某种意义上来说，创业比较像赌博，敢于冒险的人能赢大钱（当然运气不好也会千家荡产），而想闷声发财的人往往赢不到大钱。so，那些不肯下注却老想着怎么赢大钱的人，无疑是在痴人说梦。记住，世上从来没有免费的午餐，不要深信任何人（至亲除外）。换句话说。这样的人本身也不适合创业，老老实实找个安生地妥妥地上班可能更适合。</p><p>总结地说，创业如果痴迷存量带来的好处，不敢去面对增量带来的麻烦，那就容易原地踏步，迟早会被后浪或者同行拍死在沙滩上。</p><h3 id="创业要沿途获取帮助">创业要沿途获取帮助</h3><p>创业为什么能成功？细细想来——那就是身边所有的人都愿意帮你，你整合资源的成本变得非常非常地低，你才可能成功。这是一个很简单的道理，所以沿途去获取帮助非常得重要。这种能力和创业者人品息息相关，所以商人一般特别在意信誉和口碑，获取身边人的认可你的产品就成功了一半。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;这是原作者经历创业后的一些反思，觉得很好，转载至此。原文链接: &lt;a href=&quot;http://jafeney.com/2017/08/03/20170803/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http
      
    
    </summary>
    
    
      <category term="think" scheme="http://www.kavience.com/categories/think/"/>
    
    
      <category term="创业" scheme="http://www.kavience.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>个人收藏导航</title>
    <link href="http://www.kavience.com/tools/personal-collection-navigation.html"/>
    <id>http://www.kavience.com/tools/personal-collection-navigation.html</id>
    <published>2021-05-10T08:19:39.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>一篇关于个人收藏的导航文章。</p><h2 id="why">why</h2><p>个人的大多数收藏都是通过谷歌的书签收藏，但访问谷歌又不是那么方便，而且找的时候也有点难找，有的时候想快速查点东西，很麻烦。</p><h2 id="how">how</h2><p>对这些资源进行分类是挺麻烦的，就按照内容类型区分吧，不定期整理，表格排名不分先后。</p><h3 id="开发相关">开发相关</h3><h4 id="精彩社区">精彩社区</h4><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">链接</th><th style="text-align:center">简介</th><th style="text-align:center">标签</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">干货集中营</td><td style="text-align:center"><a href="https://gank.io/" target="_blank" rel="noopener">https://gank.io/</a></td><td style="text-align:center">偏前端社区</td><td style="text-align:center">全栈,app,flutter</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">码力全开</td><td style="text-align:center"><a href="https://www.maliquankai.com/" target="_blank" rel="noopener">https://www.maliquankai.com/</a></td><td style="text-align:center">自由职业</td><td style="text-align:center">app</td><td style="text-align:center">可以在上面找资料</td></tr></tbody></table><h4 id="技术博客">技术博客</h4><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">链接</th><th style="text-align:center">简介</th><th style="text-align:center">标签</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">风雪之隅</td><td style="text-align:center"><a href="https://www.laruence.com/" target="_blank" rel="noopener">https://www.laruence.com/</a></td><td style="text-align:center">Laruence</td><td style="text-align:center">php,Laruence</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">岁寒</td><td style="text-align:center"><a href="https://lvwenhan.com/" target="_blank" rel="noopener">https://lvwenhan.com/</a></td><td style="text-align:center">全栈开发</td><td style="text-align:center">php,laravel,iOS</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">施国鹏 seth-shi 的博客</td><td style="text-align:center"><a href="https://www.shiguopeng.cn/" target="_blank" rel="noopener">https://www.shiguopeng.cn/</a></td><td style="text-align:center">全栈开发</td><td style="text-align:center">php,golang</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">jafeney 的博客</td><td style="text-align:center"><a href="http://jafeney.com/" target="_blank" rel="noopener">http://jafeney.com/</a></td><td style="text-align:center">前端开发</td><td style="text-align:center">前端</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">晚晴幽草轩</td><td style="text-align:center"><a href="https://www.jeffjade.com/" target="_blank" rel="noopener">https://www.jeffjade.com/</a></td><td style="text-align:center">好多互联网内容</td><td style="text-align:center">各种各样</td><td style="text-align:center">没事可以逛逛，激发灵感 ,里面也有一些收集资料</td></tr><tr><td style="text-align:center">贾鹏辉的博客</td><td style="text-align:center"><a href="https://www.devio.org/" target="_blank" rel="noopener">https://www.devio.org/</a></td><td style="text-align:center">移动端开发</td><td style="text-align:center">flutter,iOS,Android</td><td style="text-align:center"></td></tr></tbody></table><h4 id="精彩博文">精彩博文</h4><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">链接</th><th style="text-align:center">简介</th><th style="text-align:center">标签</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">HTTP 接口设计指北</td><td style="text-align:center"><a href="https://github.com/bolasblack/http-api-guide" target="_blank" rel="noopener">https://github.com/bolasblack/http-api-guide</a></td><td style="text-align:center">api设计</td><td style="text-align:center">http,api</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">你真的了解React Hooks吗？</td><td style="text-align:center"><a href="https://tech.youzan.com/hookhe-lei-zu-jian-zai-shi-yong-shang-you-he-bu-tong/" target="_blank" rel="noopener">https://tech.youzan.com/hookhe-lei-zu-jian-zai-shi-yong-shang-you-he-bu-tong/</a></td><td style="text-align:center">react hooks深入了解</td><td style="text-align:center">react,hooks</td><td style="text-align:center"></td></tr></tbody></table><h3 id="设计相关">设计相关</h3><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">链接</th><th style="text-align:center">简介</th><th style="text-align:center">标签</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">pinterest</td><td style="text-align:center"><a href="https://www.pinterest.com/" target="_blank" rel="noopener">https://www.pinterest.com/</a></td><td style="text-align:center">高清图片</td><td style="text-align:center">picture,idea</td><td style="text-align:center">可以去上面逛逛找灵感</td></tr><tr><td style="text-align:center">logo</td><td style="text-align:center"><a href="https://hatchful.shopify.com/zh-CN/" target="_blank" rel="noopener">https://hatchful.shopify.com/zh-CN/</a></td><td style="text-align:center">快速制作logo</td><td style="text-align:center">logo,idea</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">正版高清图片</td><td style="text-align:center"><a href="https://pixabay.com/zh/" target="_blank" rel="noopener">https://pixabay.com/zh/</a></td><td style="text-align:center">正版高清图片</td><td style="text-align:center">picture</td><td style="text-align:center"></td></tr></tbody></table><h3 id="工具">工具</h3><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">链接</th><th style="text-align:center">简介</th><th style="text-align:center">标签</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">验证码接收</td><td style="text-align:center"><a href="https://www.yinsiduanxin.com/" target="_blank" rel="noopener">https://www.yinsiduanxin.com/</a></td><td style="text-align:center">验证码接收平台</td><td style="text-align:center">验证码</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">图片转字符</td><td style="text-align:center"><a href="https://www.degraeve.com/img2txt.php" target="_blank" rel="noopener">https://www.degraeve.com/img2txt.php</a></td><td style="text-align:center">图片转字符</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">vultr</td><td style="text-align:center"><a href="https://www.vultr.com/?ref=8868444-6G" target="_blank" rel="noopener">https://www.vultr.com/?ref=8868444-6G</a></td><td style="text-align:center">国外服务器</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">shadowsocks</td><td style="text-align:center"><a href="https://portal.shadowsocks.nz/aff.php?aff=36748" target="_blank" rel="noopener">https://portal.shadowsocks.nz/aff.php?aff=36748</a></td><td style="text-align:center">翻墙服务</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="总结">总结</h2><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;一篇关于个人收藏的导航文章。&lt;/p&gt;
&lt;h2 id=&quot;why&quot;&gt;why&lt;/h2&gt;
&lt;p&gt;个人的大多数收藏都是通过谷歌的书签收藏，但访问谷歌又不是那么方便，而且找的时候也有点难找，有的时候想快速查点东西，很麻烦。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="tools" scheme="http://www.kavience.com/categories/tools/"/>
    
    
      <category term="收藏" scheme="http://www.kavience.com/tags/%E6%94%B6%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hexo主题omega开发历程</title>
    <link href="http://www.kavience.com/tools/hexo-theme-omega-development-history.html"/>
    <id>http://www.kavience.com/tools/hexo-theme-omega-development-history.html</id>
    <published>2021-04-30T06:58:13.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p><a href="https://github.com/kavience/hexo-theme-omega" target="_blank" rel="noopener">Omega</a> 是 hexo 框架下的一个博客主题。</p><p><img src="/img/blog_img/theme-preview.jpg" alt="theme-preview"></p><h3 id="特点">特点</h3><ul><li>轻量</li><li>便于阅读</li><li>配置定制化</li><li>多语言支持</li></ul><h2 id="why">why</h2><p>使用过各种各样的工具、框架搭建博客，在去年最终选择使用 hexo 来搭建，主要是不用维护服务器，简单方便，然而始终没有找到称心如意的主题。所以决定动手自己做一个。</p><p>正如其名，我希望有一个纯粹的、便于阅读、容易定制化的博客主题。现在有很多 hexo 的主题框架，但是都不如我意，这也就是我为什么要做这个主题的初衷。主题参考了 <a href="http://huangxuan.me/" target="_blank" rel="noopener">Hux</a> 的博客整体布局，我也比较喜欢这种布局。</p><h3 id="纯粹">纯粹</h3><p>主题是基于 hexo 框架的，首先我希望博客不需要太多复杂、混乱、无用的功能。我理想的博客就是一个记录生活、提供与志同道合的网友的交流平台。</p><h3 id="便于阅读">便于阅读</h3><p>博客最主要的功能就是提供阅读了，所以一个良好的阅读体验是最重要的。</p><h3 id="容易定制化">容易定制化</h3><p>如果博客和别人的完全一致，那也不好，不够独特，容易审美疲劳。所以主题具有定制化的功能是必须的。</p><p>但是定制化如果过于复杂，又会增加时间成本，就变得如同开发一个主题了，所以简化定制化成本也是必须的。</p><h2 id="how">how</h2><h3 id="替换主题">替换主题</h3><p>将主题文件放置在 themes 目录，修改根目录下的配置文件 _config.yml 的 theme 为 omega</p><h3 id="安装依赖">安装依赖</h3><p>主题有以下依赖，尽量保持一致，否则可能会出现未知问题。</p><pre><code class="highlight json">"dependencies": &#123;    "cheerio": "^1.0.0-rc.6",    "hexo": "^4.0.0",    "hexo-generator-archive": "^1.0.0",    "hexo-generator-category": "^1.0.0",    "hexo-generator-feed": "^2.2.0",    "hexo-generator-index-pin-top": "^0.2.2",    "hexo-generator-searchdb": "^1.3.3",    "hexo-generator-seo-friendly-sitemap": "0.0.25",    "hexo-generator-tag": "^1.0.0",    "hexo-renderer-ejs": "^1.0.0",    "hexo-renderer-less": "^2.0.2",    "hexo-renderer-markdown-it": "^3.4.1",    "hexo-server": "^1.0.0",    "hexo-tag-cloud": "^2.1.2",    "hexo-translate-title": "^1.0.11",    "hexo-wordcount": "^6.0.1"  &#125;</code></pre><h3 id="修改配置">修改配置</h3><p>根目录下的 _config.yml 配置可参考<a href="https://www.kavience.com/">我的博客</a>，主题下的配置变量主要有以下内容:</p><pre><code class="highlight yml"><span class="comment"># omega setting start</span><span class="comment"># ----------------------------------------------------------</span><span class="comment"># Site settings</span><span class="attr">beian:</span> <span class="string">赣ICP备17009879号</span><span class="attr">SEOTitle:</span> <span class="string">kavience</span> <span class="string">|</span> <span class="string">Blog</span><span class="comment"># ----------------------------------------------------------</span><span class="comment"># Banner settings</span><span class="attr">banner:</span> <span class="literal">true</span> <span class="comment"># close all header banner if false</span><span class="attr">header_img:</span> <span class="string">/img/header_img/home.jpg</span><span class="attr">article_img:</span> <span class="string">/img/header_img/article-bg.jpg</span><span class="attr">archives_img:</span> <span class="string">/img/header_img/archive.jpg</span><span class="attr">archive_tag_img:</span> <span class="string">/img/header_img/archive-tag.jpg</span><span class="attr">archive_category_img:</span> <span class="string">/img/header_img/archive-category.jpg</span><span class="attr">404_img:</span> <span class="string">/img/header_img/404.jpg</span><span class="comment"># ----------------------------------------------------------</span><span class="comment"># Contact settings</span><span class="attr">email:</span> <span class="string">kavience@gmail.com</span><span class="attr">zhihu_username:</span> <span class="string">kavience-xiaofan</span><span class="attr">github_username:</span> <span class="string">kavience</span><span class="attr">twitter_username:</span> <span class="string">Mr_Kavience</span><span class="comment"># weibo_username: xxx</span><span class="comment"># facebook_username:  xxx</span><span class="comment"># linkedin_username:  xxx</span><span class="attr">sitemapIcon:</span> <span class="literal">true</span><span class="attr">RSS:</span> <span class="literal">true</span><span class="comment"># ----------------------------------------------------------</span><span class="comment"># Comment settings</span><span class="attr">comment_method:</span> <span class="string">gitalk</span> <span class="comment"># gitalk or disqus</span><span class="comment">## Method 1: gitalk https://github.com/gitalk/gitalk</span><span class="attr">gitalk:</span>  <span class="attr">clientID:</span> <span class="string">'d25cda615a572205be1e'</span>  <span class="attr">clientSecret:</span> <span class="string">'faa4cf10f1daea3d4701f8be90d80feb88c818ac'</span>  <span class="attr">repo:</span> <span class="string">'blog'</span>  <span class="attr">owner:</span> <span class="string">'kavience'</span>  <span class="attr">admin:</span> <span class="string">['kavience']</span>  <span class="attr">distractionFreeMode:</span> <span class="literal">false</span><span class="comment">## Method 2: disqus</span><span class="comment"># disqus_username: kavience</span><span class="comment"># ----------------------------------------------------------</span><span class="comment"># Analytics settings</span><span class="comment">## Baidu Analytics</span><span class="comment"># ba_track_id: xxx</span><span class="comment">## Google Analytics</span><span class="attr">ga_track_id:</span> <span class="string">"UA-171834825-2"</span><span class="attr">ga_domain:</span> <span class="string">www.kavience.com</span><span class="comment"># ----------------------------------------------------------</span><span class="comment"># Reward settings</span><span class="attr">reward:</span> <span class="literal">true</span><span class="attr">reward_comment:</span> <span class="string">赞赏一下</span><span class="attr">wechatpay:</span> <span class="string">/img/reward/wechat.png</span><span class="attr">alipay:</span> <span class="string">/img/reward/alipay.png</span><span class="comment"># ----------------------------------------------------------</span><span class="comment"># Sidebar settings</span><span class="attr">sidebar_about_description:</span> <span class="string">"种一棵树最好的时间是十年前，其次是现在。"</span><span class="attr">sidebar_avatar:</span> <span class="string">/img/avatar/my-avatar.jpg</span><span class="attr">widgets:</span>  <span class="bullet">-</span> <span class="string">short-about</span>  <span class="bullet">-</span> <span class="string">recent-posts</span>  <span class="bullet">-</span> <span class="string">category</span>  <span class="bullet">-</span> <span class="string">archive</span>  <span class="bullet">-</span> <span class="string">featured-tags</span>  <span class="bullet">-</span> <span class="string">copyright</span><span class="comment"># ----------------------------------------------------------</span><span class="comment"># less vars</span><span class="attr">less:</span>  <span class="attr">options:</span>    <span class="attr">globalVars:</span>      <span class="attr">bg-color:</span> <span class="string">'#f1e5c9'</span>      <span class="attr">main-bg-color:</span> <span class="string">'#f6f8fa'</span>      <span class="attr">text-main-color:</span> <span class="string">'#404046'</span>      <span class="attr">text-secondary-color:</span> <span class="string">'#a3a3a3'</span>      <span class="attr">text-threed-color:</span> <span class="string">'#808080'</span>      <span class="attr">hover-color:</span> <span class="string">'#0085a1'</span>      <span class="attr">border-color:</span> <span class="string">gray</span>      <span class="comment">## highlight vars</span>      <span class="comment"># highlight-background: "#f6f8fa"</span>      <span class="comment"># highlight-current-line: "#efefef"</span>      <span class="comment"># highlight-selection: "#d6d6d6"</span>      <span class="comment"># highlight-foreground: "#24292e"</span>      <span class="comment"># highlight-comment: "#8e908c"</span>      <span class="comment"># highlight-red: "#c82829"</span>      <span class="comment"># highlight-orange: "#f5871f"</span>      <span class="comment"># highlight-yellow: "#eab700"</span>      <span class="comment"># highlight-green: "#718c00"</span>      <span class="comment"># highlight-aqua: "#3e999f"</span>      <span class="comment"># highlight-blue: "#4271ae"</span>      <span class="comment"># highlight-purple: "#8959a8"</span>      <span class="attr">highlight-background:</span> <span class="string">"#002451"</span>      <span class="attr">highlight-current-line:</span> <span class="string">"#00346e"</span>      <span class="attr">highlight-selection:</span> <span class="string">"#003f8e"</span>      <span class="attr">highlight-foreground:</span> <span class="string">"#ffffff"</span>      <span class="attr">highlight-comment:</span> <span class="string">"#7285b7"</span>      <span class="attr">highlight-red:</span> <span class="string">"#ff9da4"</span>      <span class="attr">highlight-orange:</span> <span class="string">"#ffc58f"</span>      <span class="attr">highlight-yellow:</span> <span class="string">"#ffeead"</span>      <span class="attr">highlight-green:</span> <span class="string">"#d1f1a9"</span>      <span class="attr">highlight-aqua:</span> <span class="string">"#99ffff"</span>      <span class="attr">highlight-blue:</span> <span class="string">"#bbdaff"</span>      <span class="attr">highlight-purple:</span> <span class="string">"#ebbbff"</span></code></pre><h2 id="总结">总结</h2><p>在主题开发的过程中，踩了很多坑，一方面是因为 hexo 官方的文档实在是太简陋了，感觉很多重要的信息都是一笔带过，反复看了几遍。这里把几个重要的知识点记录一下。</p><h3 id="css-预处理器">css 预处理器</h3><p>hexo 支持多种 css 预处理器，例如 sass、less、stylus 等，需要安装对应的渲染插件，例如 hexo-renderer-less 、hexo-renderer-stylus 。</p><p>在引入的过程，使用 css 辅助函数像这样引入就可以了。</p><pre><code class="highlight ejs">&lt;%- css(&#39;css&#x2F;omega&#39;)%&gt;</code></pre><p>会自动引入主题下的 source 下的 css 目录下的 omega.css 文件，hexo-renderer-less 在打包的时候，会自动编译 omega.less 成 omega.css。<br>这里还有个坑，在 stylus 中可以使用 hexo-config 辅助函数获取 hexo 的配置变量，在 less 中，hexo-config 辅助函数是不存在的，只能把变量定义在 less 下面的配置，例如这样：</p><pre><code class="highlight yml"><span class="attr">less:</span>  <span class="attr">options:</span>    <span class="attr">globalVars:</span>      <span class="attr">bg-color:</span> <span class="string">'#f1e5c9'</span></code></pre><h3 id="归档">归档</h3><p>在开发归档的页面过程中，发现生成的 tag、category 都归属于 archive ，也就是说例如你想访问一个分类下的所有文章，像这样 <a href="https://www.kavience.com/categories/frontend/">https://www.kavience.com/categories/frontend/</a>, 最终生成的这个页面采用的是 archive 模板。官网文档是这样描述的：</p><blockquote><p>模板决定了网站内容的呈现方式，每个主题至少都应包含一个 index 模板，以下是各页面相对应的模板名称：</p></blockquote><table><thead><tr><th style="text-align:center">模板</th><th style="text-align:center">用途</th><th style="text-align:center">回退</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">首页</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">post</td><td style="text-align:center">文章</td><td style="text-align:center">index</td></tr><tr><td style="text-align:center">page</td><td style="text-align:center">分页</td><td style="text-align:center">index</td></tr><tr><td style="text-align:center">archive</td><td style="text-align:center">归档</td><td style="text-align:center">index</td></tr><tr><td style="text-align:center">category</td><td style="text-align:center">分类归档</td><td style="text-align:center">archive</td></tr><tr><td style="text-align:center">tag</td><td style="text-align:center">标签归档</td><td style="text-align:center">archive</td></tr></tbody></table><p>所以必须在 archive 模板中处理这三个页面渲染的方式，可以通过 page 变量下的 category 、tag 来判断到底是属于何种归档。</p><h3 id="注意">注意</h3><p>博客采用的一些插件可能会导致一些奇奇怪怪的问题出现，所以请仔细看下面的说明。</p><ul><li>文章名字不能带 + 号等特殊文字，否则可能造成翻译无法通过</li><li>文章名字不能带 ‘,’ 且不能超过 50 个字符，因为 GitHub 标签不允许，否则无法生成评论 issue</li><li>文章名字不能与文章内各级标题同名，否则无法生成评论 issue</li><li>文章不能无标题，否则生成 searchdb 有问题</li></ul><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kavience/hexo-theme-omega&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Omega&lt;/a&gt; 是 hexo 框架下的一个博客主题
      
    
    </summary>
    
    
      <category term="tools" scheme="http://www.kavience.com/categories/tools/"/>
    
    
      <category term="hexo" scheme="http://www.kavience.com/tags/hexo/"/>
    
      <category term="omega" scheme="http://www.kavience.com/tags/omega/"/>
    
  </entry>
  
  <entry>
    <title>Eslint和prettie配合husky提高前端开发规范</title>
    <link href="http://www.kavience.com/frontend/eslint-and-prettie-cooperate-with-husky-to-improve-frontend-development-specifications.html"/>
    <id>http://www.kavience.com/frontend/eslint-and-prettie-cooperate-with-husky-to-improve-frontend-development-specifications.html</id>
    <published>2021-04-26T10:54:50.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>使用 eslint 和 prettie 再配合 husky 提高前端开发规范。</p><h2 id="why">why</h2><p>平时的开发中，开发规范必不可少，手动修改规范既不可靠，也非常繁琐，所以可以利用 eslint 和 prettie 自动修复以及规范化代码。</p><p>再配合 husky ，当开发者 commit 的时候，会自动校验，且尝试自动修复代码，一旦修复失败，则会放弃代码提交。</p><h2 id="how">how</h2><p>安装以下几个依赖：</p><pre><code class="highlight json"><span class="comment">// package.json</span>&#123;  <span class="comment">// ...</span>  <span class="comment">// 忽略其他代码</span>  <span class="attr">"scripts"</span>: &#123;    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,    <span class="attr">"lint"</span>: <span class="string">"lint-staged"</span>  &#125;,  <span class="attr">"dependencies"</span>: &#123;    <span class="attr">"eslint"</span>: <span class="string">"^7.25.0"</span>,    <span class="attr">"eslint-config-airbnb"</span>: <span class="string">"^18.2.1"</span>,    <span class="attr">"eslint-config-prettier"</span>: <span class="string">"^8.3.0"</span>,    <span class="attr">"eslint-import-resolver-alias"</span>: <span class="string">"^1.1.2"</span>,    <span class="attr">"eslint-plugin-import"</span>: <span class="string">"^2.22.1"</span>,    <span class="attr">"eslint-plugin-jsx-a11y"</span>: <span class="string">"^6.4.1"</span>,    <span class="attr">"eslint-plugin-prettier"</span>: <span class="string">"^3.4.0"</span>,    <span class="attr">"eslint-plugin-react"</span>: <span class="string">"^7.23.2"</span>,    <span class="attr">"husky"</span>: <span class="string">"^6.0.0"</span>,    <span class="attr">"lint-staged"</span>: <span class="string">"^10.5.4"</span>,    <span class="attr">"module-alias"</span>: <span class="string">"^2.2.2"</span>,    <span class="attr">"prettier"</span>: <span class="string">"^2.2.1"</span>  &#125;,  <span class="attr">"husky"</span>: &#123;    <span class="attr">"hooks"</span>: &#123;      <span class="attr">"pre-commit"</span>: <span class="string">"lint-staged"</span>    &#125;  &#125;,  <span class="attr">"lint-staged"</span>: &#123;    <span class="attr">"**/*.js"</span>: [      <span class="string">"eslint --fix"</span>,      <span class="string">"git add"</span>    ]  &#125;,  <span class="attr">"_moduleAliases"</span>: &#123;    <span class="attr">"@root"</span>: <span class="string">"."</span>,    <span class="attr">"@lib"</span>: <span class="string">"./lib"</span>  &#125;&#125;</code></pre><p>配置 <strong>.eslintrc.js</strong></p><pre><code class="highlight js"><span class="built_in">module</span>.exports = &#123;  <span class="comment">// 使用 airbnb, prettier 推荐的规范</span>  extends: [<span class="string">'airbnb'</span>, <span class="string">'plugin:prettier/recommended'</span>],  parserOptions: &#123;    <span class="comment">// 使用 es6</span>    ecmaVersion: <span class="number">6</span>,    sourceType: <span class="string">'module'</span>,  &#125;,  <span class="comment">// 自定义规则</span>  rules: &#123;    <span class="string">'arrow-body-style'</span>: <span class="number">0</span>,    strict: <span class="number">0</span>,    <span class="string">'no-console'</span>: <span class="number">0</span>,    <span class="string">'func-names'</span>: <span class="number">0</span>,    <span class="string">'space-before-function-paren'</span>: <span class="number">0</span>,    <span class="string">'no-param-reassign'</span>: <span class="number">0</span>,    <span class="string">'import/no-dynamic-require'</span>: <span class="number">0</span>,    <span class="string">'global-require'</span>: <span class="number">0</span>,    <span class="string">'consistent-return'</span>: <span class="number">0</span>,  &#125;,  <span class="comment">// 配置别名</span>  settings: &#123;    <span class="string">'import/resolver'</span>: &#123;      alias: &#123;        map: [[<span class="string">'@'</span>, <span class="string">'.'</span>]],        extensions: [<span class="string">'.js'</span>],      &#125;,    &#125;,  &#125;,&#125;;</code></pre><p>配置好之后，安装 vscode 插件 eslint，这样可以在项目编译前检查错误，另外需要重启 vscode 使配置生效。</p><p>接下来配置 husky，安装依赖后运行以下命令：</p><pre><code class="highlight bash"><span class="comment"># husky v6 版本是需要先安装的，会在项目下生成 .husky 目录</span>node_modules/.bin/husky install<span class="comment"># 添加 pre-commit 钩子</span>node_modules/.bin/husky <span class="built_in">set</span> .husky/pre-commit <span class="string">"npm run lint"</span></code></pre><p>到此为止，项目就配置完了，接下来可以测试一下，修改一个文件，然后 commit 的时候，就会自动运行 <strong>npm run lint</strong> 了。</p><blockquote><p>!注意如果 husky 没生效，一定要确认 git 是在 <strong>node_modules/.bin/husky set .husky/pre-commit “npm run lint”</strong> 之前初始化的。</p></blockquote><h2 id="总结">总结</h2><p>添加项目规范，可以保证项目的格式统一，养成良好的开发习惯。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;使用 eslint 和 prettie 再配合 husky 提高前端开发规范。&lt;/p&gt;
&lt;h2 id=&quot;why&quot;&gt;why&lt;/h2&gt;
&lt;p&gt;平时的开发中，开发规范必不可少，手动修改规范既不可靠，也非常繁琐，所以可以利用 esli
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="eslint" scheme="http://www.kavience.com/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>再造前端组件库轮子项目</title>
    <link href="http://www.kavience.com/frontend/reengineering-the-frontend-component-library-wheel-project.html"/>
    <id>http://www.kavience.com/frontend/reengineering-the-frontend-component-library-wheel-project.html</id>
    <published>2021-04-26T01:35:50.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>再造一遍像 ant-design 那样的轮子库，知其然，也要知其所以然。</p><h2 id="why">why</h2><p>经过昨天的打击，今天重振旗鼓，我要重新振作起来，不就是组件库吗？既然我思路不够，那我就依照现有项目，重新造一个呗！说干就干。</p><h2 id="how">how</h2><p>先制定一下项目计划，整体年底左右完成即可，3 个月一个周期，预计 3 个周期。项目历程分为：</p><ul><li>底层组件（2021.4.26 ~ 2021.7.26）<ul><li>底层组件库脚手架</li><li>底层组件库</li></ul></li><li>上层组件（2021.7.27 ~ 2021.10.27）<ul><li>上层脚手架</li><li>上层组件库</li></ul></li><li>上层官方文档（2021.10.28 ~ 2021.12.31）<ul><li>组件页面官网</li><li>组件文档</li><li>组件开发历程</li></ul></li></ul><p>项目计划制定并不是一成不变，是灵活调度（<s>偷懒用的</s>）的，具体的 TODO 更新到我的 iPad 上吧。</p><p>计划代号为426计划，我发现很多项目都以动物命名，动物名字都快被榨干了，我就将项目名称暂定为： willow-design (柳树)。</p><h2 id="总结">总结</h2><p>如果按照这个项目制定计划走一遍并认真完成，是可以学习到很多东西的，希望自己能坚持下去。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;再造一遍像 ant-design 那样的轮子库，知其然，也要知其所以然。&lt;/p&gt;
&lt;h2 id=&quot;why&quot;&gt;why&lt;/h2&gt;
&lt;p&gt;经过昨天的打击，今天重振旗鼓，我要重新振作起来，不就是组件库吗？既然我思路不够，那我就依照现有
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://www.kavience.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>迷茫的一天</title>
    <link href="http://www.kavience.com/think/a-lost-day.html"/>
    <id>http://www.kavience.com/think/a-lost-day.html</id>
    <published>2021-04-25T08:06:46.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>受到了一次【物理】打击，引发的思考。</p><h2 id="why">why</h2><p>本来打算做一个 Mas OS 的 <a href="https://kavience.github.io/masos-web/" target="_blank" rel="noopener">demo</a>，本以为会是件很简单的事，结果自从基本架子搭起来以后，一方面要找素材，另一方面要从零开始造轮子。两件事都非常折磨人，没有太多找素材的经验，造一个好的轮子，也要花不少的时间。今天打算造一个 Mac OS 的菜单，实现 Mac 上的菜单功能，发现事情远没那么简单，没有很好的一个思路。</p><p>随即想去看看 ant-design 的 <a href="https://github.com/react-component/trigger" target="_blank" rel="noopener">Trigger</a> 的实现方式，结果就受到了打击。</p><h2 id="how">how</h2><p>我原有的一个思路是，实现一个 Trigger ，对于 React 来说，最主要的就是使用 <a href="https://zh-hans.reactjs.org/docs/portals.html" target="_blank" rel="noopener">React.createPortal</a> 这个方法了，因为 Trigger 基本上都是根据子类元素的位置去确定弹出的内容的位置，所以必然是要插入一个 position 为 absolute 的元素，然后根据子元素的位置，去计算弹出的位置。</p><pre><code class="highlight jsx"><span class="comment">// 以下皆伪代码，几个原思路的核心功能，源代码被我一怒之下删了，冲动是魔鬼啊。</span><span class="comment">// 要实现的组件类似这样</span>&lt;Trigger  type=<span class="string">"click"</span>  positon=<span class="string">"bottom"</span>  popContent=&#123;&lt;div&gt;<span class="keyword">this</span> is pop&lt;<span class="regexp">/div&gt;&#125;</span><span class="regexp">&gt;</span><span class="regexp">  &lt;button&gt;Open&lt;/</span>button&gt;&lt;<span class="regexp">/Trigger&gt;</span><span class="regexp"></span><span class="regexp">/</span><span class="regexp">/ 1. 插入弹窗，dom 是真实的 document 元素，popContent 是传入需要渲染的 react 节点，即 &lt;div&gt;this is pop&lt;/</span>div&gt; render() &#123;  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="xml">    &#123;props.children&#125;</span><span class="xml">    &#123;React.createPortal(popContent, dom);&#125;</span><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;<span class="comment">// 2. 创建 dom</span><span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);dom.style.position = <span class="string">"display"</span>;<span class="comment">// 3. 计算 popContent 的位置</span><span class="comment">// 利用 ref 得到 children 元素的位置，然后根据 offset 得到左和上的距离，再加上元素的宽高即可计算出 popContent 的 top 和 left 是多少</span><span class="comment">// 4. 点击屏幕非 popContent 的空白处，关闭 popContent</span><span class="comment">// 监听点击事件，通过判断点击位置是否在 popContent 内，而决定是否需要关闭</span></code></pre><p>理想状态就是这样的，看起来一切都可行，</p><p>然而。。。</p><p>还是我太天真了。</p><p>到了第四步，在 useEfect 中添加一个全局的监听事件，肯定需要清除这个事件，然而清除之后又导致下一次触发 useEfect 的时候，又无法重新监听新的 ref 。后来实在没有好的想法了，就想着去看看别人的实现方式，首先就想到了 <a href="https://ant.design/components/popover-cn/" target="_blank" rel="noopener">popover</a>，经过一系列的排查，最终发现底层使用的是 <a href="https://github.com/react-component/trigger" target="_blank" rel="noopener">rc-trigger</a>， 于是就看 rc-trigger 的实现方式，看了一会，发现自己耐不住心去看，一大串一大串的代码，绕来绕去，看的头疼。</p><h2 id="总结">总结</h2><p>于是这就造就了我今天迷茫的一天，还想着有一天弄个 ant-design 源码解析系列呢，但如果这点代码都看不下去，以后怎么办？</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;受到了一次【物理】打击，引发的思考。&lt;/p&gt;
&lt;h2 id=&quot;why&quot;&gt;why&lt;/h2&gt;
&lt;p&gt;本来打算做一个 Mas OS 的 &lt;a href=&quot;https://kavience.github.io/masos-web/&quot; 
      
    
    </summary>
    
    
      <category term="think" scheme="http://www.kavience.com/categories/think/"/>
    
    
      <category term="迷茫" scheme="http://www.kavience.com/tags/%E8%BF%B7%E8%8C%AB/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令记录</title>
    <link href="http://www.kavience.com/tools/git-common-command-record.html"/>
    <id>http://www.kavience.com/tools/git-common-command-record.html</id>
    <published>2021-04-23T02:17:23.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>一篇关于 Git 常用命令的记录文章。</p><h2 id="why">why</h2><p>Git 在工作中成了必不可少的工具，个人比较喜欢使用 Git 命令，但是 Git 命令其实比较繁杂，有点难记，例如 <code>rebase</code>, <code>reset</code> 等，只要不用的时间久了，就会忘记。所以特此记录。</p><h2 id="how">how</h2><h3 id="git-clone">git clone</h3><p>用法： <code>git clone [&lt;options&gt;] [--] &lt;repo&gt; [&lt;dir&gt;]</code></p><p>作用： 克隆一个仓库到本地</p><p>常用：</p><ul><li>-b<ul><li>克隆指定分支： <code>git clone -b test git@github.com:kavience/blog.git</code></li></ul></li></ul><h3 id="git-status">git status</h3><p>用法： <code>git status [&lt;options&gt;] [--] &lt;pathspec&gt;...</code></p><p>作用： 查看暂存区</p><p>常用：</p><ul><li>s<ul><li>简要显示暂存区</li></ul></li></ul><h3 id="git-add">git add</h3><p>用法： <code>git add [&lt;options&gt;] [--] &lt;pathspec&gt;...</code></p><p>作用： 添加修改（包括添加、删除、修改等操作）到暂存区</p><p>常用：</p><ul><li>A<ul><li>添加所有修改到暂存区，等同于 <code>git add .</code></li></ul></li></ul><h3 id="git-log">git log</h3><p>用法： <code>git log [&lt;options&gt;] [&lt;revision-range&gt;] [[--] &lt;path&gt;...]</code></p><p>作用： 查看日志</p><p>常用：</p><ul><li>统计个人代码量<ul><li><code>git log --author=&quot;username&quot; --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc }' -</code></li></ul></li><li>统计所有人增删行数<ul><li><code>git log --format='%aN' | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc }' -; done</code></li></ul></li></ul><h3 id="git-commit">git commit</h3><p>用法： <code>git commit [&lt;options&gt;] [--] &lt;pathspec&gt;...</code></p><p>作用： 提交暂存区里面的修改，并生成一个唯一的 commit 号</p><p>常用：</p><h3 id="git-push">git push</h3><p>用法： <code>git push [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;...]]</code></p><p>作用： 上传当前仓库的 commit 到远程仓库地址</p><p>常用：</p><ul><li>上传一个远程仓库不存在的分支<ul><li><code>git push --set-upstream [origin] [branch]</code></li></ul></li><li>强制上传，会强制替换远程仓库（<code>慎用！！！</code>）<ul><li><code>git push -f [origin] [branch]</code></li></ul></li><li>上传 tag 到仓库<ul><li><code>git push [origin] [tag name]</code></li><li><code>git push [origin] --tags</code> 上传所有 tag</li></ul></li></ul><h3 id="git-fetch">git fetch</h3><p>用法：</p><pre><code class="highlight bash">git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;...]]   or: git fetch [&lt;options&gt;] &lt;group&gt;   or: git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)...]   or: git fetch --all [&lt;options&gt;]</code></pre><p>作用： 拉取远程分支</p><p>常用：</p><ul><li>拉取指定远程分支<ul><li><code>git fetch [origin] [branch]</code></li></ul></li><li>拉取所有分支<ul><li><code>git fetch --all</code></li></ul></li></ul><h3 id="git-merge">git merge</h3><p>用法：</p><pre><code class="highlight plain">git merge [&lt;options&gt;] [&lt;commit&gt;...]   or: git merge --abort   or: git merge --continue</code></pre><p>作用： 合并分支</p><p>常用：</p><ul><li>合并指定分支到当前分支<ul><li><code>git merge [target_branch]</code></li></ul></li><li>当有冲突的时候，继续合并（必须先解决冲突）<ul><li><code>git merge --continue</code></li></ul></li></ul><h3 id="git-pull">git pull</h3><p>用法： <code>git pull [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;...]]</code></p><p>作用： 拉取远程分支并与本地分支合并</p><p>常用：</p><ul><li>本地分支与远程分支合并<ul><li><code>git pull origin [origin_branch]:[local_branch]</code></li><li>如果本地分支与远程分支存在跟踪关系，可以直接使用  <code>git pull origin [branch]</code> ，建立跟踪关系可以使用 <code>git branch --set-upstream [local_branch] origin/[origin_branch]</code></li></ul></li></ul><h3 id="git-branch">git branch</h3><p>用法：</p><pre><code class="highlight plain">git branch [&lt;options&gt;] [-r | -a] [--merged | --no-merged]   or: git branch [&lt;options&gt;] [-l] [-f] &lt;branch-name&gt; [&lt;start-point&gt;]   or: git branch [&lt;options&gt;] [-r] (-d | -D) &lt;branch-name&gt;...   or: git branch [&lt;options&gt;] (-m | -M) [&lt;old-branch&gt;] &lt;new-branch&gt;   or: git branch [&lt;options&gt;] (-c | -C) [&lt;old-branch&gt;] &lt;new-branch&gt;   or: git branch [&lt;options&gt;] [-r | -a] [--points-at]   or: git branch [&lt;options&gt;] [-r | -a] [--format]</code></pre><p>作用： 查看、新建、删除、跟踪等操作分支</p><p>常用：</p><ul><li>查看本地所有分支<ul><li><code>git branch</code></li><li><code>git branch -v</code> 带最后一次 commit</li></ul></li><li>建立新分支<ul><li><code>git branch [branch_name]</code></li></ul></li><li>删除分支<ul><li><code>git branch -d [branch]</code></li><li><code>git branch -D [branch]</code> 强制删除，丢弃修改（慎用！！！）</li></ul></li><li>本地分支和远程分支建立跟踪关系<ul><li><code>git branch --set-upstream [local_branch] origin/[origin_branch]</code></li></ul></li></ul><h3 id="git-checkout">git checkout</h3><p>用法：</p><pre><code class="highlight plain">git checkout [&lt;options&gt;] &lt;branch&gt;   or: git checkout [&lt;options&gt;] [&lt;branch&gt;] -- &lt;file&gt;...</code></pre><p>作用： 切换分支、 tag 、 commit ，或创建且切换到新分支</p><p>常用：</p><ul><li>切换分支或指定 commit ，或者指定 tag<ul><li><code>git checkout [branch|commit|tag]</code></li></ul></li><li>创建新分支，且切换到该分支<ul><li><code>git checkout -b [branch]</code></li></ul></li></ul><h3 id="git-stash">git stash</h3><p>用法：</p><pre><code class="highlight plain">git stash list [&lt;options&gt;]   or: git stash show [&lt;options&gt;] [&lt;stash&gt;]   or: git stash drop [-q|--quiet] [&lt;stash&gt;]   or: git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]   or: git stash branch &lt;branchname&gt; [&lt;stash&gt;]   or: git stash clear   or: git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]          [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]          [--] [&lt;pathspec&gt;...]]   or: git stash save [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]          [-u|--include-untracked] [-a|--all] [&lt;message&gt;]</code></pre><p>作用： 暂存和恢复进度</p><p>常用：</p><ul><li>查看所有暂存的进度<ul><li><code>git stash list</code></li></ul></li><li>暂存当前修改<ul><li><code>git stash</code></li></ul></li><li>恢复进度<ul><li><code>git stash apply</code> 恢复最近的一次进度</li><li><code>git stash apply [stash]</code> 恢复指定的进度</li><li><code>git stash drop [stash]</code> 删除该进度</li><li><code>git stash pop [stash]</code> 恢复指定的进度并删除该进度</li></ul></li></ul><h3 id="git-rebase">git rebase</h3><p>用法： <code>git commit [&lt;options&gt;] [--] &lt;pathspec&gt;...</code></p><p>作用： 合并多次 commit 、分支合并、保持一个简洁的 commit 信息</p><p>常用：</p><ul><li>合并多次 commit<ul><li><code>git rebase -i HEAD~[n]</code> n 为 commit 次数</li></ul></li><li>分支合并<ul><li><code>git rebase [branch]</code>  合并分支到当前分支，和 merge 不一样的是不会产生 commit 信息，确保当前分支是只有本人使用，否则可能会产生丢失别人的 commit 信息。</li></ul></li></ul><h3 id="git-reset">git reset</h3><p>用法：</p><pre><code class="highlight plain">git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [&lt;commit&gt;]   or: git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;...   or: git reset --patch [&lt;tree-ish&gt;] [--] [&lt;paths&gt;...]    -q, --quiet           be quiet, only report errors    --mixed               reset HEAD and index    --soft                reset only HEAD    --hard                reset HEAD, index and working tree    --merge               reset HEAD, index and working tree    --keep                reset HEAD but keep local changes    --recurse-submodules[&#x3D;&lt;reset&gt;]                          control recursive updating of submodules    -p, --patch           select hunks interactively    -N, --intent-to-add   record only the fact that removed paths will be added later</code></pre><p>作用： 回滚到某个 commit</p><p>常用：</p><ul><li>软回滚，保留文件修改，硬回滚，丢失文件修改<ul><li><code>git reset --[soft|hard] HEAD</code> 最近一次，等同于 <code>git reset --[soft|hard] HEAD~0</code></li><li><code>git reset --[soft|hard] HEAD^</code> 上一次，等同于 <code>git reset --[soft|hard] HEAD~1</code></li><li><code>git reset --[soft|hard] HEAD^^</code> 上两次，等同于 <code>git reset --[soft|hard] HEAD~2</code></li><li><code>git reset --[soft|hard] HEAD^n^</code> 上n次，等同于 <code>git reset --[soft|hard] HEAD~n</code></li></ul></li></ul><h2 id="git-rm">git rm</h2><p>用法：</p><pre><code class="highlight plain">git rm [&lt;options&gt;] [--] &lt;file&gt;...    -n, --dry-run         dry run    -q, --quiet           do not list removed files    --cached              only remove from the index    -f, --force           override the up-to-date check    -r                    allow recursive removal    --ignore-unmatch      exit with a zero status even if nothing matched</code></pre><p>作用：删除缓存文件</p><p>常用：</p><ul><li>移除已经添加到缓存区的文件<ul><li><code>git rm -r --cached &lt;file&gt;</code></li></ul></li></ul><h2 id="总结">总结</h2><p>这只是个人工作中总结常用的一些命令，并不全面，会持续更新。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;一篇关于 Git 常用命令的记录文章。&lt;/p&gt;
&lt;h2 id=&quot;why&quot;&gt;why&lt;/h2&gt;
&lt;p&gt;Git 在工作中成了必不可少的工具，个人比较喜欢使用 Git 命令，但是 Git 命令其实比较繁杂，有点难记，例如 &lt;code&gt;
      
    
    </summary>
    
    
      <category term="tools" scheme="http://www.kavience.com/categories/tools/"/>
    
    
      <category term="git" scheme="http://www.kavience.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>利用travis做CI和CD</title>
    <link href="http://www.kavience.com/tools/use-travis-for-ci-and-cd.html"/>
    <id>http://www.kavience.com/tools/use-travis-for-ci-and-cd.html</id>
    <published>2021-04-21T10:46:14.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ci-cd-简介">CI/CD 简介</h2><p>CI: Continuous Integration ( 持续集成 )</p><p>CD: Continuous Delivery ( 持续交付 ) / Continuous Deployment ( 持续部署 )</p><p><img src="/img/blog_img/ci-cd-flow.png" alt="ci-cd-flow"></p><p>先看 Readhat 的解释：</p><blockquote><p>CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在集成新代码时所引发的问题（亦称：“集成地狱”）。具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。</p></blockquote><p>再看维基百科的解释：</p><blockquote><p>在软件工程中，CI/CD或CICD通常指的是持续集成和持续交付或持续部署的组合实践。CI/CD通过在应用程序的构建、测试和部署中实施自动化，在开发和运营团队之间架起了桥梁。</p></blockquote><p>以下是个人观点：</p><p>持续集成的概念，类似开发者在合并新的代码到主干分支的时候，系统自动执行构建并执行测试，并将结果通知到开发者。</p><p>持续交付的概念，在代码集成且验证通过后，自动将验证的代码放入存储库，持续交付的目标是可以拥有一个随时部署的代码版本。</p><p>持续部署的概念，作为持续交付的延伸，可以自动将代码发布到生产环境。</p><h2 id="ci-cd-实战">CI/CD 实战</h2><p>基于以上概念的描述，我举 <a href="https://github.com/kavience/masos-web" target="_blank" rel="noopener">masos-web</a> 这个例子</p><p>现在 masos-web 有三个分支，分别是 <code>master</code>, <code>dev</code>, <code>feat-test</code> 。</p><h3 id="git-工作流">Git 工作流</h3><p>基于 Git 工作流开发， <code>master</code> 作为稳定的主分支代码，保证可以随时部署到生产环境。 <code>dev</code> 分支作为开发分支，是 <code>master</code> 分支的延伸，与 <code>master</code> 分支不会且不应该存在冲突。 <code>feat-test</code> 是相关的开发功能分支，编写相应的代码， <code>feat-test</code> 与 <code>dev</code> 存在冲突是正常的，因为有多个功能分支同时基于 <code>dev</code> 分支开发，功能分支<strong>禁止</strong>直接合并到 <code>master</code> 分支。</p><h3 id="持续集成">持续集成</h3><ul><li>在 <code>feat-test</code> 分支上做了部分修改，然后合并到 <code>dev</code> 分支，通过 <code>review</code> 后，再执行合并。</li><li>将 <code>dev</code> 分支与 <code>master</code> 分支合并，触发自动构建、代码检查等。</li></ul><h3 id="持续交付">持续交付</h3><p>持续交付，可生产多个版本，保证项目有多个可用的版本，一旦新版本发生了不可预知的错误，可随时使用旧版本。</p><ul><li>自动生成 tag，发布版本</li></ul><h3 id="持续部署">持续部署</h3><ul><li>自动发布最新的版本到生产环境</li></ul><p>除自动发布外，还可随时手动选择不同的版本发布。</p><h2 id="travis-使用流程">Travis 使用流程</h2><ul><li><p>注册登录</p><p>到 <a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis</a> 官网登录，安装指引注册、登录、授权。如下图：</p><p><img src="/img/blog_img/travis1.png" alt="ci-cd-flow"></p><p><img src="/img/blog_img/travis2.png" alt="ci-cd-flow"></p></li><li><p>申请 GitHub token</p><p>申请路径为： GitHub &gt; settings &gt; Developer settings &gt; Personal access tokens &gt; Generate new token</p><p>申请后，会得到一个例如 ghp_mZuC0e0gGxxxxxxxxxxxxxxxxx 的一个 token。</p></li><li><p>加密 GitHub token<br>使用 travis 加密这个 token。步骤为：</p><ul><li>使用 sudo gem install travis 安装 travis</li><li>运行命令加密：<pre><code class="highlight bash">travis encrypt GITHUB_TOKEN=ghp_mZuC0e0gGxxxxxxxxxxxxxxxxx --com</code></pre></li><li>会有个确认仓库的提示，输入 yes 后回车，得到一个 <code>secure</code></li></ul></li><li><p>编写 .travis.yml<br>在项目下新建一个文件 <code>.travis.yml</code> ， 内容如下：</p><pre><code class="highlight yml"><span class="comment"># 项目为 node 开发</span><span class="attr">language:</span> <span class="string">node_js</span><span class="comment"># node 版本</span><span class="attr">node_js:</span><span class="bullet">-</span> <span class="number">14</span><span class="comment"># 任务队列 </span><span class="attr">jobs:</span>   <span class="comment"># 安装依赖</span>  <span class="attr">install:</span>    <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">install</span>  <span class="comment"># 执行一下自定义的脚本</span>  <span class="attr">script:</span>    <span class="comment"># 因为 conventional-changelog-cli 和 standard-version 不用写在 package.json ，而是采用全局安装的方式</span>    <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">global</span> <span class="string">add</span> <span class="string">conventional-changelog-cli</span> <span class="string">standard-version</span>    <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">build</span>    <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">release</span>    <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">changelog</span>    <span class="bullet">-</span> <span class="string">cp</span> <span class="string">CHANGELOG.md</span> <span class="string">build/CHANGELOG.md</span>    <span class="bullet">-</span> <span class="string">mv</span> <span class="string">build/</span> <span class="string">/tmp/build</span>  <span class="comment"># 只有 master 分支触发构建</span>  <span class="attr">branches:</span>    <span class="bullet">-</span> <span class="string">master</span>  <span class="comment"># 部署到 github pages</span>  <span class="attr">deploy:</span>    <span class="attr">provider:</span> <span class="string">pages</span>    <span class="attr">local_dir:</span> <span class="string">/tmp/build</span>    <span class="attr">skip_cleanup:</span> <span class="literal">true</span>    <span class="attr">github_token:</span> <span class="string">"$GITHUB_TOKEN"</span>    <span class="attr">keep_history:</span> <span class="literal">true</span>    <span class="attr">on:</span>      <span class="attr">branch:</span> <span class="string">master</span>  <span class="comment"># 部署后发布 tags</span>  <span class="attr">after_deploy:</span>    <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--follow-tags</span> <span class="string">origin</span> <span class="string">master</span><span class="attr">env:</span>  <span class="attr">global:</span>    <span class="comment"># &lt;secure&gt; 替换为上一步生成的 secure</span>    <span class="bullet">-</span> <span class="attr">secure:</span> <span class="string">&lt;secure&gt;</span></code></pre><blockquote><p>最新消息，travis 不再为开源项目免费提供使用。换成 GitHub action 吧。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ci-cd-简介&quot;&gt;CI/CD 简介&lt;/h2&gt;
&lt;p&gt;CI: Continuous Integration ( 持续集成 )&lt;/p&gt;
&lt;p&gt;CD: Continuous Delivery ( 持续交付 ) / Continuous Deployment ( 持续部
      
    
    </summary>
    
    
      <category term="tools" scheme="http://www.kavience.com/categories/tools/"/>
    
    
      <category term="CI-CD" scheme="http://www.kavience.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs模块addons入门</title>
    <link href="http://www.kavience.com/frontend/getting-started-with-nodejs-module-addons.html"/>
    <id>http://www.kavience.com/frontend/getting-started-with-nodejs-module-addons.html</id>
    <published>2021-03-30T05:17:19.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>打算好好学习一下 nodejs，那就先从 nodejs 官方文档看起吧，这篇博客主要是记录一下 nodejs 下的 c++ addnos 模块，看 nodejs 为什么要引入 c++ ，以及如何引入 c++ 代码。</p><p><a href="https://nodejs.org/docs/latest-v9.x/api/addons.html" target="_blank" rel="noopener">c++ addons 官方文档</a></p><h2 id="why">why</h2><blockquote><p>nodejs 采用事件驱动、异步编程，为网络服务而设计。其实 Javascript 的匿名函数和闭包特性非常适合事件驱动、异步编程。非阻塞模式的 IO 处理给 Node.js 带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它 IO 资源的中间层服务。</p></blockquote><p>Nodejs 虽然有着不错的异步能力，但是在密集型计算的时候却并不出众，简单来说所有的异步任务会维护在一个事件循环中(队列)，线程会不断的去事件循环中取任务来执行，当 CPU 密集型的任务造成执行时间过长，就会导致其他任务无法执行，这样整个程序的性能就不行了。这个时候就可以用 c++ 来编写一些 nodejs 模块，加快运算时间。</p><h2 id="how">how</h2><p>以 fibonacci 函数为例，先看一下运行结果。</p><pre><code class="highlight js"><span class="keyword">var</span> fibonacciC = <span class="built_in">require</span>(<span class="string">"./build/Release/fibonacci.node"</span>).fibonacci;<span class="function"><span class="keyword">function</span> <span class="title">fibonacciJS</span>(<span class="params">n</span>) </span>&#123;  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="keyword">else</span> <span class="keyword">return</span> fibonacciJS(n - <span class="number">1</span>) + fibonacciJS(n - <span class="number">2</span>);&#125;<span class="built_in">console</span>.time(<span class="string">"c++"</span>);<span class="built_in">console</span>.log(fibonacciC(<span class="number">40</span>));<span class="built_in">console</span>.timeEnd(<span class="string">"c++"</span>);<span class="built_in">console</span>.time(<span class="string">"js"</span>);<span class="built_in">console</span>.log(fibonacciJS(<span class="number">40</span>));<span class="built_in">console</span>.timeEnd(<span class="string">"js"</span>);<span class="comment">// 输出</span><span class="number">102334155</span>c++: <span class="number">524.515</span>ms<span class="number">102334155</span>js: <span class="number">1.335</span>s</code></pre><p>在 40 次的递归运算中，可以看到采用原生 js 实现的方式，时间是 c++ 方式实现的两倍多，如果计算时间更长的话，原生 js 实现的效率更低。</p><p>接下来看一下是如何把 c++ 的代码结合到 nodejs 中。</p><h3 id="编写-c-代码">编写 c++ 代码</h3><pre><code class="highlight c++"><span class="comment">// fibonacci.cc</span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="keyword">namespace</span> demo &#123;<span class="keyword">using</span> v8::FunctionCallbackInfo;<span class="keyword">using</span> v8::Isolate;<span class="keyword">using</span> v8::Local;<span class="keyword">using</span> v8::Object;<span class="keyword">using</span> v8::Number;<span class="keyword">using</span> v8::Value;<span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;   <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)        <span class="keyword">return</span> <span class="number">0</span>;    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)        <span class="keyword">return</span> <span class="number">1</span>;    <span class="keyword">else</span>        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);&#125;<span class="comment">/* 通过 FunctionCallbackInfo&lt;Value&gt;&amp; args 可以设置返回值 */</span><span class="function"><span class="keyword">void</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;  Isolate *isolate = args.GetIsolate();  <span class="comment">// node v10 版本之前是这样获取 number 参数的</span>  <span class="comment">// args[0]-&gt;NumberValue()</span>  <span class="comment">// v10 版本之后是这样获取的</span>  <span class="comment">// args[0].As&lt;Number&gt;()-&gt;Value()</span>  Local&lt;Number&gt; num = Number::New(isolate, fib(args[<span class="number">0</span>].As&lt;Number&gt;()-&gt;Value()));  <span class="comment">// 设置函数调用的返回值</span>  args.GetReturnValue().Set(num);  <span class="keyword">return</span> ;&#125;<span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;  <span class="comment">// 指定 module 名字</span>  NODE_SET_METHOD(exports, <span class="string">"fibonacci"</span>, fibonacci);&#125;<span class="comment">// 加载 module</span>NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)&#125;</code></pre><h3 id="编译-c-代码">编译 c++ 代码</h3><pre><code class="highlight bash"><span class="comment"># 首先要安装 node-gyp</span>npm i -g node-gyp</code></pre><p>在当前目录下添加 <code>binding.gyp</code> 文件，内容为:</p><pre><code class="highlight js">&#123;  <span class="string">"targets"</span>: [    &#123;      <span class="string">"target_name"</span>: <span class="string">"fibonacci"</span>,      <span class="string">"sources"</span>: [ <span class="string">"fibonacci.cc"</span> ]    &#125;  ]&#125;</code></pre><p>运行打包编译命令</p><pre><code class="highlight bash"><span class="comment"># 先打包</span>node-gyp  configure<span class="comment"># 会生成一个 build 目录，然后进入这个目录</span><span class="built_in">cd</span> build<span class="comment"># 编译文件</span>make</code></pre><p>这个时候会生成一个 build 目录，以及 build 目录下的 Release 目录。</p><h3 id="引入-c-模块">引入 c++ 模块</h3><p>接下来就可以像这样引入该模块</p><pre><code class="highlight js"><span class="keyword">var</span> fibonacciC = <span class="built_in">require</span>(<span class="string">"./build/Release/fibonacci.node"</span>).fibonacci;<span class="built_in">console</span>.log(fibonacciC(<span class="number">40</span>));</code></pre><h2 id="总结">总结</h2><p>引入 c++ ，借助其高效的计算能力，可以让 nodejs 也进行一些密集型的计算，本文只是一个简单的实例，更多强大的功能还需要看官方文档以及熟悉 c++ 才行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;打算好好学习一下 nodejs，那就先从 nodejs 官方文档看起吧，这篇博客主要是记录一下 nodejs 下的 c++ addnos 模块，看 nodejs 为什么要引入 c++ ，以及如何引入 c++ 代码。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://www.kavience.com/tags/JavaScript/"/>
    
      <category term="nodejs" scheme="http://www.kavience.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Apple M1 下的 Rosetta 与 Npm</title>
    <link href="http://www.kavience.com/tools/rosetta-and-npm-under-apple-m1.html"/>
    <id>http://www.kavience.com/tools/rosetta-and-npm-under-apple-m1.html</id>
    <published>2021-03-26T06:07:46.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">what</h2><p>新版的 Apple M1 是基于 arm 架构的，然而大部分的软件 和 npm 包都还没有适配 arm 架构，所以苹果公司就使用 Rosetta 来兼容 x86 架构的软件。</p><h2 id="why">why</h2><p>第一次使用 x86 软件的时候，系统会自动提示安装 Rosetta ，安装后直接运行软件即可。</p><p>然而，今天遇到一个非常奇怪的问题，在安装依赖的时候我发现无法安装 <code>node-canvas</code> 这个包，经过一系列的排查，我发现问题出在这里：</p><pre><code class="highlight shell">...npm ERR! node-pre-gyp http 404 status code downloading tarball https://github.com/Automattic/node-canvas/releases/download/v2.7.0/canvas-v2.7.0-node-v88-darwin-unknown-arm64.tar.gz...</code></pre><p>无法找到 <code>canvas-v2.7.0-node-v88-darwin-unknown-arm64.tar.gz</code> 这个包，顺着 node-canvas 的 releases 发现，根本就没有发布这个包，只有 <code>canvas-v2.7.0-node-v88-darwin-unknown-x64.tar.gz</code>，这个时候我突然意识到，当前是以 arm 架构运行的 terminal 和 npm，所以识别出来后，自动去寻找适合 arm 架构的包，然而并没有适配 arm 的包，所以就导致无法安装。</p><h2 id="how">how</h2><p>我顺着使用 x86 架构的软件的思路，我觉得既然软件可以移植到 M1 上，npm 肯定也是可以的，一定有某种方法，而且肯定与 Rosetta 有关。终于，想到办法了。</p><ol><li>在应用程序中找到 terminal ，然后右键 <code>显示简介</code>，发现有个选项 <code>使用Rosetta打开</code></li><li>打开一个 terminal，然后卸载 node ，再重新安装一次。(我是使用 nvm 安装的 node)</li><li>使用该版本的 node 安装依赖，发现成功了。</li></ol><h2 id="总结">总结</h2><p>简而言之就是安装依赖的时候，发现依赖不适用于 arm 架构的 M1，只能使用 x86 架构的依赖，所以需要借助于 Rosetta 去安装依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;what&lt;/h2&gt;
&lt;p&gt;新版的 Apple M1 是基于 arm 架构的，然而大部分的软件 和 npm 包都还没有适配 arm 架构，所以苹果公司就使用 Rosetta 来兼容 x86 架构的软件。&lt;/p&gt;
&lt;h2 id=&quot;why&quot;&gt;why&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="tools" scheme="http://www.kavience.com/categories/tools/"/>
    
    
      <category term="apple" scheme="http://www.kavience.com/tags/apple/"/>
    
  </entry>
  
  <entry>
    <title>Mobx的学习与使用</title>
    <link href="http://www.kavience.com/frontend/study-and-use-of-mobx.html"/>
    <id>http://www.kavience.com/frontend/study-and-use-of-mobx.html</id>
    <published>2021-03-24T05:20:39.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mobx-简介">mobx 简介</h2><blockquote><p>简单、可扩展的状态管理，相比于 redux，更轻巧，更简单，更灵活，在某些时候性能甚至更优越。</p></blockquote><p>在这里简单的记录和介绍一下 mobx 的使用。</p><h2 id="简单例子">简单例子</h2><pre><code class="highlight js"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;<span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">"mobx-react"</span>;<span class="keyword">var</span> numStore = observable(&#123;  num: <span class="number">1</span>,  addNum: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">this</span>.num++;  &#125;,&#125;);@observer<span class="class"><span class="keyword">class</span> <span class="title">TimerView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;  handleAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="keyword">this</span>.props.numStore.addNum();  &#125;;  render() &#123;    <span class="keyword">return</span> (      &lt;div&gt;        &lt;span&gt; num: &#123;<span class="keyword">this</span>.props.numStore.num&#125; &lt;<span class="regexp">/span&gt;</span><span class="regexp">        &lt;button onClick=&#123;this.handleAdd&#125;&gt;&lt;/</span>button&gt;      &lt;<span class="regexp">/div&gt;</span><span class="regexp">    );</span><span class="regexp">  &#125;</span><span class="regexp">&#125;</span><span class="regexp"></span><span class="regexp">ReactDOM.render(&lt;TimerView numStore=&#123;numStore&#125; /</span>&gt;, <span class="built_in">document</span>.body);</code></pre><h2 id="主要的-api">主要的 api</h2><h3 id="observable">observable</h3><p>使用：</p><ul><li>observable(value)</li><li>@observable classProperty = value</li></ul><p>Observable 值可以是 JS 基本数据类型、引用类型、普通对象、类实例、数组和映射。 主要作用是指定该值的是被观察的、可修改的。其装饰器写法为 <code>@observable</code>。例如</p><pre><code class="highlight js"><span class="keyword">import</span> &#123; observable, computed &#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;<span class="comment">// 方法1，直接使用</span><span class="keyword">var</span> NumStore = observable(&#123;  num: <span class="number">1</span>,  addNum: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">this</span>.num++;  &#125;,&#125;);<span class="comment">// 方法二，装饰器写法</span><span class="class"><span class="keyword">class</span> <span class="title">NumStore</span> </span>&#123;  @observable price = <span class="number">0</span>;  @observable num = <span class="number">1</span>;  @computed <span class="keyword">get</span> total() &#123;    <span class="keyword">return</span> <span class="keyword">this</span>.price * <span class="keyword">this</span>.num;  &#125;&#125;</code></pre><h3 id="computed">computed</h3><p>如果任何影响计算值的值发生变化了，计算值将根据状态自动进行衍生。 计算值在大多数情况下可以被 MobX 优化的，因为它们被认为是纯函数。 例如，如果前一个计算中使用的数据没有更改，计算属性将不会重新运行。 如果某个其它计算属性或 reaction 未使用该计算属性，也不会重新运行。 在这种情况下，它将被暂停。</p><pre><code class="highlight js"><span class="keyword">import</span> &#123; observable, computed &#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;<span class="class"><span class="keyword">class</span> <span class="title">NumStore</span> </span>&#123;  @observable price = <span class="number">0</span>;  @observable num = <span class="number">1</span>;  @computed <span class="keyword">get</span> total() &#123;    <span class="keyword">return</span> <span class="keyword">this</span>.price * <span class="keyword">this</span>.num;  &#125;&#125;</code></pre><h3 id="autorun">autorun</h3><p>autorun 可以用来监听值的变化，不要把 <code>computed</code> 和 <code>autorun</code> 搞混。它们都是响应式调用的表达式，但是，如果你想响应式的产生一个可以被其它 observer 使用的值，请使用 @computed，如果你不想产生一个新值，而想要达到一个效果，请使用 autorun。 举例来说，效果是像打印日志、发起网络请求等这样命令式的副作用。</p><pre><code class="highlight js"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;<span class="keyword">import</span> &#123; observable, configure, action, runInAction, autorun &#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;configure(&#123; <span class="attr">enforceActions</span>: <span class="string">"observed"</span> &#125;);<span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Session</span> </span>&#123;  @observable num = <span class="number">1</span>;  <span class="keyword">constructor</span>() &#123;    autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;      <span class="comment">// 每次调用 addNum / subNum都会执行此函数</span>      <span class="built_in">console</span>.log(<span class="string">"auto log num:"</span> + <span class="keyword">this</span>.num);    &#125;);  &#125;  @action addNum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);    <span class="keyword">this</span>.num++;  &#125;;  @action subNum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="keyword">this</span>.num--;  &#125;;&#125;<span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Session();</code></pre><h3 id="action">action</h3><p>用法:</p><ul><li>action(fn)</li><li>action(name, fn)</li><li>@action classMethod() {}</li><li>@action(name) classMethod () {}</li><li>@action boundClassMethod = (args) =&gt; { body }</li><li>@action(name) boundClassMethod = (args) =&gt; { body }</li><li>@action.bound classMethod() {}</li></ul><p>action 主要是用来修改状态，也可以使用异步的方法</p><pre><code class="highlight js"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;<span class="keyword">import</span> &#123; observable, configure, action, runInAction &#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;<span class="comment">// 强制使用 action 来修改状态，否则会打印 waring</span>configure(&#123; <span class="attr">enforceActions</span>: <span class="string">"observed"</span> &#125;);<span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Session</span> </span>&#123;  @observable num = <span class="number">1</span>;  @observable loading = <span class="literal">false</span>;  @action addNum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);    <span class="keyword">this</span>.num++;  &#125;;  @action subNum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="keyword">this</span>.num--;  &#125;;  @action directGetHundred = <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="keyword">this</span>.loading = <span class="literal">true</span>;    setTimeout(      <span class="comment">// 所有的修改状态都需要放在 action 中</span>      action(<span class="string">"directAddHundred"</span>, () =&gt; &#123;        <span class="keyword">this</span>.num += <span class="number">100</span>;        <span class="keyword">this</span>.loading = <span class="literal">false</span>;      &#125;),      <span class="number">1000</span>    );  &#125;;  @action directGetTwoHundred = <span class="keyword">async</span> () =&gt; &#123;    <span class="keyword">this</span>.loading = <span class="literal">true</span>;    <span class="keyword">await</span> axios(<span class="string">"/"</span>);    <span class="comment">// 调用其他异步操作</span>    <span class="comment">// await axios("/");</span>    <span class="comment">// runInAction 是 action 的语法糖，鼓励你不要到处写 action，而是在整个过程结束时尽可能多地对所有状态进行修改</span>    runInAction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;      <span class="keyword">this</span>.loading = <span class="literal">false</span>;      <span class="keyword">this</span>.num += <span class="number">200</span>;    &#125;);  &#125;;&#125;<span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Session();</code></pre><h2 id="flows">flows</h2><p>flows 的工作原理与 async / await 是一样的。只是使用 function * 来代替 async，使用 yield 代替 await 。 使用 flow 的优点是它在语法上基本与 async / await 是相同的 (只是关键字不同)，并且不需要手动用 @action 来包装异步代码，这样代码更简洁。</p><p>flow 只能作为函数使用，不能作为装饰器使用。 flow 可以很好的与 MobX 开发者工具集成，所以很容易追踪 async 函数的过程。</p><pre><code class="highlight js">mobx.configure(&#123; <span class="attr">enforceActions</span>: <span class="literal">true</span> &#125;);<span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;  @observable githubProjects = [];  @observable state = <span class="string">"pending"</span>;  fetchProjects = flow(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;    <span class="comment">// &lt;- 注意*号，这是生成器函数！</span>    <span class="keyword">this</span>.githubProjects = [];    <span class="keyword">this</span>.state = <span class="string">"pending"</span>;    <span class="keyword">try</span> &#123;      <span class="keyword">const</span> projects = <span class="keyword">yield</span> fetchGithubProjectsSomehow(); <span class="comment">// 用 yield 代替 await</span>      <span class="keyword">const</span> filteredProjects = somePreprocessing(projects);      <span class="comment">// 异步代码块会被自动包装成动作并修改状态</span>      <span class="keyword">this</span>.state = <span class="string">"done"</span>;      <span class="keyword">this</span>.githubProjects = filteredProjects;    &#125; <span class="keyword">catch</span> (error) &#123;      <span class="keyword">this</span>.state = <span class="string">"error"</span>;    &#125;  &#125;);&#125;</code></pre><h2 id="总结">总结</h2><p>之前一直使用 redux，看到了有赞前端技术团队的 <a href="https://tech.youzan.com/mobx_vs_redux/" target="_blank" rel="noopener">我为什么从 Redux 迁移到了 Mobx<br></a> 文章，决定了解一下 mobx ，现在这里只记录 mobx 的简单使用，详细的还是需要查看<a href="https://cn.mobx.js.org/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mobx-简介&quot;&gt;mobx 简介&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;简单、可扩展的状态管理，相比于 redux，更轻巧，更简单，更灵活，在某些时候性能甚至更优越。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里简单的记录和介绍一下 mobx 的使用。&lt;/
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="mobx" scheme="http://www.kavience.com/tags/mobx/"/>
    
      <category term="mobx-react" scheme="http://www.kavience.com/tags/mobx-react/"/>
    
  </entry>
  
  <entry>
    <title>Typescript常见知识总结</title>
    <link href="http://www.kavience.com/frontend/typescript-common-knowledge-summary.html"/>
    <id>http://www.kavience.com/frontend/typescript-common-knowledge-summary.html</id>
    <published>2020-12-25T06:11:17.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="never-unknown-any-三者之间的区别">never, unknown, any 三者之间的区别</h2><p>三者都是 TypeScript 的类型, never 是最具体的类型，因为没有哪个集合比空集合更小了；而 unknown 是最弱的类型，因为它包含了全部可能的值。 any 则不为集合，它破坏了类型检查，因此请尽量不要使用 any。在 TypeScript 中， nerver 可以赋值为 unknown 和 any ，但是 unknown 和 any 不可以赋值给 never，never 只能赋值 never。</p><p>那 nerver 的作用是什么呢？举个尤雨溪提到的<a href="https://www.zhihu.com/question/354601204/answer/888551021" target="_blank" rel="noopener">例子</a>：</p><pre><code class="highlight ts"><span class="keyword">interface</span> Foo &#123;  <span class="keyword">type</span>: <span class="string">"foo"</span>;&#125;<span class="keyword">interface</span> Bar &#123;  <span class="keyword">type</span>: <span class="string">"bar"</span>;&#125;<span class="keyword">type</span> All = Foo | Bar;<span class="function"><span class="keyword">function</span> <span class="title">handleValue</span>(<span class="params">val: All</span>) </span>&#123;  <span class="keyword">switch</span> (val.type) &#123;    <span class="keyword">case</span> <span class="string">"foo"</span>:      <span class="comment">// 这里 val 被收窄为 Foo</span>      <span class="keyword">break</span>;    <span class="keyword">case</span> <span class="string">"bar"</span>:      <span class="comment">// val 在这里是 Bar</span>      <span class="keyword">break</span>;    <span class="keyword">default</span>:      <span class="comment">// val 在这里是 never</span>      <span class="keyword">const</span> exhaustiveCheck: never = val;      <span class="keyword">break</span>;  &#125;&#125;</code></pre><p>注意在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事改了 All 的类型：</p><pre><code class="highlight ts"><span class="keyword">type</span> All = Foo | Bar | Baz;</code></pre><p>然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 All 的可能类型。</p><h2 id="interface-与-type-的区别">interface 与 type 的区别</h2><h3 id="相同点：">相同点：</h3><h4 id="都可以描述一个对象或者函数">都可以描述一个对象或者函数</h4><pre><code class="highlight ts"><span class="comment">// 使用 interface</span><span class="keyword">interface</span> User &#123;  name: <span class="built_in">string</span>;  age: <span class="built_in">number</span>;&#125;<span class="keyword">interface</span> SetUser &#123;  (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>): <span class="built_in">void</span>;&#125;</code></pre><pre><code class="highlight ts"><span class="comment">// 使用 type</span><span class="keyword">type</span> User = &#123;  name: <span class="built_in">string</span>;  age: <span class="built_in">number</span>;&#125;;<span class="keyword">type</span> SetUser = <span class="function">(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</code></pre><h4 id="都允许扩展">都允许扩展</h4><pre><code class="highlight ts"><span class="keyword">interface</span> Name &#123;  name: <span class="built_in">string</span>;&#125;<span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123;  age: <span class="built_in">number</span>;&#125;</code></pre><pre><code class="highlight ts"><span class="keyword">type</span> Name = &#123;  name: <span class="built_in">string</span>;&#125;;<span class="keyword">type</span> User = Name &amp; &#123; age: <span class="built_in">number</span> &#125;;</code></pre><h3 id="不同点">不同点</h3><h4 id="type-可以而-interface-不行">type 可以而 interface 不行</h4><p>type 可以声明基本类型别名，联合类型，元组等类型</p><pre><code class="highlight ts"><span class="comment">// 基本类型别名</span><span class="keyword">type</span> Name = <span class="built_in">string</span>;<span class="comment">// 联合类型</span><span class="keyword">interface</span> Dog &#123;  wong();&#125;<span class="keyword">interface</span> Cat &#123;  miao();&#125;<span class="keyword">type</span> Pet = Dog | Cat;<span class="comment">// 具体定义数组每个位置的类型</span><span class="keyword">type</span> PetList = [Dog, Pet];</code></pre><p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</p><pre><code class="highlight ts"><span class="comment">// 当你想获取一个变量的类型时，使用 typeof</span><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);<span class="keyword">type</span> B = <span class="keyword">typeof</span> div;</code></pre><p>其它用法</p><pre><code class="highlight ts"><span class="keyword">type</span> StringOrNumber = <span class="built_in">string</span> | <span class="built_in">number</span>;<span class="keyword">type</span> Text = <span class="built_in">string</span> | &#123; text: <span class="built_in">string</span> &#125;;<span class="keyword">type</span> NameLookup = Dictionary&lt;<span class="built_in">string</span>, Person&gt;;<span class="keyword">type</span> Callback&lt;T&gt; = <span class="function">(<span class="params">data: T</span>) =&gt;</span> <span class="built_in">void</span>;<span class="keyword">type</span> Pair&lt;T&gt; = [T, T];<span class="keyword">type</span> Coordinates = Pair&lt;<span class="built_in">number</span>&gt;;<span class="keyword">type</span> Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;; right: Tree&lt;T&gt; &#125;;</code></pre><h4 id="interface-可以而-type-不行">interface 可以而 type 不行</h4><p>interface 能够声明合并</p><pre><code class="highlight ts"><span class="keyword">interface</span> User &#123;  name: <span class="built_in">string</span>;  age: <span class="built_in">number</span>;&#125;<span class="keyword">interface</span> User &#123;  sex: <span class="built_in">string</span>;&#125;<span class="comment">/*</span><span class="comment">User 接口为 &#123;</span><span class="comment">  name: string</span><span class="comment">  age: number</span><span class="comment">  sex: string </span><span class="comment">&#125;</span><span class="comment">*/</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;never-unknown-any-三者之间的区别&quot;&gt;never, unknown, any 三者之间的区别&lt;/h2&gt;
&lt;p&gt;三者都是 TypeScript 的类型, never 是最具体的类型，因为没有哪个集合比空集合更小了；而 unknown 是最弱的类型，因
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="typescript" scheme="http://www.kavience.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题之Js进阶(持续更新)</title>
    <link href="http://www.kavience.com/frontend/js-advanced-frontend-interview-questions-continuous-update.html"/>
    <id>http://www.kavience.com/frontend/js-advanced-frontend-interview-questions-continuous-update.html</id>
    <published>2020-11-12T11:05:46.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型">数据类型</h2><p>Number, String, Bool, Null, Undefined, Symbol, 引用数据类型( Object, Function, Array )。</p><p>Null 与 Undefined 的区别:</p><p>Null</p><ul><li><p>作为函数的参数, 表示该函数的参数不是对象。</p></li><li><p>作为对象原型链的终点。</p></li></ul><p>Undefined</p><ul><li><p>变量被声明了, 但没有赋值时, 就等于 undefined。</p></li><li><p>调用函数时, 应该提供的参数没有提供, 该参数等于 undefined。</p></li><li><p>对象没有赋值的属性, 该属性的值为 undefined。</p></li><li><p>函数没有返回值时, 默认返回 undefined。</p></li></ul><h2 id="var-const-let-的区别">var, const, let 的区别</h2><ul><li>var 命令存在变量提升现象, 可在声明之前使用, let 与 const 则不存在</li><li>let 与 const 存在暂时性死区的现象, 这个区块对这些命令声明的变量, 从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量, 就会报错。</li><li>let 与 const 不可以重复声明。</li><li>const 声明的是只读的常量, 一旦声明, 就必须立即初始化, 声明之后值不能改变。</li><li>let 与 const 是块级作用域。</li></ul><table><thead><tr><th>声明方式</th><th>变量提升</th><th>暂时性死区</th><th>重复声明</th><th>初始值</th><th>作用域</th></tr></thead><tbody><tr><td>var</td><td>允许</td><td>不存在</td><td>允许</td><td>不需要</td><td>除块级</td></tr><tr><td>let</td><td>不允许</td><td>存在</td><td>不允许</td><td>不需要</td><td>块级</td></tr><tr><td>const</td><td>不允许</td><td>存在</td><td>不允许</td><td>需要</td><td>块级</td></tr></tbody></table><h2 id="new-的过程">new 的过程</h2><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;    <span class="keyword">this</span>.name = name;&#125;Person.prototype = &#123;    <span class="keyword">constructor</span>: Person,    sayName: function() &#123;         alert(<span class="keyword">this</span>.name);&#125;;<span class="keyword">var</span> jack = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>);</code></pre><p>首先, 必须保证 new 运算符后跟着的是一个有<code>[[Construct]]</code>内部方法的对象, 否则会抛出异常。</p><p>接下来就是创建对象的过程:</p><ol><li><p>先创建一个原生对象, 假定为 obj = {} 或 obj = new Object。</p></li><li><p>获得构造函数 Person 的 prototype 对象, 并将其赋给 obj 的<code>[[Prototype]]</code>属性, 表现为<code>__proto__</code>。</p></li><li><p>call 构造函数的内部方法, 把其中的 this 赋值为新创建的对象 obj, 并传入所需参数。</p></li><li><p>执行构造函数, 并返回创建的对象。</p></li></ol><p>这里有一点需要说明: 正常来讲构造函数中是不用写 return 语句的, 因为它会默认返回新创建的对象。但是, 如果在构造函数中写了 return 语句, 如果 return 的是一个对象, 那么函数就会覆盖掉新创建的对象, 而返回此对象；如果 return 的是基本类型如字符串、数字、布尔值等, 那么函数会忽略掉 return 语句, 还是返回新创建的对象。</p><h3 id="实现一个-new">实现一个 new</h3><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">Fn</span>) </span>&#123;  <span class="keyword">const</span> obj = &#123;&#125;;  <span class="keyword">if</span> (<span class="keyword">typeof</span> Fn === <span class="string">"function"</span>) &#123;    obj.__proto__ = Fn.prototype;    <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>);    Fn.call(obj, ...args);  &#125;  <span class="keyword">return</span> obj;&#125;<span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;&#125;<span class="keyword">const</span> person = myNew(Person, <span class="string">"张三"</span>);<span class="built_in">console</span>.log(person.name);</code></pre><h2 id="this-的指向">this 的指向</h2><p>在 js 中 this 一般会出现在如下情况:</p><ol><li>全局状态下</li><li>一般函数内</li><li>this 和对象转换</li><li>原型链中</li><li>与 DOM 相关</li></ol><p>详见另一篇文章 - <a href="../js-%E5%BD%BB%E5%BA%95%E4%BA%86%E8%A7%A3this%E7%9A%84%E6%8C%87%E5%90%91">js-彻底了解 this 的指向</a></p><h2 id="apply-call-bind-的区别与实现">apply, call, bind 的区别与实现</h2><p>bind 与 call 或 apply 最大的区别就是 bind 不会被立即调用, 而是返回一个函数, 函数内部的 this 指向与 bind 执行时的第一个参数, 而传入 bind 的第二个及以后的参数作为原函数的参数来调用原函数。</p><p>call, apply 都是为了改变某个函数运行时的上下文而存在的, 简单点说就是为了改变某个运行时函数内部 this 指向, 区别在于 apply 第二参数需要是一个参数数组, call 的第二参数及其之后的参数需要是数组里面的元素。</p><h3 id="apply-的实现">apply 的实现</h3><pre><code class="highlight js"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;  <span class="comment">// 基础类型转包装对象</span>  <span class="keyword">if</span> (context === <span class="literal">undefined</span> || context === <span class="literal">null</span>) &#123;    context = <span class="built_in">window</span>;  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">"string"</span>) &#123;    context = <span class="keyword">new</span> <span class="built_in">String</span>(context);  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">"number"</span>) &#123;    context = <span class="keyword">new</span> <span class="built_in">Number</span>(context);  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">"boolean"</span>) &#123;    context = <span class="keyword">new</span> <span class="built_in">Boolean</span>(context);  &#125;  <span class="comment">// 非对象, 非undefined, 非null的值才会抛错</span>  <span class="keyword">if</span> (    <span class="keyword">typeof</span> arr !== <span class="string">"object"</span> &amp;&amp;    <span class="keyword">typeof</span> arr !== <span class="string">"undefined"</span> &amp;&amp;    <span class="keyword">typeof</span> arr !== <span class="string">"null"</span>  )    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"CreateListFromArrayLike called on non-object"</span>);  arr = (<span class="built_in">Array</span>.isArray(arr) &amp;&amp; arr) || []; <span class="comment">// 非数组就赋值空数组</span>  <span class="comment">// 保存原函数至指定对象的fn属性上</span>  context.fn = <span class="keyword">this</span>;  <span class="comment">// 通过指定对象的fn属性执行原函数并出入参数</span>  <span class="keyword">const</span> fnValue = context.fn(...arr);  <span class="keyword">delete</span> context.fn; <span class="comment">// 从context中删除fn原函数</span>  <span class="keyword">return</span> fnValue;&#125;;</code></pre><h3 id="call-的实现">call 的实现</h3><pre><code class="highlight js"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;  <span class="comment">// 基础类型转包装对象</span>  <span class="keyword">if</span> (context === <span class="literal">undefined</span> || context === <span class="literal">null</span>) &#123;    context = <span class="built_in">window</span>;  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">"string"</span>) &#123;    context = <span class="keyword">new</span> <span class="built_in">String</span>(context);  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">"number"</span>) &#123;    context = <span class="keyword">new</span> <span class="built_in">Number</span>(context);  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">"boolean"</span>) &#123;    context = <span class="keyword">new</span> <span class="built_in">Boolean</span>(context);  &#125;  <span class="comment">// 保存原函数至指定对象的fn属性上</span>  context.fn = <span class="keyword">this</span>;  <span class="comment">// 获取除第一个参数之后的所有参数</span>  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>);  <span class="comment">// 通过指定对象的fn属性执行原函数并出入参数</span>  <span class="keyword">const</span> fnValue = context.fn(...args);  <span class="keyword">delete</span> context.fn; <span class="comment">// 从context中删除fn原函数</span>  <span class="keyword">return</span> fnValue;&#125;;</code></pre><h3 id="bind-的实现">bind 的实现</h3><pre><code class="highlight js"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;  <span class="comment">// 保存原函数</span>  <span class="keyword">const</span> ofn = <span class="keyword">this</span>;  <span class="comment">// 获取除第一个参数之后的所有参数</span>  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>);  <span class="function"><span class="keyword">function</span> <span class="title">O</span>(<span class="params"></span>) </span>&#123;&#125;  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;    <span class="comment">// 第一个参数的判断是为了忽略使用new实例化函数时让this指向它自己, 否则就指向这个context指定对象</span>    <span class="comment">// 第二个参数的处理做了参数合并,  就是 bind &amp; fn 两个函数的参数合并</span>    ofn.apply(      <span class="keyword">this</span> <span class="keyword">instanceof</span> O ? <span class="keyword">this</span> : context,      args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>))    );  &#125;  O.prototype = <span class="keyword">this</span>.prototype;  fn.prototype = <span class="keyword">new</span> O();  <span class="keyword">return</span> fn;&#125;;</code></pre><h2 id="闭包">闭包</h2><h2 id="时间循环">时间循环</h2><h2 id="类型判断">类型判断</h2><h2 id="手写-promise">手写 promise</h2><h2 id="垃圾回收机制">垃圾回收机制</h2><h2 id="原型链">原型链</h2><blockquote><p>概要: 每个构造函数( construct ) 都有一个原型对象, 原型对象( prototype )都包含一个指向构造函数的内部指针, 而实例( instance ) 都包含指向原型对象的内部指针。实例与原型的链条称作<code>原型链</code>。</p></blockquote><p>网上看到一张图, 感觉很全面的描述了原型链之间的关系:</p><p><img src="/img/blog_img/prototype.png" alt="prototype"></p><p>注意: <code>prototype</code> 是函数(ES6 中箭头函数除外)特有的属性, 实例对象不存在该属性, <code>__proto__</code> 则在两者内都存在, 因为函数也是对象。</p><h2 id="继承的实现">继承的实现</h2><p>七种 JS 继承方式分别是:</p><ul><li>原型链继承</li><li>构造函数式继承</li><li>组合式继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li><li>ES6 关键字 extends 继承</li></ul><h3 id="原型链继承">原型链继承</h3><p>基本思想: 通过直接改变子类的 prototype 实现。</p><p>优点: 实例可继承的属性有: 实例的构造函数的属性, 父类构造函数的属性, 父类原型上的属性（新实例不会继承父类实例的属性）。</p><p>缺点: 新实例无法向父类构造函数传参, 继承单一, 所有新实例都会共享父类实例的属性。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;&#125;Person.prototype.job = <span class="string">"frontend"</span>;<span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">this</span>.name = <span class="string">"child"</span>;&#125;Child.prototype = <span class="keyword">new</span> Person();<span class="keyword">var</span> child = <span class="keyword">new</span> Child();<span class="built_in">console</span>.log(child.job); <span class="comment">// frontend</span><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></code></pre><h3 id="构造函数式继承">构造函数式继承</h3><p>基本思想: 在子类型构造函数的内部调用超类型构造函数.</p><p>优点: 保证了原型链中引用类型值的独立, 不再被所有实例共享, 子类型创建时也能够向父类型传递参数。</p><p>缺点: 方法都在构造函数中定义, 函数难以复用, 而且父类中定义的方法, 对子类而言也是不可见的。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;<span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;  Father.call(<span class="keyword">this</span>); <span class="comment">//继承了Father,且向父类型传递参数</span>&#125;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();instance1.colors.push(<span class="string">"black"</span>);<span class="built_in">console</span>.log(instance1.colors); <span class="comment">//"red,blue,green,black"</span><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();<span class="built_in">console</span>.log(instance2.colors); <span class="comment">//"red,blue,green" 可见引用类型值是独立的</span></code></pre><h3 id="组合式继承">组合式继承</h3><p>基本思路: 使用原型链实现对原型属性和方法的继承, 通过借用构造函数来实现对实例属性的继承。</p><p>优点: 通过在原型上定义方法实现了函数复用, 又能保证每个实例都有它自己的属性。</p><p>缺点: 调用了两次父类构造函数, 造成了不必要的消耗。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;Father.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.name);&#125;;<span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;  Father.call(<span class="keyword">this</span>, name); <span class="comment">//继承实例属性, 第一次调用Father()</span>  <span class="keyword">this</span>.age = age;&#125;Son.prototype = <span class="keyword">new</span> Father(); <span class="comment">//继承父类方法,第二次调用Father()</span>Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.age);&#125;;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>, <span class="number">5</span>);instance1.colors.push(<span class="string">"black"</span>);<span class="built_in">console</span>.log(instance1.colors); <span class="comment">//"red,blue,green,black"</span>instance1.sayName(); <span class="comment">//louis</span>instance1.sayAge(); <span class="comment">//5</span><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>, <span class="number">10</span>);<span class="built_in">console</span>.log(instance1.colors); <span class="comment">//"red,blue,green"</span>instance1.sayName(); <span class="comment">//zhai</span>instance1.sayAge(); <span class="comment">//10</span></code></pre><h3 id="原型式继承">原型式继承</h3><p>基本思想: 也是通过 prototype 完成继承, 只不过在多了一层函数调用。</p><p>优点: 用一个函数包装一个对象, 然后返回这个函数的调用, 这个函数就变成了可以随意增添属性的实例或对象。<code>Object.create()</code> 就是这个原理。</p><p>缺点: 所有的实例都会继承原型上的属性, 无法实现复用。</p><pre><code class="highlight js"><span class="comment">// 先封装一个函数容器, 用来承载继承的原型和输出对象</span><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;  F.prototype = obj;  <span class="keyword">return</span> <span class="keyword">new</span> F();&#125;<span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;&#125;<span class="keyword">var</span> super0 = <span class="keyword">new</span> Person();<span class="keyword">var</span> super1 = object(super0);<span class="built_in">console</span>.log(super1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></code></pre><h3 id="寄生式继承">寄生式继承</h3><p>基本思想: 寄生式继承的思路与(寄生)构造函数和工厂模式类似, 即创建一个仅用于封装继承过程的函数, 该函数在内部以某种方式来增强对象, 最后再像真的是它做了所有工作一样返回对象。</p><p>优点: 借助原型可以基于已有的对象创建新对象, 同时还不必因此创建自定义类型。</p><p>缺点: 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率, 这一点与构造函数模式类似。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;  <span class="comment">// 通过 prototype 继承</span>  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;  F.prototype = obj;  <span class="keyword">return</span> <span class="keyword">new</span> F();&#125;<span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;&#125;<span class="keyword">var</span> sup = <span class="keyword">new</span> Person();<span class="function"><span class="keyword">function</span> <span class="title">subobject</span>(<span class="params">obj</span>) </span>&#123;  <span class="keyword">var</span> sub = object(obj);  sub.name = <span class="string">"ming"</span>;  <span class="keyword">return</span> sub;&#125;<span class="keyword">var</span> sup2 = subobject(sup);<span class="comment">// 这个函数经过声明后就成了可增添属性的对象</span><span class="built_in">console</span>.log(sup2.name); <span class="comment">// 'ming'</span><span class="built_in">console</span>.log(sup2 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></code></pre><h3 id="寄生组合式继承">寄生组合式继承</h3><p>基本思想: 不必为了指定子类型的原型而调用超类型的构造函数。</p><p>优点: 集寄生式继承和组合继承的优点于一身, 是实现基于类型继承的最有效方法。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;&#125;<span class="comment">// 寄生</span><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;  F.prototype = obj;  <span class="keyword">return</span> <span class="keyword">new</span> F();&#125;<span class="comment">// object是F实例的另一种表示方法</span><span class="keyword">var</span> obj = object(Person.prototype);<span class="comment">// obj实例（F实例）的原型继承了父类函数的原型</span><span class="comment">// 上述更像是原型链继承, 只不过只继承了原型属性</span><span class="comment">// 组合</span><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">this</span>.age = <span class="number">100</span>;  Person.call(<span class="keyword">this</span>); <span class="comment">// 这个继承了父类构造函数的属性</span>&#125; <span class="comment">// 解决了组合式两次调用构造函数属性的特点</span>Sub.prototype = obj;<span class="built_in">console</span>.log(Sub.prototype.constructor); <span class="comment">// Person</span>obj.constructor = Sub; <span class="comment">// 重点, 一定要修复实例</span><span class="built_in">console</span>.log(Sub.prototype.constructor); <span class="comment">// Sub</span><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();<span class="comment">// Sub实例就继承了构造函数属性, 父类实例, object的函数属性</span><span class="built_in">console</span>.log(sub1.job); <span class="comment">// frontend</span><span class="built_in">console</span>.log(sub1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></code></pre><h3 id="es6-关键字-extends-继承">ES6 关键字 extends 继承</h3><p>ES6 关键字 extends 继承本质也是组合式继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据类型&quot;&gt;数据类型&lt;/h2&gt;
&lt;p&gt;Number, String, Bool, Null, Undefined, Symbol, 引用数据类型( Object, Function, Array )。&lt;/p&gt;
&lt;p&gt;Null 与 Undefined 的区别:&lt;/p
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="前端面试题" scheme="http://www.kavience.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题之其它概念(持续更新)</title>
    <link href="http://www.kavience.com/frontend/other-concepts-of-frontend-interview-questions-continuous-update.html"/>
    <id>http://www.kavience.com/frontend/other-concepts-of-frontend-interview-questions-continuous-update.html</id>
    <published>2020-11-12T11:05:46.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器垃圾回收机制">浏览器垃圾回收机制</h2><p>浏览器的垃圾回收机制（Garbage collection<br>）, 简称 GC, 它会周期性运行以释放那些不需要的内存, 否则, JavaScript 的解释器将会耗尽全部系统内存而导致系统崩溃。具体到浏览器中的实现, 通常有两个策略: 标记清除和引用计数。</p><h3 id="引用计数法">引用计数法</h3><p>此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用）, 对象将被垃圾回收机制回收。引用计数法是最初级的垃圾收集算法, 如果某对象没有其他对象指向它了, 那就说明它可以被回收。但是它无法处理循环引用的问题。我们执行 f 函数, 它返回了一个数字, 和内部的 o1,o2 没什么关系, 但是对引用计数法来说, o1,o2 它们之间还存在着相互引用, 并不会被回收。这就造成了内存泄漏。</p><h3 id="标记清除法">标记清除法</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。<br>从 2012 年起, 所有现代浏览器都使用了标记-清除垃圾回收算法。标记清除法假定存在一个根对象（相当于 js 的全局对象）, 垃圾回收器将定期从根对象开始查找, 凡是从根部出发能扫描到的都会保留, 扫描不到的将被回收。</p><p>内部流程</p><ul><li>垃圾收集器找到所有的根, 并“标记”（记住）它们。</li><li>然后它遍历并“标记”来自它们的所有引用。</li><li>然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住, 以免将来再次遍历到同一个对象。</li><li>……如此操作, 直到所有可达的（从根部）引用都被访问到。</li><li>没有被标记的对象都会被删除。</li></ul><h3 id="几种常见的内存泄漏">几种常见的内存泄漏</h3><ol><li><p>全局变量</p><p>全局变量什么时候需要自动释放内存空间很难判断, 所以在开发中尽量避免使用全局变量, 以提高内存有效使用率。</p></li><li><p>未移除的事件绑定</p><p>dom 元素虽然被移除了, 但元素绑定的事件还在, 如果不及时移除事件绑定, 在 IE9 以下版本容易导致内存泄漏。现代浏览器不存在这个问题了, 了解一下即可</p></li><li><p>定时器 setInterval/setTimeout</p><p>看下面的一段定时器代码, 一旦我们在其它地方移除了 node 节点, 定时器的回调便失去了意义, 然而它一直在执行导致 callback 无法回收, 进而造成 callback 内部掉数据 resData 也无法被回收。所以我们应该及时 clear 定时器。</p><pre><code class="highlight js"><span class="keyword">let</span> resData = <span class="number">100</span>;<span class="keyword">let</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="keyword">let</span> node = <span class="built_in">document</span>.querySelecter(<span class="string">".p"</span>);  node &amp;&amp; (node.innerHTML = resData);&#125;;setInterval(callback, <span class="number">1000</span>);</code></pre></li></ol><h3 id="weakmap-weakset">WeakMap、WeakSet</h3><p>es6 的 WeakMap 和 Map 类似, 都是用于生成键值对的集合, 不同的是 WeakMap 是一种弱引用, 它的键名所指向的对象, 不计入垃圾回收机制, 另外就是 WeakMap 只接受对象作为键名（null 除外）, 而 Map 可以接受各种类型的数据作为键。</p><p>WeakMap 这种结构有助于防止内存泄漏, 一旦消除对键的引用, 它占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对, 也会自动消失。包括 WeakSet 也是类似的, 内部存储的都是弱引用对象, 不会被计入垃圾回收。</p><p>看一个阮一峰 ES6 文档上举的例子:</p><pre><code class="highlight js"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();myWeakmap.set(<span class="built_in">document</span>.getElementById(<span class="string">"logo"</span>), &#123; <span class="attr">timesClicked</span>: <span class="number">0</span> &#125;);<span class="built_in">document</span>.getElementById(<span class="string">"logo"</span>).addEventListener(  <span class="string">"click"</span>,  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">let</span> logoData = myWeakmap.get(<span class="built_in">document</span>.getElementById(<span class="string">"logo"</span>));    logoData.timesClicked++;  &#125;,  <span class="literal">false</span>);</code></pre><p>上面代码中, 我们将 dom 对象作为键名, 每次点击, 我们就更新一下状态。我们将这个状态作为键值放在 WeakMap 里。一旦这个 DOM 节点删除, 该状态就会自动消失, 不存在内存泄漏风险。</p><p>WeakSet 和 WeakMap 类似, 它和 set 结构的区别也是两点:</p><p>WeakSet 中的对象都是弱引用, 不会被计入垃圾回收<br>成员只能是对象, 而不能是其他类型的值<br>所以从垃圾回收的角度来看, 合理的使用 WeakMap 和 WeakSet, 能帮助我们避免内存泄漏。</p><h2 id="浏览器工作原理">浏览器工作原理</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">MDN 链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浏览器垃圾回收机制&quot;&gt;浏览器垃圾回收机制&lt;/h2&gt;
&lt;p&gt;浏览器的垃圾回收机制（Garbage collection&lt;br&gt;
）, 简称 GC, 它会周期性运行以释放那些不需要的内存, 否则, JavaScript 的解释器将会耗尽全部系统内存而导致系统崩溃。具体
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="前端面试题" scheme="http://www.kavience.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题之界面与样式(持续更新)</title>
    <link href="http://www.kavience.com/frontend/interface-and-style-of-frontend-interview-questions-continuous-update.html"/>
    <id>http://www.kavience.com/frontend/interface-and-style-of-frontend-interview-questions-continuous-update.html</id>
    <published>2020-11-12T11:05:46.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="html-概念">Html 概念</h2><h3 id="doctype-的作用">DOCTYPE 的作用</h3><p>告诉浏览器使用哪个版本的 HTML 规范来渲染文档。DOCTYPE 不存在或形式不正确会导致 HTML 文档以混杂模式呈现。<br>标准模式（Standards mode）以浏览器支持的最高标准运行；混杂模式（Quirks mode）中页面是一种比较宽松的向后兼容的方式显示。</p><h3 id="常见的行内元素有哪些？块级元素有哪些？-空-void-元素有那些？">常见的行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><p>行内元素: a span img input select<br>块级元素: div h1 p ul ol li dl dt dd<br>空元素: <br> <hr> <link> <meta></p><h3 id="页面导入样式时-使用-link-和-import-有什么区别？">页面导入样式时, 使用 link 和@import 有什么区别？</h3><p>相同的地方, 都是外部引用 CSS 方式, 区别:</p><p>link 是 xhtml 标签, 除了加载 css 外, 还可以定义 RSS 等其他事务；@import 属于 CSS 范畴, 只能加载 CSS<br>link 引用 CSS 时候, 页面载入时同时加载；@import 需要在页面完全加载以后加载, 而且@import 被引用的 CSS 会等到引用它的 CSS 文件被加载完才加载<br>link 是 xhtml 标签, 无兼容问题；@import 是在 css2.1 提出来的, 低版本的浏览器不支持<br>link 支持使用 javascript 控制去改变样式, 而@import 不支持<br>link 方式的样式的权重高于@import 的权重<br>import 在 html 使用时候需要<code>&lt;style type=&quot;text/css&quot;&gt;</code>标签</p><h3 id="介绍一下你对浏览器内核的理解？">介绍一下你对浏览器内核的理解？</h3><p>主要分成两部分: 渲染引擎(Layout Engine 或 Rendering Engine)和 JS 引擎。</p><p>渲染引擎: 负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等）, 以及计算网页的显示方式, 然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同, 所以渲染的效果也不相同。<br>JS 引擎: 解析和执行 javascript 来实现网页的动态效果。</p><p>最开始渲染引擎和 JS 引擎并没有区分的很明确, 后来 JS 引擎越来越独立, 内核就倾向于只指渲染引擎。</p><h3 id="常见的浏览器内核有哪些？">常见的浏览器内核有哪些？</h3><p>Trident( MSHTML ): IE MaxThon TT The World 360 搜狗浏览器<br>Geckos: Netscape6 及以上版本 FireFox Mozilla Suite/SeaMonkey<br>Presto: Opera7 及以上(Opera 内核原为: Presto, 现为: Blink)<br>Webkit: Safari Chrome</p><h3 id="html5-有哪些新特性-移除了那些元素？如何处理-html5-新标签的浏览器兼容问题？如何区分-html-和-html5">HTML5 有哪些新特性,移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5</h3><p>新增加了图像、位置、存储、多任务等功能。</p><p>新增元素:</p><ul><li>canvas</li><li>用于媒介回放的 video 和 audio 元素</li><li>本地离线存储。localStorage 长期存储数据, 浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除</li><li>语意化更好的内容元素, 比如 article footer header nav section</li><li>位置 API: Geolocation</li><li>表单控件, calendar date time email url search</li><li>新的技术: web worker(web worker 是运行在后台的 JavaScript, 独立于其他脚本, 不会影响页面的性能。您可以继续做任何愿意做的事情: 点击、选取内容等等, 而此时 web worker 在后台运行)</li><li>web socket</li><li>拖放 API: drag、drop</li></ul><p>移除的元素:</p><ul><li>纯表现的元素: basefont big center font s strike tt u</li><li>性能较差元素: frame frameset noframes</li></ul><p>区分:</p><p>DOCTYPE 声明的方式是区分重要因素<br>根据新增加的结构、功能来区分</p><h3 id="对-html-语义化的理解？">对 HTML 语义化的理解？</h3><ul><li>去掉或丢失样式的时候能够让页面呈现出清晰的结构。</li><li>有利于 SEO 和搜索引擎建立良好沟通, 有助于爬虫抓取更多的信息, 爬虫依赖于标签来确定上下文和各个关键字的权重。</li><li>方便其它设备解析。</li><li>便于团队开发和维护, 语义化根据可读性。</li></ul><h3 id="cookies-sessionstorage-和-localstorage-的区别？">cookies, sessionStorage 和 localStorage 的区别？</h3><p>共同点: 都是保存在浏览器端, 且是同源的。</p><p>区别:</p><ul><li>cookies 是为了标识用户身份而存储在用户本地终端上的数据, 始终在同源 http 请求中携带, 即 cookies 在浏览器和服务器间来回传递, 而 sessionstorage 和 localstorage 不会自动把数据发给服务器, 仅在本地保存。</li><li>存储大小的限制不同。cookie 保存的数据很小, 不能超过 4k, 而 sessionstorage 和 localstorage 保存的数据大, 可达到 5M。</li><li>数据的有效期不同。cookie 在设置的 cookie 过期时间之前一直有效, 即使窗口或者浏览器关闭。sessionstorage 仅在浏览器窗口关闭之前有效。localstorage 始终有效, 窗口和浏览器关闭也一直保存, 用作长久数据保存。</li><li>作用域不同。cookie 在所有的同源窗口都是共享；sessionstorage 不在不同的浏览器共享, 即使同一页面；localstorage 在所有同源窗口都是共享</li></ul><h3 id="iframe-框架有那些优缺点？">iframe 框架有那些优缺点？</h3><p>优点:</p><ul><li>iframe 能够原封不动的把嵌入的网页展现出来。</li><li>如果有多个网页引用 iframe, 那么你只需要修改 iframe 的内容, 就可以实现调用的每一个页面内容的更改, 方便快捷。</li><li>网页如果为了统一风格, 头部和版本都是一样的, 就可以写成一个页面, 用 iframe 来嵌套, 可以增加代码的可重用。</li><li>如果遇到加载缓慢的第三方内容如图标和广告, 这些问题可以由 iframe 来解决。</li></ul><p>缺点:</p><ul><li>搜索引擎的爬虫程序无法解读这种页面</li><li>框架结构中出现各种滚动条</li><li>使用框架结构时, 保证设置正确的导航链接。</li><li>iframe 页面会增加服务器的 http 请求</li></ul><h3 id="html5-的-form-如何关闭自动完成功能？">HTML5 的 form 如何关闭自动完成功能？</h3><p>HTML 的输入框可以拥有自动完成的功能, 当你往输入框输入内容的时候, 浏览器会从你以前的同名输入框的历史记录中查找出类似的内容并列在输入框下面, 这样就不用全部输入进去了, 直接选择列表中的项目就可以了。但有时候我们希望关闭输入框的自动完成功能, 例如当用户输入内容的时候, 我们希望使用 AJAX 技术从数据库搜索并列举而不是在用户的历史记录中搜索。</p><p>方法:</p><ul><li>在 IE 的 internet 选项菜单中里的自动完成里面设置</li><li>设置 form 输入框的 autocomplete 为 on 或者 off 来来开启输入框的自动完成功能</li></ul><h3 id="如何实现浏览器内多个标签页之间的通信">如何实现浏览器内多个标签页之间的通信?</h3><ul><li>WebSocket SharedWorker</li><li>也可以调用 localstorge、cookies 等本地存储方式。 localstorge 在另一个浏览上下文里被添加、修改或删除时, 它都会触发一个事件, 我们通过监听事件, 控制它的值来进行页面信息通信。<br>注意: Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常</li></ul><h3 id="元素的-alt-和-title-有什么异同？">元素的 alt 和 title 有什么异同？</h3><p>在 alt 和 title 同时设置的时候, alt 作为图片的替代文字出现, title 是图片的解释文字。</p><h2 id="css-概念">CSS 概念</h2><h3 id="盒模型概念">盒模型概念</h3><p>盒模型分为标准盒模型与怪异盒模型( 也称为 IE 盒模型 )</p><p>标准盒模型下 width 和 height 为内容的宽高, 怪异盒模型下 width 和 height 为内容的宽高加上 border 的宽高, 再加上 padding 的宽高。</p><pre><code class="highlight css"><span class="selector-class">.box</span> &#123;  <span class="comment">/* Chrome 默认标准盒模型 */</span>  <span class="attribute">box-sizing</span>: <span class="string">"content-box"</span>; <span class="comment">/* 标准盒模型 */</span>&#125;<span class="selector-class">.box</span> &#123;  <span class="attribute">box-sizing</span>: <span class="string">"border-box"</span>; <span class="comment">/* 怪异盒模型 */</span>&#125;</code></pre><p>大部分的开源组件库, 例如 ant-design 都使用怪异盒模型, 不会造成布局破坏。</p><h3 id="常见的垂直水平居中方法">常见的垂直水平居中方法</h3><p>通过样式处理</p><pre><code class="highlight css"><span class="selector-class">.parent</span> &#123;  <span class="attribute">position</span>: relative;  <span class="attribute">width</span>: <span class="number">500px</span>;  <span class="attribute">height</span>: <span class="number">500px</span>;&#125;<span class="selector-class">.child</span> &#123;  <span class="attribute">width</span>: <span class="number">100px</span>;  <span class="attribute">height</span>: <span class="number">100px</span>;  <span class="attribute">background</span>: red;&#125;<span class="comment">/* 方法一, 子级知道宽高 */</span><span class="selector-class">.child</span> &#123;  <span class="attribute">position</span>: absolute;  <span class="attribute">width</span>: <span class="number">200px</span>;  <span class="attribute">height</span>: <span class="number">200px</span>;  <span class="attribute">top</span>: <span class="number">50%</span>;  <span class="attribute">left</span>: <span class="number">50%</span>;  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;  <span class="attribute">margin-top</span>: -<span class="number">100px</span>;  <span class="attribute">background</span>: red;&#125;<span class="comment">/* 方法二, 使用 margin: auto */</span><span class="selector-class">.child</span> &#123;  <span class="attribute">position</span>: absolute;  <span class="attribute">width</span>: <span class="number">200px</span>;  <span class="attribute">height</span>: <span class="number">200px</span>;  <span class="attribute">top</span>: <span class="number">0</span>;  <span class="attribute">left</span>: <span class="number">0</span>;  <span class="attribute">bottom</span>: <span class="number">0</span>;  <span class="attribute">right</span>: <span class="number">0</span>;  <span class="attribute">margin</span>: auto;  <span class="attribute">background</span>: red;&#125;<span class="comment">/* 方法三, 子级不知道宽高, 使用 transform  */</span><span class="selector-class">.child</span> &#123;  <span class="attribute">position</span>: absolute;  <span class="attribute">top</span>: <span class="number">50%</span>;  <span class="attribute">left</span>: <span class="number">50%</span>;  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);  <span class="attribute">background</span>: red;&#125;<span class="comment">/* 方法四, 使用 flex 布局 */</span><span class="selector-class">.parent</span> &#123;  <span class="attribute">position</span>: relative;  <span class="attribute">display</span>: flex;  <span class="attribute">justify-content</span>: center;  <span class="attribute">align-items</span>: center;  <span class="attribute">width</span>: <span class="number">500px</span>;  <span class="attribute">height</span>: <span class="number">500px</span>;&#125;<span class="comment">/* 方法六, 利用 table-cell 布局 */</span><span class="selector-class">.parent</span> &#123;  <span class="attribute">display</span>: table-cell;  <span class="attribute">vertical-align</span>: middle;  <span class="attribute">text-align</span>: center;&#125;</code></pre><p>通过 js 处理样式, 本质与 css 处理一致</p><pre><code class="highlight js"><span class="comment">// 方法五 js</span><span class="keyword">let</span> parentWidth = <span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>).clientWidth,  parentHeight = <span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>).clientHeight,  childWidth = <span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).clientWidth,  childHeight = <span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).clientHeight;<span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>).style.position = <span class="string">"relative"</span>;<span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).style.position = <span class="string">"absolute"</span>;<span class="built_in">console</span>.log((parentWidth - childWidth) / <span class="number">2</span>);<span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).style.left =  (parentWidth - childWidth) / <span class="number">2</span> + <span class="string">"px"</span>;<span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).style.top =  (parentHeight - childHeight) / <span class="number">2</span> + <span class="string">"px"</span>;</code></pre><h3 id="px-em-rem-概念">px, em, rem 概念</h3><ul><li><p>px 像素。绝对单位, 像素 px 是相对于显示器屏幕分辨率而言的, 是一个虚拟单位。是计算机系统的数字化图像长度单位, 如果 px 要换算成物理长度, 需要指定精度 DPI。</p></li><li><p>em 是相对长度单位, 相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置, 则相对浏览器的默认字体尺寸。它会继承父级元素的字体大小, 因此并不是一个固定的值。</p></li><li><p>rem 是 CSS3 新增的一个相对单位(root em,根 em),使用 rem 为元素设定字体大小事, 仍然是相对大小但相对的只是 HTML 根元素。</p><p>区别: IE 无法调用那些使用 px 作为单位的字体大小, 而 em 和 rem 可以缩放, rem 相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身, 通过它既可以做到只修改根元素就成比例地调整所有字体大小, 又可以避免字体大小逐层复合的连锁反应。目前, 除了 IE8 及更早版本外, 所有浏览器已支持 rem。</p></li></ul><h3 id="css3-新特性">CSS3 新特性</h3><ul><li>颜色: 新增 RGBA, HSLA 模式</li><li>文字阴影(text-shadow)</li><li>边框: 圆角（border-radius）边框阴影: box-shadow</li><li>盒子模型: box-sizing</li><li>背景: background-size 设置背景图片的尺寸, background-origin 设置背景图片的原点, background-clip 设置背景图片的裁剪区域, 以“, ”分隔可以设置多背景, 用于自适应布局</li><li>渐变: linear-gradient, radial-gradient</li><li>过渡: transition 可实现动画</li><li>自定义动画</li><li>在 CSS3 中唯一引入的伪元素是 <code>::selection</code></li><li>多媒体查询, 多栏布局</li><li>border-image</li><li>2D 转换: transform:translate(x,y)rotate(x,y)skew(x,y)scale(x,y)</li><li>3D 转换</li></ul><h3 id="display-none-与-visibility-hidden-的区别是什么">display:none; 与 visibility:hidden 的区别是什么?</h3><p><code>display:none;</code> 使用该属性后, HTML 元素（对象）的宽高, 高度等各种属性值都将“丢失”；<br><code>visibility:hidden;</code> 使用该属性后, HTML 元素（对象）仅仅是在视觉上看不见（完全透明）, 而它所占据的空间位置仍然存在, 也即是说它仍然具有高度, 宽度等属性值。</p><h3 id="css-选择符有哪些？优先级算法如何计算？内联和-important-哪个优先级高？">css 选择符有哪些？优先级算法如何计算？内联和 !important 哪个优先级高？</h3><p>css 选择符有: 类选择器、标签选择器、ID 选择器、后代选择器（派生选择器）、群组选择器<br>:link、:visited、:hover、:active 按照 LVHA（LoVe HAte）顺序定义</p><table><thead><tr><th>等级</th><th>标签内选择符</th><th>ID 选择符</th><th>Class 选择符/属性选择符/伪类选择符</th><th>元素选择符</th></tr></thead><tbody><tr><td>示例</td><td><code>&lt;span style=&quot;color:red;&quot;&gt;</code></td><td>#text{color:red;}</td><td>.text{color:red;} [type=“text”]{color:red}</td><td>span{color:red;}</td></tr><tr><td>标记位</td><td>x,0,0,0</td><td>0,x,0,0</td><td>0,0,x,0</td><td>0,0,0,x</td></tr></tbody></table><p>特点:</p><ul><li>每个等级的初始值为 0,</li><li>每个等级的叠加为选择器出现的次数相加</li><li>不可进位, 比如 0,99,99,99</li><li>依次表示为: 0,0,0,0</li><li>每个等级计数之间没关联</li><li>等级判断从左向右, 如果某一位数值相同, 则判断下一位数值</li><li>如果两个优先级相同, 则最后出现的优先级高, !important 也适用</li><li>通配符选择器的特殊性值为: 0,0,0,0</li><li>继承样式优先级最低, 通配符样式优先级高于继承样式</li></ul><p>!important 优先级最高。</p><h3 id="flex-布局概念">FLEX 布局概念</h3><p><img src="/img/blog_img/prototype.png" alt="prototype"></p><h4 id="flex-容器的属性">flex 容器的属性</h4><ul><li>flex-direction 属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap 定义如何换行</li><li>flex-flow 是 flex-direction flex-wrap 的缩写</li><li>justify-content 定义主轴的对齐方式</li><li>align-items 定义交叉轴上的对齐方式</li><li>align-content 定义多个轴的对齐方式</li></ul><h4 id="flex-item-的属性">flex item 的属性</h4><ul><li>order 定义项目的排序, 越小越靠前</li><li>flex-grow 定义 item 放大比例, 默认为 0</li><li>flex-shrink 定义 item 缩小比例, 默认为 1</li><li>flex-basis 定义了在分配多余空间之前, 项目占据的主轴空间（main size）。</li><li>flex 是 flex-grow, flex-shrink 和 flex-basis 的简写, 默认值为 0 1 auto。</li><li>align-self 允许单个项目有与其他项目不一样的对齐方式, 可覆盖 align-items 属性。</li></ul><h3 id="bfc">BFC</h3><p>BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域, 只有 Block-level box 参与, 它规定了内部的 Block-level Box 如何布局,</p><p>并且与这个区域外部毫不相干。</p><p>BFC 布局规则:</p><ul><li>内部的 Box 会在垂直方向, 一个接一个地放置。</li><li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li><li>每个元素的 margin box 的左边, 与包含块 border box 的左边相接触(对于从左往右的格式化, 否则相反)。即使存在浮动也是如此。</li><li>BFC 的区域不会与 float box 重叠。</li><li>BFC 就是页面上的一个隔离的独立容器, 容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 BFC 的高度时, 浮动元素也参与计算</li></ul><h3 id="css-鼠标禁用事件">css 鼠标禁用事件</h3><pre><code class="highlight css"><span class="selector-class">.div</span> &#123;  <span class="attribute">pointer-envets</span>: none;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;html-概念&quot;&gt;Html 概念&lt;/h2&gt;
&lt;h3 id=&quot;doctype-的作用&quot;&gt;DOCTYPE 的作用&lt;/h3&gt;
&lt;p&gt;告诉浏览器使用哪个版本的 HTML 规范来渲染文档。DOCTYPE 不存在或形式不正确会导致 HTML 文档以混杂模式呈现。&lt;br&gt;
标准
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="前端面试题" scheme="http://www.kavience.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>基于g6的流程图编辑器Demo</title>
    <link href="http://www.kavience.com/frontend/demo-of-flow-chart-editor-based-on-g6.html"/>
    <id>http://www.kavience.com/frontend/demo-of-flow-chart-editor-based-on-g6.html</id>
    <published>2020-10-14T06:01:46.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="✨-特点">✨ 特点</h2><ul><li>拖拽式更新工作流程图</li><li>数据与图双向转换</li></ul><h2 id="📦-原理">📦 原理</h2><h3 id="拖拽">拖拽</h3><p>基于 <code>react-dnd</code> 和 <code>react-dnd-html5-backend</code> 创建拖拽节点与背景画布。</p><h3 id="图">图</h3><p>基于 <code>g6</code> 创建可视化图，根据 api 提供的 <code>registerBehavior</code> 注册行为，监听鼠标事件，基于 g6 提供的 <code>ToolBar</code>, <code>Menu</code>, <code>Minimap</code>, <code>Grid</code> 等插件，提供更多功能。</p><h3 id="样式">样式</h3><p>基于 <code>antd</code> 提供的 UI 组件优化样式。</p><h2 id="💡-预览">💡 预览</h2><p>请查看 <a href="https://kavience.github.io/work-flow-editor" target="_blank" rel="noopener">在线 Demo </a></p><h2 id="🔨-说明">🔨 说明</h2><p>项目仅供学习和参考，或许不适合直接用于项目中，<a href="https://github.com/kavience/work-flow-editor" target="_blank" rel="noopener">项目地址</a>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;✨-特点&quot;&gt;✨ 特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;拖拽式更新工作流程图&lt;/li&gt;
&lt;li&gt;数据与图双向转换&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;📦-原理&quot;&gt;📦 原理&lt;/h2&gt;
&lt;h3 id=&quot;拖拽&quot;&gt;拖拽&lt;/h3&gt;
&lt;p&gt;基于 &lt;code&gt;react-dnd
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="g6" scheme="http://www.kavience.com/tags/g6/"/>
    
      <category term="流程图" scheme="http://www.kavience.com/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Js-彻底了解This的指向</title>
    <link href="http://www.kavience.com/frontend/js-thoroughly-understand-the-point-of-this.html"/>
    <id>http://www.kavience.com/frontend/js-thoroughly-understand-the-point-of-this.html</id>
    <published>2020-09-07T09:37:16.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因">起因</h2><p>对 js 的 this 指向问题还是会有点模糊，我决定下点功夫，写下这篇文章，彻底把 this 搞明白。</p><h2 id="什么是-this-？">什么是 this ？</h2><p>这也是我发出的第一个问题，究竟什么是 this ？在 js 中 this 代表的到底是什么？根据 <a href="https://www.w3schools.com/js/js_this.asp" target="_blank" rel="noopener">w3c</a> 的描述：</p><blockquote><p>The JavaScript this keyword refers to the object it belongs to.</p></blockquote><blockquote><p>在 js 中 this 关键字代表它所属对象的引用。</p></blockquote><p>再根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">MDN</a> 的描述，</p><blockquote><p>In the global execution context (outside of any function), this refers to the global object whether in strict mode or not.</p></blockquote><blockquote><p>this 表示当前执行上下文( global、function 或 eval )的一个属性，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值。</p></blockquote><p>由此可见 this 的指向是不确定的，是在运行时确定的，而且 this 在不同的情况下，其代表的含义也不一样。</p><p>下面我将通过本文，彻底分析 this 的所有形式。</p><blockquote><p>注：全局对象，在浏览器端代表 window 对象，在 nodejs 环境下代表 global 对象，以下不再区分，简称全局对象。</p></blockquote><h2 id="this-存在的情形">this 存在的情形</h2><p>首先要考虑 this 一般会出现在哪些情况呢？</p><ol><li>全局状态下</li><li>一般函数内</li><li>this 和对象转换</li><li>原型链中</li><li>与 DOM 相关</li></ol><p>其实 this 一般都是出现在函数内，所以在第六点单独称之为 「一般函数」，下面分别分析。</p><h3 id="全局状态下">全局状态下</h3><p>无论是否在严格模式下，在全局执行环境中(在任何函数体外部) this 都指向<code>全局对象</code>。如:</p><pre><code class="highlight js"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 全局对象</span></code></pre><h3 id="一般函数内">一般函数内</h3><p>在全局状态下、对象内、class 内等的函数，我称之为一般函数，也是使用最多的情况。</p><h4 id="函数在全局状态下">函数在全局状态下</h4><p><code>在普通函数内部，this 的值取决于函数被调用的方式。</code>在严格模式下，如果进入执行环境时没有设置 this 的值，this 会保持为 undefined，非严格模式下指向全局对象。</p><p><code>在箭头函数中，this 取决于函数被创建时的环境。</code>因此在全局情况下，无论是否为严格模式，this 指向都是全局对象。</p><p>请务必记住以上重点标记的两句话，在很多地方也都用到。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;<span class="meta">  "use strict"</span>;  <span class="built_in">console</span>.log(<span class="keyword">this</span>);&#125;<span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>);&#125;<span class="keyword">const</span> f4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>);&#125;;<span class="keyword">const</span> f5 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="meta">  "use strict"</span>;  <span class="built_in">console</span>.log(<span class="keyword">this</span>);&#125;;f2(); <span class="comment">// undefined</span>f3(); <span class="comment">// 全局对象</span>f4(); <span class="comment">// 全局对象</span>f5(); <span class="comment">// 全局对象</span></code></pre><h4 id="函数在对象内部">函数在对象内部</h4><pre><code class="highlight js"><span class="keyword">const</span> obj = &#123;  type: <span class="number">1</span>,  func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  &#125;,  func2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  &#125;,&#125;;obj.func1(); <span class="comment">// obj</span>obj.func2(); <span class="comment">// 全局对象</span><span class="comment">// 把 func1，func2 单独拿出来调用，在当前情况下等同于全局状态下的调用</span><span class="keyword">const</span> &#123; func1, func2 &#125; = obj;func1(); <span class="comment">// 全局对象</span>func2(); <span class="comment">// 全局对象</span></code></pre><p>在严格模式下再运行一遍</p><pre><code class="highlight js"><span class="meta">"use strict"</span>;<span class="keyword">const</span> obj = &#123;  type: <span class="number">1</span>,  func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  &#125;,  func2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  &#125;,&#125;;obj.func1(); <span class="comment">// obj</span>obj.func2(); <span class="comment">// 全局对象</span><span class="comment">// 把 func1，func2 单独拿出来调用，在当前情况下等同于全局状态下的调用</span><span class="keyword">const</span> &#123; func1, func2 &#125; = obj;func1(); <span class="comment">// undefined</span>func2(); <span class="comment">// 全局对象</span></code></pre><p>当作为对象的函数时，this 的绑定只受最接近的成员引用的影响。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">independent</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="keyword">this</span>.prop;&#125;<span class="keyword">const</span> independent2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="keyword">return</span> <span class="keyword">this</span>.prop;&#125;;<span class="keyword">var</span> obj = &#123;  prop: <span class="number">37</span>,  func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="keyword">this</span>.prop;  &#125;,  func2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="keyword">return</span> <span class="keyword">this</span>.prop;  &#125;,&#125;;obj.func3 = independent;obj.func4 = independent2;obj.child = &#123; <span class="attr">func5</span>: independent, <span class="attr">func6</span>: independent2, <span class="attr">prop</span>: <span class="number">42</span> &#125;;<span class="built_in">console</span>.log(obj.func1()); <span class="comment">// 37</span><span class="built_in">console</span>.log(obj.func2()); <span class="comment">// undefined</span><span class="built_in">console</span>.log(obj.func3()); <span class="comment">// 37</span><span class="built_in">console</span>.log(obj.func4()); <span class="comment">// undefined</span><span class="built_in">console</span>.log(obj.child.func5()); <span class="comment">// 42</span><span class="built_in">console</span>.log(obj.child.func6()); <span class="comment">// undefined</span></code></pre><h4 id="函数在-class-内">函数在 class 内</h4><p>this 在类中的表现与在函数中类似，因为类本质上也是函数，但也有一些区别和注意事项。在类的构造函数中，this 是一个常规对象。<code>类中所有非静态的方法都会被添加到 this 的原型中</code>。</p><p>和其他普通函数一样，类方法中的 this 值取决于它们如何被调用。需要注意的是类内部<code>总是严格模式</code>。类的方法内部如果含有 this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;  normalFunction() &#123;    <span class="built_in">console</span>.log(<span class="string">"normal function:"</span>, <span class="keyword">this</span>);  &#125;  arrowFunction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">"arrow function:"</span>, <span class="keyword">this</span>);  &#125;;&#125;<span class="keyword">const</span> t = <span class="keyword">new</span> TestClass();<span class="keyword">const</span> &#123; normalFunction, arrowFunction &#125; = t;normalFunction(); <span class="comment">// normal function: undefined</span>arrowFunction(); <span class="comment">// arrow function: TestClass &#123;arrowFunction: ƒ&#125;</span></code></pre><p>在上面代码中</p><pre><code class="highlight js"><span class="keyword">const</span> &#123; normalFunction, arrowFunction &#125; = t;</code></pre><p>其实相当于如下代码</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">normalFunction2</span>(<span class="params"></span>) </span>&#123;<span class="meta">  "use strict"</span>;  <span class="built_in">console</span>.log(<span class="string">"normal function:"</span>, <span class="keyword">this</span>);&#125;</code></pre><p>因为普通函数的 this 是由调用者确定的，如果在非严格模式下，直接调用，则 this 指向全局对象，如果是严格模式下，this 则为 undefined。而箭头函数是由创建时就确定了，所以 arrowFunction 实际指向的仍是 TestClass 实例。</p><p>有时，也可以通过 bind 方法使类中的 this 值总是指向这个类实例。为了做到这一点，可在构造函数中绑定类方法：</p><pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;  <span class="keyword">constructor</span>() &#123;    <span class="comment">// 注意 bind 和无 bind 的区别</span>    <span class="keyword">this</span>.sayBye = <span class="keyword">this</span>.sayBye.bind(<span class="keyword">this</span>);  &#125;  sayHi() &#123;    <span class="built_in">console</span>.log(<span class="string">`Hello from <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);  &#125;  sayBye() &#123;    <span class="built_in">console</span>.log(<span class="string">`Bye from <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);  &#125;  <span class="keyword">get</span> name() &#123;    <span class="keyword">return</span> <span class="string">"Ferrari"</span>;  &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;  <span class="keyword">get</span> name() &#123;    <span class="keyword">return</span> <span class="string">"Tweety"</span>;  &#125;&#125;<span class="keyword">const</span> car = <span class="keyword">new</span> Car();<span class="keyword">const</span> bird = <span class="keyword">new</span> Bird();<span class="comment">// class 中方法的调用取决于调用者</span>car.sayHi(); <span class="comment">// Hello from Ferrari</span>bird.sayHi = car.sayHi;bird.sayHi(); <span class="comment">// Hello from Tweety</span><span class="comment">// 对于已绑定的函数，this 就不在依赖调用者</span>bird.sayBye = car.sayBye;bird.sayBye(); <span class="comment">// Bye from Ferrari</span></code></pre><p>在派生类中的构造函数没有初始的 this 绑定。在构造函数中调用 <code>super()</code> 会生成一个 this 绑定。所以在子类的构造函数中，如果要使用 this 的话必须要调用 <code>super()</code> ，相当于 <code>this = new Base();</code>。派生类不能在调用 super() 之前返回，除非其构造函数返回的是一个对象，或者根本没有构造函数。</p><pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Good</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;<span class="class"><span class="keyword">class</span> <span class="title">AlsoGood</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;  <span class="keyword">constructor</span>() &#123;    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">5</span> &#125;;  &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Bad</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;  <span class="keyword">constructor</span>() &#123;&#125;&#125;<span class="keyword">new</span> Good();<span class="keyword">new</span> AlsoGood();<span class="keyword">new</span> Bad(); <span class="comment">// ReferenceError</span></code></pre><p>更多关于 class 的内容可以查看阮一峰老师<a href="https://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">关于 class 的说明</a></p><h4 id="改变-this-指向">改变 this 指向</h4><p>通过函数的 call, apply, bind 方法是可以改变 this 的指向的，例如：</p><pre><code class="highlight js"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="string">"Custom"</span> &#125;;<span class="keyword">var</span> a = <span class="string">"Global"</span>;<span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="keyword">this</span>.a;&#125;<span class="comment">// ECMAScript 5 引入了 Function.prototype.bind()。调用 f.bind(someObject)会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。</span><span class="keyword">const</span> func2 = func1.bind(obj);func1(obj);func1.call(obj);func1.apply(obj);func2(obj);<span class="comment">// 注意：如果将this传递给call、bind、或者apply来调用箭头函数，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数(thisArg)应该设置为null。</span></code></pre><h3 id="this-和对象转换">this 和对象转换</h3><p>在非严格模式下使用 call 和 apply 时，如果用作 this 的值不是对象，则会被尝试转换为对象。null 和 undefined 被转换为全局对象。原始值如 7 或 ‘foo’ 会使用相应构造函数转换为对象。因此 7 会被转换为 new Number(7) 生成的对象，字符串 ‘foo’ 会转换为 new String(‘foo’) 生成的对象。</p><pre><code class="highlight js"><span class="comment">// 非严格模式下</span><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 此处也属于函数内的 this ，下面会继续分析</span>  <span class="built_in">console</span>.log(<span class="keyword">this</span>);&#125;bar.call(<span class="number">7</span>); <span class="comment">// Number &#123;7&#125;</span>bar.call(<span class="string">"foo"</span>); <span class="comment">// String &#123;"foo"&#125;</span>bar.call(<span class="literal">undefined</span>); <span class="comment">// 全局对象</span></code></pre><pre><code class="highlight js"><span class="comment">// 严格模式下</span><span class="meta">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>);&#125;bar.call(<span class="number">7</span>); <span class="comment">// 7</span>bar.call(<span class="string">"foo"</span>); <span class="comment">// foo</span>bar.call(<span class="literal">undefined</span>); <span class="comment">// undefined</span></code></pre><p>ECMAScript 5 引入了 <code>Function.prototype.bind()</code> 。调用 f.bind(someObject)会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="keyword">this</span>.a;&#125;<span class="keyword">var</span> g = f.bind(&#123; <span class="attr">a</span>: <span class="string">"azerty"</span> &#125;);<span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span><span class="keyword">var</span> h = g.bind(&#123; <span class="attr">a</span>: <span class="string">"yoo"</span> &#125;); <span class="comment">// bind只生效一次！</span><span class="built_in">console</span>.log(h()); <span class="comment">// azerty</span><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">37</span>, <span class="attr">f</span>: f, <span class="attr">g</span>: g, <span class="attr">h</span>: h &#125;;<span class="built_in">console</span>.log(o.a, o.f(), o.g(), o.h()); <span class="comment">// 37, 37, azerty, azerty</span></code></pre><h3 id="原型链中">原型链中</h3><p>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样。</p><pre><code class="highlight js"><span class="comment">// 对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。虽然最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p 。也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p 。</span><span class="keyword">var</span> o = &#123;  f: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;  &#125;,&#125;;<span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);p.a = <span class="number">1</span>;p.b = <span class="number">4</span>;<span class="built_in">console</span>.log(p.f()); <span class="comment">// 5</span></code></pre><p>相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + <span class="keyword">this</span>.c;&#125;<span class="keyword">var</span> o = &#123;  a: <span class="number">1</span>,  b: <span class="number">2</span>,  c: <span class="number">3</span>,  <span class="keyword">get</span> average() &#123;    <span class="keyword">return</span> (<span class="keyword">this</span>.a + <span class="keyword">this</span>.b + <span class="keyword">this</span>.c) / <span class="number">3</span>;  &#125;,&#125;;<span class="built_in">Object</span>.defineProperty(o, <span class="string">"sum"</span>, &#123;  <span class="keyword">get</span>: sum,  enumerable: true,  configurable: true,&#125;);console.log(o.average, o.sum); // 2, 6</code></pre><h3 id="与-dom-相关">与 DOM 相关</h3><p>当函数被用作事件处理函数时，它的 this 指向触发事件的元素(一些浏览器在使用非 addEventListener 的函数动态地添加监听函数时不遵守这个约定)。</p><pre><code class="highlight js"><span class="comment">// 被调用时，将关联的元素变成蓝色</span><span class="function"><span class="keyword">function</span> <span class="title">bluify</span>(<span class="params">e</span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.currentTarget); <span class="comment">// 总是 true</span>  <span class="comment">// 当 currentTarget 和 target 是同一个对象时为 true</span>  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.target);  <span class="keyword">this</span>.style.backgroundColor = <span class="string">"#A5D9F3"</span>;&#125;<span class="comment">// 获取文档中的所有元素的列表</span><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);<span class="comment">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;  elements[i].addEventListener(<span class="string">"click"</span>, bluify, <span class="literal">false</span>);&#125;</code></pre><p>当代码被内联 on-event 处理函数 调用时，它的 this 指向监听器所在的 DOM 元素：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span>Show this<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="comment">&lt;!-- 在下面这种情况下，没有设置内部函数的 this，所以它指向 global/window 对象(即非严格模式下调用的函数未设置 this 时指向的默认对象)。 --&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span>Show inner this<span class="tag">&lt;/<span class="name">button</span>&gt;</span></code></pre><h2 id="最后">最后</h2><p>分析一道题</p><pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  prop = &#123;    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log(<span class="keyword">this</span>);    &#125;,    func2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;      <span class="built_in">console</span>.log(<span class="keyword">this</span>);    &#125;,  &#125;;&#125;<span class="keyword">const</span> t = <span class="keyword">new</span> Test();t.prop.func1(); <span class="comment">// object prop</span>t.prop.func2(); <span class="comment">// object t</span><span class="keyword">const</span> &#123; prop &#125; = t;prop.func1(); <span class="comment">// object prop</span>prop.func2(); <span class="comment">// t</span><span class="keyword">const</span> &#123; func1, func2 &#125; = prop;func1(); <span class="comment">// undefined</span>func2(); <span class="comment">// t</span></code></pre><p>答案已经公布，想想为什么呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;起因&lt;/h2&gt;
&lt;p&gt;对 js 的 this 指向问题还是会有点模糊，我决定下点功夫，写下这篇文章，彻底把 this 搞明白。&lt;/p&gt;
&lt;h2 id=&quot;什么是-this-？&quot;&gt;什么是 this ？&lt;/h2&gt;
&lt;p&gt;这也是我发出的第一个问题，究竟什么是 th
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://www.kavience.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>世界在发展，人类有进步吗</title>
    <link href="http://www.kavience.com/think/the-world-is-developing-mankind-progressing.html"/>
    <id>http://www.kavience.com/think/the-world-is-developing-mankind-progressing.html</id>
    <published>2020-08-27T03:30:36.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<p>本文是受阮一峰老师的博客 <a href="http://www.ruanyifeng.com/blog/2020/08/weekly-issue-121.html" target="_blank" rel="noopener">为什么人类没有越来越闲？</a> 启发，于是想独立的思考更多这个问题。</p><p>地球已经出现几十亿年，人类出现不过区区几百万年，而且真正开始在地球占领统治地位的时间则更短了。有时候我也时常在想，为什么我感觉现在人的生活并没有因为人类统治地位而更轻松？很明显，近现代一两百年的科技发展，将人类带上了一个新的台阶，我觉得这个变化不亚于人类第一次用火和人类第一次有国家、文明的概念。按理说，科技如此发展，人类不应该更加团结、和谐的发展吗？而现在这个世界却还存在战争、饥荒、种族歧视等等各种理应不出现在这个时代的东西。我想多思考思考。</p><p>「科学发展快而人类发展慢」，最主要的，我认为就是这个原因了。有点德不配位的感觉。人类普及了电、石油等基础的元素，于是飞速发展了火车、轮船、飞机、电脑等各种缩短时间、空间的工具。那人类的本质有因为这些工具而改变吗？有，但是微不足道。</p><p>因为这些工具，人类爆发了资源的掠夺战，爆发了有史以来最大的战争，发生了南京大屠杀、广岛与长崎原子弹等的人类悲剧。现阶段人类生活看似平稳，实际上也是非常脆弱的，中东现在还陷入战争泥沼，非洲饥荒灾难不断。</p><p>因为这些工具，资本主义更加横行霸道，富的更富，穷的更穷。才会发生如现在这样，资本主义光明正大的宣传 996 ，竟然称之为福报，底层人民的需求得不到关注，花几十年工作，才能在大城市买房，社会矛盾越来越凸显。</p><p>看似平稳的社会其实也是脆弱的很，一旦发生一些难以预测的灾难，例如传播性极强、致死率极高的疾病，难以想象的饥荒灾难等，世界一定会再陷入混乱，生灵涂炭未必不会再发生在地球，作为普通人，也只能默默祈祷了。如果真的发生这一切，感觉以目前人类的程度，是难以抵抗的。希望有招一日，人类真的能够大一统，抛开歧视，人人都能克服自己的虚荣、欲望，成为桃花源中的人，那个时候，人类就可以抵御大部分的灾难了。</p><p>长路漫漫，希望世界永远和平，🙏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是受阮一峰老师的博客 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2020/08/weekly-issue-121.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么人类没有越来越闲？&lt;/a&gt; 启发，于是
      
    
    </summary>
    
    
      <category term="think" scheme="http://www.kavience.com/categories/think/"/>
    
    
      <category term="人类" scheme="http://www.kavience.com/tags/%E4%BA%BA%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Jest单元测试</title>
    <link href="http://www.kavience.com/frontend/jest-unit-testing.html"/>
    <id>http://www.kavience.com/frontend/jest-unit-testing.html</id>
    <published>2020-08-25T03:19:51.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">What</h2><p>采用 Jest 对 react 项目进行单元测试。</p><h2 id="why">Why</h2><p>曾使用 Mocha 对项目进行过单元测试，但是 Mocha 需要配合一系列工具包( sinon, enzyme, chai, nyc )等，加上 Mocha 对 typescript 支持不是特别友好。所以打算采用 Jest 进行单元测试，目前的测试工具 Mocha、Jest、Ava 区别大致如下：</p><table><thead><tr><th>框架</th><th>断言</th><th>异步</th><th>Mock</th><th>代码覆盖率</th></tr></thead><tbody><tr><td>Mocha</td><td>不支持（Chai/power-asset）</td><td>友好</td><td>不支持（Sinon）</td><td>不支持（Istanbul）</td></tr><tr><td>Jest</td><td>默认支持</td><td>友好</td><td>默认支持</td><td>支持</td></tr><tr><td>Ava</td><td>默认支持</td><td>友好</td><td>不支持（Sinon)</td><td>不支持（Istanbul)</td></tr></tbody></table><h2 id="how">How</h2><h3 id="配置包与命令">配置包与命令</h3><p>安装所需依赖(采用的 typescript )</p><pre><code class="highlight bash">yarn add -D jest babel-jest jest-transform-stub ts-jest enzyme-to-json enzyme enzyme-adapter-react-16</code></pre><p>配置命令</p><pre><code class="highlight js">...<span class="string">"scripts"</span>: &#123;    <span class="string">"test"</span>: <span class="string">"cross-env jest"</span>,    <span class="string">"test:with-coverage"</span>: <span class="string">"cross-env TEST_COVERAGE=true jest"</span>  &#125;,...</code></pre><h3 id="配置-jest">配置 Jest</h3><p>根目录下编辑 jest.config.js</p><pre><code class="highlight js"><span class="built_in">module</span>.exports = &#123;  preset: <span class="string">"ts-jest"</span>, <span class="comment">// 采用 ts 测试</span>  setupFiles: [<span class="string">"./jest.setup.js"</span>],  transform: &#123;    <span class="string">"^.+\\.[tj]s?$"</span>: <span class="string">"babel-jest"</span>,    <span class="string">"^.+\\.[tj]sx?$"</span>: <span class="string">"babel-jest"</span>,    <span class="string">"^.+\\.(css|styl|less|sass|scss|png|jpg|ttf|woff|woff2|svg)$"</span>:      <span class="string">"jest-transform-stub"</span>,  &#125;,  moduleNameMapper: &#123;    <span class="string">"^@/(.*)$"</span>: <span class="string">"&lt;rootDir&gt;/src/$1"</span>, <span class="comment">// 用 @ 映射当前 src 下的路径</span>    <span class="string">"^.+.(css|styl|less|sass|scss|png|jpg|ttf|woff|woff2|svg)$"</span>:      <span class="string">"jest-transform-stub"</span>, <span class="comment">// stub 掉 css|styl|less|sass|scss|png|jpg|ttf|woff|woff2|svg 的测试</span>    <span class="string">"\\.worker.entry.js"</span>: <span class="string">"&lt;rootDir&gt;/__mocks__/workerMock.js"</span>,  &#125;,  globals: &#123;    <span class="string">"ts-jest"</span>: &#123;      tsConfig: <span class="string">"./tsconfig.test.json"</span>, <span class="comment">// 指定 ts 测试配置文件</span>    &#125;,  &#125;,  collectCoverage: process.env.TEST_COVERAGE ? <span class="literal">true</span> : <span class="literal">false</span>, <span class="comment">// 是否需要查看测试覆盖率</span>  collectCoverageFrom: [<span class="string">"&lt;rootDir&gt;/src/**/*.&#123;ts,tsx&#125;"</span>, <span class="string">"!**/node_modules/**"</span>],  testPathIgnorePatterns: [<span class="string">"&lt;rootDir&gt;/dist/"</span>, <span class="string">"&lt;rootDir&gt;/node_modules/"</span>],  snapshotSerializers: [<span class="string">"enzyme-to-json/serializer"</span>],  transformIgnorePatterns: [<span class="string">"&lt;rootDir&gt;/dist/"</span>, <span class="string">"&lt;rootDir&gt;/node_modules/"</span>],  testURL: <span class="string">"http://localhost"</span>,  clearMocks: <span class="literal">true</span>,&#125;;</code></pre><p>根目录下编辑 jest.setup.js</p><pre><code class="highlight js"><span class="comment">// 该文件是运行单元测试前会执行一遍，可以 mock 掉一些报错的东西</span><span class="keyword">const</span> React = <span class="built_in">require</span>(<span class="string">"react"</span>);<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) &#123;  global.window.resizeTo = <span class="function">(<span class="params">width, height</span>) =&gt;</span> &#123;    global.window.innerWidth = width || global.window.innerWidth;    global.window.innerHeight = height || global.window.innerHeight;    global.window.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">"resize"</span>));  &#125;;  global.window.scrollTo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;  <span class="keyword">if</span> (!<span class="built_in">window</span>.matchMedia) &#123;    <span class="built_in">Object</span>.defineProperty(global.window, <span class="string">"matchMedia"</span>, &#123;      value: jest.fn(<span class="function">(<span class="params">query</span>) =&gt;</span> (&#123;        matches: query.includes(<span class="string">"max-width"</span>),        addListener: jest.fn(),        removeListener: jest.fn(),      &#125;)),    &#125;);  &#125;  <span class="keyword">const</span> mockResponse = jest.fn();  <span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"location"</span>, &#123;    value: &#123;      hash: &#123;        endsWith: mockResponse,        includes: mockResponse,      &#125;,      assign: mockResponse,    &#125;,    writable: <span class="literal">true</span>,  &#125;);&#125;<span class="keyword">const</span> Enzyme = <span class="built_in">require</span>(<span class="string">"enzyme"</span>);<span class="keyword">const</span> Adapter = <span class="built_in">require</span>(<span class="string">"enzyme-adapter-react-16"</span>);Enzyme.configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter() &#125;);<span class="built_in">Object</span>.assign(Enzyme.ReactWrapper.prototype, &#123;  findObserver() &#123;    <span class="keyword">return</span> <span class="keyword">this</span>.find(<span class="string">"ResizeObserver"</span>);  &#125;,  triggerResize() &#123;    <span class="keyword">const</span> ob = <span class="keyword">this</span>.findObserver();    ob.instance().onResize([&#123; <span class="attr">target</span>: ob.getDOMNode() &#125;]);  &#125;,&#125;);<span class="built_in">console</span>.log(<span class="string">"Current React Version:"</span>, React.version);</code></pre><p>至此 Jest 项目搭建就已经完成了, 比 Mocha 简单些。</p><h3 id="jest-使用">Jest 使用</h3><p>编写测试文件</p><pre><code class="highlight ts"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;<span class="keyword">import</span> &#123; App <span class="keyword">as</span> TargetComponent &#125; <span class="keyword">from</span> <span class="string">"../App"</span>;<span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">"enzyme"</span>;describe(<span class="string">"src &gt; APP"</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="keyword">const</span> defaultProps = &#123;    updateTabs: jest.fn(), <span class="comment">// 模拟 updateTabs 函数</span>    user: &#123;&#125;,  &#125;;  <span class="comment">// shallow 浅拷贝模拟 react 组件</span>  <span class="keyword">const</span> render = <span class="function">(<span class="params">props: &#123;&#125; = &#123;&#125;</span>) =&gt;</span>    shallow(&lt;TargetComponent &#123;...defaultProps&#125; &#123;...props&#125; /&gt;);  <span class="comment">// describe 一个方法</span>  describe(<span class="string">"componentDidMount"</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="comment">// 判断行为</span>    it(<span class="string">"should direct return if no tab"</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;      <span class="comment">// 实例化组件</span>      <span class="keyword">const</span> component = render(&#123;        user: &#123;          permissionsMapping: &#123;            <span class="string">"/"</span>: <span class="literal">null</span>,          &#125;,        &#125;,      &#125;);      <span class="comment">// 执行方法</span>      <span class="keyword">const</span> result = component.instance().componentDidMount();      <span class="comment">// 执行断言</span>      expect(component.instance().props.updateTabs).toBeCalledWith(<span class="string">"test"</span>);      expect(result).toBeUndefined();    &#125;);  &#125;);&#125;);</code></pre><p>执行单元测试</p><pre><code class="highlight bash">yarn <span class="built_in">test</span></code></pre><p>或者执行单个测试文件</p><pre><code class="highlight bash"><span class="comment"># 采用 describe.only 方法不行，略坑</span>node_modules/.bin/jest src/components/BaseList/__test__/index.test.tsx</code></pre><p>查看覆盖率</p><pre><code class="highlight bash">yarn <span class="built_in">test</span>:with-coverage</code></pre><p>在跟目录下 coverage 下会生成 html 文件，在浏览器打开查看覆盖率即可，可以在 Jest 配置中配置测试率要求，具体可以查看官网文档。</p><h2 id="总结">总结</h2><p>个人感觉 Jest 比 Mocha 配置简单些，易上手，Mocha 需要配合 sinon 进行 stub，配合 Chai 断言效果才会更好，在使用上 Jest 和 Mocha 并无太大区别。</p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;What&lt;/h2&gt;
&lt;p&gt;采用 Jest 对 react 项目进行单元测试。&lt;/p&gt;
&lt;h2 id=&quot;why&quot;&gt;Why&lt;/h2&gt;
&lt;p&gt;曾使用 Mocha 对项目进行过单元测试，但是 Mocha 需要配合一系列工具包( sinon, enzyme, c
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://www.kavience.com/tags/JavaScript/"/>
    
      <category term="jest" scheme="http://www.kavience.com/tags/jest/"/>
    
  </entry>
  
  <entry>
    <title>一道有趣的JavaScript题</title>
    <link href="http://www.kavience.com/frontend/an-interesting-javascript-question.html"/>
    <id>http://www.kavience.com/frontend/an-interesting-javascript-question.html</id>
    <published>2020-08-10T04:03:47.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>如下为一段代码, 请完善 sum 函数, 使得 sum(1, 2, 3, 4, 5, 6) 函数返回值为 21 , 需要在 sum 函数中调用 asyncAdd 函数, 且不能修改 asyncAdd 函数:</p><pre><code class="highlight js"><span class="comment">/**</span><span class="comment"> * 请在 sum函数中调用此函数, 完成数值计算</span><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>a 要相加的第一个值</span><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>b 要相加的第二个值</span><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>callback 相加之后的回调函数</span><span class="comment"> */</span><span class="function"><span class="keyword">function</span> <span class="title">asyncAdd</span>(<span class="params">a, b, callback</span>) </span>&#123;  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    callback(<span class="literal">null</span>, a + b);  &#125;, <span class="number">100</span>);&#125;<span class="comment">/**</span><span class="comment"> * 请在此方法中调用asyncAdd方法, 完成数值计算</span><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;...any&#125;</span> </span>rest 传入的参数</span><span class="comment"> */</span><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>) </span>&#123;  <span class="comment">// 请在此处完善代码</span>&#125;<span class="keyword">let</span> start = <span class="built_in">window</span>.performance.now();sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;  <span class="comment">// 请保证在调用sum方法之后, 返回结果21</span>  <span class="built_in">console</span>.log(res);  <span class="built_in">console</span>.log(<span class="string">`程序执行共耗时: <span class="subst">$&#123;<span class="built_in">window</span>.performance.now() - start&#125;</span>`</span>);&#125;);</code></pre><h2 id="自己的解决方法">自己的解决方法</h2><p>题目是在掘金上看到的, 立马开始动手做题, 第一时间想到的就是使用剩余参数, 然后配合 promise 做递归, 下面是我的实现方式:</p><pre><code class="highlight js"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>) </span>&#123;  <span class="keyword">const</span> [a = <span class="number">0</span>, b = <span class="number">0</span>, ...others] = rest;  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;    asyncAdd(a, b, <span class="function"><span class="keyword">function</span> (<span class="params">arg1, callBackResult</span>) </span>&#123;      <span class="keyword">if</span> (others.length !== <span class="number">0</span>) &#123;        sum(callBackResult, ...others).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;          resolve(res);        &#125;);      &#125; <span class="keyword">else</span> &#123;        resolve(callBackResult);      &#125;    &#125;);  &#125;);&#125;</code></pre><p>思路很简单, 在 sum 函数中, 返回一个 promise , 如果剩余参数的长度为 0 , 则直接 resolve asyncAdd 函数执行的回调的结果, 否则递归调用 sum, 把结果作为第一个 sum 的第一个参数, 剩余参数直接展开, 然后在递归调用的回调中, 再 resolve 结果, 最终达到题目要求。</p><h2 id="标准答案">标准答案</h2><p>比较满意的看了看自己的代码, 觉得不错, 然后看了一下标准答案, 发现, 自己的代码执行速度还是太慢, 看一下别人的实现：</p><pre><code class="highlight js"><span class="comment">// 方法一, 和我的差不多, 但是比我的更简洁。。。</span><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sum1</span>(<span class="params">...rest</span>) </span>&#123;  <span class="keyword">let</span> result = rest.shift();  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> rest) &#123;    result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;      asyncAdd(result, num, (_, res) =&gt; &#123;        resolve(res);      &#125;);    &#125;);  &#125;  <span class="keyword">return</span> result;&#125;<span class="comment">// 方法二, 重点在于把参数两两分开, 使用 Promise.all 一次执行多个 promise</span><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">...rest</span>) </span>&#123;  <span class="keyword">if</span> (rest.length &lt;= <span class="number">1</span>) &#123;    <span class="keyword">return</span> rest[<span class="number">0</span>] || <span class="number">0</span>;  &#125;  <span class="keyword">const</span> promises = [];  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rest.length; i += <span class="number">2</span>) &#123;    promises.push(      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;        <span class="keyword">if</span> (rest[i + <span class="number">1</span>] === <span class="literal">undefined</span>) &#123;          resolve(rest[i]);        &#125; <span class="keyword">else</span> &#123;          asyncAdd(rest[i], rest[i + <span class="number">1</span>], (_, result) =&gt; &#123;            resolve(result);          &#125;);        &#125;      &#125;)    );  &#125;  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);  <span class="keyword">return</span> <span class="keyword">await</span> sum(...result);&#125;<span class="comment">// 方法三, 隐氏类型转换 和 promise.all 结合使用</span><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>) </span>&#123;  <span class="keyword">let</span> result = <span class="number">0</span>;  <span class="comment">// 隐氏类型转换, 对象 + 数字, 会先调用对象的toString 方法</span>  <span class="keyword">const</span> obj = &#123;&#125;;  obj.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> result;  &#125;;  <span class="keyword">const</span> promises = [];  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> rest) &#123;    promises.push(      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;        asyncAdd(obj, num, (_, res) =&gt; &#123;          resolve(res);        &#125;);      &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;        <span class="comment">// 把回调的结果直接给 result, obj下次计算的时候, 会自动调用 toString 方法拿到最新的 result</span>        result = res;      &#125;)    );  &#125;  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);  <span class="keyword">return</span> result;&#125;</code></pre><p>以上几种结果, 方法三是最快的, 本想给我的方法也做做优化, 发现我的方法确实没办法优化, 因为我是直接在 sum 里面返回 promise , 没有办法使用 promise.all 。 究其原因, 是因为我第一时间就想到用递归, 而不是 for 循环, 我发现在敲代码的过程中, 类似循环的问题, 能用递归的地方, 我第一想到的方案都是采用递归, 很少很少采用 for 循环去做某件事, 这是为什么呢？看来以后还是得转变一下思路, 递归的效率有的时候不一定是最高的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;如下为一段代码, 请完善 sum 函数, 使得 sum(1, 2, 3, 4, 5, 6) 函数返回值为 21 , 需要在 sum 函数中调用 asyncAdd 函数, 且不能修改 asyncAdd 函数:&lt;/p&gt;
&lt;pre&gt;&lt;cod
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://www.kavience.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>生命的脆弱</title>
    <link href="http://www.kavience.com/think/fragility-of-life.html"/>
    <id>http://www.kavience.com/think/fragility-of-life.html</id>
    <published>2020-08-08T05:37:57.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>树叶的一生，只是为了归根吗？ – 亚索</p></blockquote><h2 id="对生命的疑问">对生命的疑问</h2><p>每当想起人生的意义的时候，我总是会想起 LOL 中亚索的这句话「树叶的一生，只是为了归根吗？」。我觉得他说的这句话，似乎适合让任何一个失落的人发出这样的呐喊，同时也会产生共鸣，人的一生，其实不也像一片树叶吗？</p><p>树叶源自于树枝，春天发芽，夏天茂盛，秋天落叶，冬天归根。而大多数人，少年时在家乡出生和长大，年轻时外出学习和工作，中年时成家立业，准备退休，年老时解甲归田。人生代代如此，反复循环，那人生究竟有何意义？</p><h2 id="对人生的探究">对人生的探究</h2><p>有人希望大富大贵，有人希望平平淡淡一生，有人希望走遍世界。为什么大家会有这么多不同的想法？我其实一直认为人类，是一种特殊的动物，动物有的行为，人类基本都有。但唯独，好奇与恐惧是人类特有的。七情六欲，动物应该也有这样的行为，但是好奇心和恐惧心里远远不如人类。为什么有人喜欢大富大贵？他好奇那种拥有花不完的钱的感觉。为什么喜欢拥有强大的权力？他好奇那种强大权力的感觉。为什么想环游世界？他好奇那种走遍世界的感觉。为什么有人希望平平淡淡一生？因为恐惧接受一些事物。为什么你能在电影中看到有些人为了活下去，做出各种匪夷所思的事情？因为恐惧死亡。</p><p>基本上，人类的行为大部分在动物身上也发生过，但唯独好奇与恐惧就像是人类特有的。好奇使人类进化的更聪明，恐惧使人类更加珍惜生命。如果生活中凡事发生了一些难以理解的事情，你只要把这件事当做发生在动物身上，基本就能说的通了。还真是有点细思极恐。</p><h2 id="感叹">感叹</h2><p>年少时，我一直以为这个世界有鬼怪和神仙存在，我以为只有他们是永远存在的。恐怕，世界上，没有什么生命是永远存在的，人的一生短短几十年，其实脆弱的很。</p><p>为什么我今天会写这么沉重的话题？一方面是因为我很早就自己想过这件事，另一方面是因为前两天去医院检查了一下腰，发现自己腰椎峡部断裂和腰椎滑脱。我相信大部分人，都应该把自己的生命看的非常非常重要，在没有大灾大难的时候，可能总觉得自己能活非常久，其实是我们大意了，生命发生意外的时候，很有可能招呼都不会和你打。我很早前做过一个手术，那种恐惧感可能这辈子都不会忘记，所以当医生说我的腰很严重的时候，我的心里有那么一瞬间非常失落，感觉就像是给我判了死刑一样。其实这还只是中等情况，不至于说威胁生命安全，但是如果真的有一天，人被宣告得了不治之症，有多少人能承受得住这个打击呢？</p><p>我们总觉得发生在别人身上的，很难在自己身上重复，离自己太遥远，其实这就发生在身边。愿所有人，能早点意识到生命的脆弱，或许很多不必要发生的事情，就会少很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;树叶的一生，只是为了归根吗？ – 亚索&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;对生命的疑问&quot;&gt;对生命的疑问&lt;/h2&gt;
&lt;p&gt;每当想起人生的意义的时候，我总是会想起 LOL 中亚索的这句话「树叶的一生，只是为了归根吗？」。我觉得他说的这
      
    
    </summary>
    
    
      <category term="think" scheme="http://www.kavience.com/categories/think/"/>
    
    
      <category term="生命" scheme="http://www.kavience.com/tags/%E7%94%9F%E5%91%BD/"/>
    
  </entry>
  
  <entry>
    <title>Web前端优化总结</title>
    <link href="http://www.kavience.com/frontend/summary-of-web-frontend-optimization.html"/>
    <id>http://www.kavience.com/frontend/summary-of-web-frontend-optimization.html</id>
    <published>2020-08-04T02:04:24.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">What</h2><p>针对 web 前端优化方案的总结, 主要技术栈为 React。</p><h2 id="why">Why</h2><p>与以往 PHP, JSP 等服务端渲染不同, 现如今大多数 web 端采用 React, Vue, Angular 等客户端渲染方案。单页应用带来的好处是显而易见的, 前端开发人员可以专注于前端页面的交互, 后端人员专注于数据的处理, 分工明确。另一方面得益于 nodejs 的生态, 例如 npm 包管理, webpack, gulp 打包等, 前端开发人员可以避免重复造轮子, 开发也变得越来越迅速。然而单页应用也带来另一个问题, 随着引入的库越来越多, 项目也越来越臃肿, 页面加载速度奇慢无比, 本文主要讨论针对 webpack 手动搭建的 React 项目为例做优化。</p><h2 id="how">How</h2><p>首先简单罗列一下 web 开发中可以优化的点有哪些:</p><ul><li>引入 CDN 资源, 图片、视频等大文件资源也可以通过 oss 等其它方式引入;</li><li>图片、icon 等使用 SVG;</li><li>样式优化( style-loader, mini css );</li><li>代码优化(减少 re-render 次数);</li><li>文件开启 GZip 压缩( Nodejs, Nginx );</li><li>代码拆分( webpack DllPlugin, webpack splitChunks, React.lazy );</li><li>客户端缓存( Cache-Control )。</li></ul><p>下面依次讲解。</p><h3 id="cdn-资源引入">CDN 资源引入</h3><p>这是最简单粗暴的, 打包后的资源文件, 如果不做任何优化, 大部分项目中压缩后的 vender.xxx.js 文件, 大概会有 5-8 M,在国内采用 CDN 加载, 时间大概 1 - 2 s 左右, 在次基础上, 还可以进行 GZip 压缩, 以 <a href="https://help.aliyun.com/knowledge_detail/39645.html" target="_blank" rel="noopener">阿里 oss</a> 为例子, 采用 GZip 压缩后的资源, 大小会差不多减少三分之二, 访问时间会在 1 秒左右, 如果对项目访问速度要求不高, 这完全足够了。</p><p>另外, 例如图片、视频、音频等大文件, 肯定是要采用 CDN 的, 可能还要引入流的概念, 这里就不累述了(关键我也不熟悉)。</p><h3 id="图片-icon-等使用-svg">图片、icon 等使用 SVG</h3><p>SVG 的优势(来源谷歌):</p><ul><li>SVG 图像可通过文本编辑器来创建和修改；</li><li>SVG 图像可被搜索、索引、脚本化或压缩；</li><li>SVG 是可伸缩的；</li><li>SVG 图像可在任何的分辨率下被高质量地打印；</li><li>SVG 可在图像质量不下降的情况下被放大；</li></ul><p>另外还有些个人认为的优势, SVG 可以做动画, 可以嵌入 HTML 文件, 减少 HTTP 请求。</p><h3 id="样式优化-style-loader-mini-css">样式优化( style-loader, mini css )</h3><p>针对样式, 大部分项目中会使用 less,sass 或者 stylus, 通过 <code>less-loader</code>, <code>sass-loader</code> 等各种 loader, 最后基本有两种方案, 一是通过 <code>css-loader</code> 和 <code>style-loader</code> 把生成后的样式嵌入 HTML, 作为 style 标签引入, 另一种是通过 <code>css-loader</code> 和 <code>miniCssExtractPlugin</code> 生成压缩后的 css 引入。两种方式我觉得都没什么问题, 差不多, 但我更喜欢后者。嵌入到 HTML 可以减少 HTTP 请求, 但是压缩后的样式再经过 GZip 压缩其实也就几十毫秒左右。</p><h3 id="代码优化-减少-re-render-次数">代码优化(减少 re-render 次数)</h3><p>代码优化根据项目采用的框架不同, 优化方案也不同, 但万变不离其宗, 主要是减少重渲染次数。</p><p>以 React 为例, 减少 <code>componentWillReceiveProps</code> , 使用 hooks 等, 注意 state 的值, 注意什么时候该用 props, 什么时候该用 state。props 和 state 的改变都会引起 re-render , 我的总结就是: 「 在组件中, 这个值会经常改变, 再<code>考虑</code>把这个值设为 state 。」 其实也不一定准确, 还是得看具体情况, 比如, <code>editable</code>, <code>visible</code> 等这类表示某些状态的, 大多数时候都作为 state, 但也有例外, 比如 <code>loading</code>, 业务不一样, 可能在会引入 <code>redux</code> 全局状态, 在发生 HTTP 请求的时候, 设置 <code>loading</code> 为 true, 组件可以从全局去拿这个状态值。</p><h3 id="文件开启-gzip-压缩-nodejs-nginx-等">文件开启 GZip 压缩( Nodejs, Nginx 等 )</h3><p>GZip 在上述方案中多次提到, 如果你不想使用 CDN, 就想部署在自己的服务器中, 开启 GZip 根据不同的 web 容器, 设置的方式也不一样, 但总体思路差不多。</p><p>先说 nodejs , 基于 nodejs 的 <a href="https://nodejs.org/docs/latest-v12.x/api/zlib.html#zlib_class_zlib_gzip" target="_blank" rel="noopener">GZip</a> , 根据不同的 nodejs 框架有不同的使用方案, 我使用的是 koa, 引入的是 <code>koa-compress</code>, 使用方式如下:</p><pre><code class="highlight js">...<span class="keyword">const</span> compress = <span class="built_in">require</span>(<span class="string">"koa-compress"</span>);<span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);<span class="keyword">const</span> server = <span class="keyword">new</span> Koa();server.use(  compress(&#123;    threshold: <span class="number">1024</span>,    gzip: &#123;      flush: <span class="built_in">require</span>(<span class="string">"zlib"</span>).Z_SYNC_FLUSH,    &#125;,    deflate: &#123;      flush: <span class="built_in">require</span>(<span class="string">"zlib"</span>).Z_SYNC_FLUSH,    &#125;,    br: <span class="literal">false</span>,  &#125;));...</code></pre><p>Nginx, Apache 等 web 容器, 编辑 conf 文件即可, 以 Nginx 为例:</p><pre><code class="highlight bash">...<span class="comment"># 开启gzip</span>gzip on;<span class="comment"># 启用gzip压缩的最小文件, 小于设置值的文件将不会压缩</span>gzip_min_length 1k;<span class="comment"># gzip 压缩级别, 1-9, 数字越大压缩的越好, 也越占用CPU时间, 后面会有详细说明</span>gzip_comp_level 1;<span class="comment"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span>gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;<span class="comment"># 是否在http header中添加Vary: Accept-Encoding, 建议开启</span>gzip_vary on;<span class="comment"># 禁用IE 6 gzip</span>gzip_disable <span class="string">"MSIE [1-6]\."</span>;<span class="comment"># 设置压缩所需要的缓冲区大小</span>gzip_buffers 32 4k;<span class="comment"># 设置gzip压缩针对的HTTP协议版本, 没做负载的可以不用</span><span class="comment"># gzip_http_version 1.0;</span>...</code></pre><p>Apache 类似。</p><h3 id="代码拆分-webpack-dllplugin-webpack-splitchunks-react-lazy">代码拆分( webpack DllPlugin, webpack splitChunks, React.lazy )</h3><h4 id="webpack-dllplugin">webpack DllPlugin</h4><p>使用 <code>webpack.DllPlugin</code> , 可以把常用的且基本不变的库, 单独拆分出去, 且仅需 build 一次, 可以提升打包的速度。</p><pre><code class="highlight js"><span class="comment">// webpack.dll.config.js</span><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);<span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);<span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">"copy-webpack-plugin"</span>);<span class="built_in">module</span>.exports = &#123;  entry: &#123;    react: [<span class="string">"react"</span>, <span class="string">"react-dom"</span>],  &#125;,  mode: <span class="string">"production"</span>,  output: &#123;    filename: <span class="string">"[name].dll.[hash:6].js"</span>,    path: path.resolve(__dirname, <span class="string">"dist"</span>, <span class="string">"dll"</span>),    library: <span class="string">"[name]_dll"</span>,  &#125;,  plugins: [    <span class="keyword">new</span> webpack.DllPlugin(&#123;      name: <span class="string">"[name]_dll"</span>,      path: path.resolve(__dirname, <span class="string">"dist"</span>, <span class="string">"dll"</span>, <span class="string">"manifest.json"</span>),    &#125;),  ],&#125;;</code></pre><p>在项目中使用:</p><pre><code class="highlight js"><span class="comment">// webpack.config.js</span>...<span class="keyword">new</span> webpack.DllReferencePlugin(&#123;      manifest: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'dll'</span>, <span class="string">'manifest.json'</span>),    &#125;),<span class="keyword">new</span> CleanWebpackPlugin(&#123;    cleanOnceBeforeBuildPatterns: [<span class="string">'**/*'</span>, <span class="string">'!dll'</span>, <span class="string">'!dll/**'</span>, <span class="string">'!pdfjs'</span>, <span class="string">'!pdfjs/**'</span>],&#125;),...</code></pre><blockquote><p>第一次使用 webpack.dll.config.js 文件会对第三方库打包, 打包完成后就不会再打包它了, 然后每次运行 webpack.config.js 文件的时候, 都会打包项目中本身的文件代码, 当需要使用第三方依赖的时候, 会使用 DllReferencePlugin 插件去读取第三方依赖库。所以说它的打包速度会得到一个很大的提升。</p></blockquote><h4 id="webpack-splitchunks">webpack splitChunks</h4><p>通过 splitChunks, 会把这些库再单独拆分出去</p><pre><code class="highlight js"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">"webpack-merge"</span>);<span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">"./webpack.config.js"</span>);<span class="keyword">const</span> opimizeCss = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>);<span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">"terser-webpack-plugin"</span>);<span class="comment">// 打包后文件大小分析</span><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">"webpack-bundle-analyzer"</span>)  .BundleAnalyzerPlugin;<span class="built_in">module</span>.exports = merge(baseConfig, &#123;  mode: <span class="string">"production"</span>,  optimization: &#123;    runtimeChunk: &#123;      name: <span class="string">"manifest"</span>,    &#125;,    splitChunks: &#123;      maxInitialRequests: <span class="number">10</span>,      cacheGroups: &#123;        vendor: &#123;          priority: <span class="number">1</span>,          name: <span class="string">"vendor"</span>,          test: <span class="regexp">/node_modules/</span>,          chunks: <span class="string">"initial"</span>,          minSize: <span class="number">0</span>,          minChunks: <span class="number">1</span>,        &#125;,        moment: &#123;          name: <span class="string">"moment"</span>,          priority: <span class="number">5</span>,          test: <span class="regexp">/[\/]node_modules[\/]moment[\/]/</span>,          chunks: <span class="string">"initial"</span>,          minSize: <span class="number">100</span>,          minChunks: <span class="number">1</span>,        &#125;,        lodash: &#123;          name: <span class="string">"lodash"</span>,          priority: <span class="number">6</span>,          test: <span class="regexp">/[\/]node_modules[\/]lodash[\/]/</span>,          chunks: <span class="string">"initial"</span>,          minSize: <span class="number">100</span>,          minChunks: <span class="number">1</span>,        &#125;,        antd: &#123;          name: <span class="string">"antd"</span>,          priority: <span class="number">7</span>,          test: <span class="regexp">/[\/]node_modules[\/]antd[\/]es[\/]/</span>,          chunks: <span class="string">"initial"</span>,          minSize: <span class="number">100</span>,          minChunks: <span class="number">1</span>,        &#125;,      &#125;,    &#125;,    minimizer: [      <span class="keyword">new</span> opimizeCss(),      <span class="keyword">new</span> TerserPlugin(&#123;        cache: <span class="literal">true</span>,        parallel: <span class="literal">true</span>,        sourceMap: <span class="literal">true</span>,      &#125;),    ],  &#125;,  plugins: [<span class="keyword">new</span> BundleAnalyzerPlugin()],&#125;);</code></pre><h4 id="react-lazy">React.lazy</h4><p>理论上你可以对你的任何代码使用懒加载, 但我觉得仅对页面级别使用懒加载足以, 通过路由懒加载界面:</p><pre><code class="highlight js"><span class="comment">//</span><span class="comment">// 路由列表</span><span class="keyword">export</span> <span class="keyword">const</span> routesMapping = &#123;  <span class="comment">//</span>  <span class="comment">// 首页</span>  <span class="string">"/"</span>: React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"@/pages/welcome"</span>)),  <span class="string">"/welcome"</span>: React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"@/pages/welcome"</span>)),&#125;;</code></pre><pre><code class="highlight js">...&#123;  map(routesMapping, (Component, key) =&gt; &#123;    <span class="keyword">return</span> (      <span class="keyword">get</span>(permissionsMapping, key) &amp;&amp; (        &lt;Route          exact          path=&#123;key&#125;        &gt;         &lt;Component            &#123;...this.props&#125;        /&gt;        &lt;<span class="regexp">/Route&gt;</span><span class="regexp">      )</span><span class="regexp">    );</span><span class="regexp">  &#125;);</span><span class="regexp">&#125;</span><span class="regexp">...</span></code></pre><p>至此, 生产环境下打包后, 你的 js 文件将会分散为多个。</p><h3 id="客户端缓存-cache-control">客户端缓存( Cache-Control )</h3><p>经过以上的各种优化, 界面的访问速度已经很快了, 还有一个针对本地缓存的方案, 这个与开启 GZip 压缩类似, 以 nodejs 为例:</p><pre><code class="highlight js">...server.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;  <span class="keyword">if</span> (ctx.request.path.indexOf(<span class="string">'/api'</span>) === <span class="number">-1</span>) &#123;    ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'public'</span>);  &#125; <span class="keyword">else</span> &#123;    ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-store, no-cache, must-revalidate'</span>);  &#125;  ctx.set(<span class="string">'max-age'</span>, <span class="number">7200</span>);  <span class="keyword">await</span> next();&#125;);...</code></pre><p>对除了 api 请求以外的请求进行缓存, 除了第一次访问需要网络请求资源以外, 下一次刷新将直接从本地缓存获取资源。</p><h2 id="总结">总结</h2><p>优化 web 体验, 基本上是围绕 <code>减少资源大小( 压缩, 拆分 )</code>, <code>减少HTTP请求( svg , 样式优化 )</code>, <code>避免重绘和重排( 优化代码 )</code>, <code>提高 HTTP 访问速度( CDN )</code>, 如果大家有更好的优化方式, 欢迎一起讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;What&lt;/h2&gt;
&lt;p&gt;针对 web 前端优化方案的总结, 主要技术栈为 React。&lt;/p&gt;
&lt;h2 id=&quot;why&quot;&gt;Why&lt;/h2&gt;
&lt;p&gt;与以往 PHP, JSP 等服务端渲染不同, 现如今大多数 web 端采用 React, Vue, An
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://www.kavience.com/tags/JavaScript/"/>
    
      <category term="优化" scheme="http://www.kavience.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>如果坚持一个行业五年</title>
    <link href="http://www.kavience.com/think/if-you-stick-to-an-industry-for-five-years.html"/>
    <id>http://www.kavience.com/think/if-you-stick-to-an-industry-for-five-years.html</id>
    <published>2020-07-31T07:55:00.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在开头">写在开头</h2><p>这两天确实有点开始焦虑了，准确的来说，我好像一直都很焦虑。最近又有新想法了，想重新捡起 Android ，想做 APP 开发。回想起大学的时候，我一直都好想做 APP 开发，书也买了不少，视频也看了不少，但始终没有坚持下去。刚刚重新看了点关于 Android 的知识，回想起以前的一些‘经验’，不知怎的，有点黯然伤神。</p><p>当初为什么没有坚持下去呢？我一直觉得自己是个很浮躁又很有想法的人，但也正是这种想法让我始终难以在某个领域特别突出。从上大学开始，到现今算算也已经五年了，如果我就一直在做 Android 开发，到今天会怎么样呢？我会不会是这个行业比较牛的人了？我觉得很有可能会。</p><h2 id="定义下一个五年">定义下一个五年</h2><p>实际上我并非是个没有计划的人，相反，我非常喜欢做一些计划，也许计划没有完成，但是计划总能让事情做起来井然有序。我曾在大学的某天心里默默列下我的第一个五年计划，就是大学毕业的那年，存下五万块钱，虽然有点俗气，但好歹也算是完成目标了。我给自己的五年计划往往无关技术、工作、爱情等。很俗，可以说只有钱和人生，像国家的中心目标一样，要以经济建设为中心，如果离开经济，其它一切可能都是浮云。我的下一个人生五年计划，也非常简单，30 岁之前，结婚、生子、存款 30 万。不再不切实际，丢掉幻想。</p><p>说的有点远了，我今天想说的是关于坚持一个行业的五年，我希望我能够坚持某个行业领域 5 年，然后在这个行业里面技术属于全国 20% 以上的水准。可惜的是我还没有确定好目标，这是非常非常不好的。我会一直坚持做前端 5 年吗？我会一直做医疗相关的系统吗？我会一直在广州做 IT 发展吗？这些我都不能确定。但我能确定一个目标，就是我想做自由职业者。而我给自己定义的工作是，不希望给任何人打工，我希望运营某些属于自己的产品，有着不错的收入，带着老婆孩子各个城市居住。</p><h2 id="种下一棵树">种下一棵树</h2><p>人生可没有多少个五年十年可以奋斗，有句话说的好，<code>「种下一棵树最后的时间是十年前，其次是现在」</code>。我想在现在种下一颗树的种子，在五年后看看结果如何。为了自由职业而奋斗，当下我要做的应该就是一直保持奋斗精神，一直学习下去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在开头&quot;&gt;写在开头&lt;/h2&gt;
&lt;p&gt;这两天确实有点开始焦虑了，准确的来说，我好像一直都很焦虑。最近又有新想法了，想重新捡起 Android ，想做 APP 开发。回想起大学的时候，我一直都好想做 APP 开发，书也买了不少，视频也看了不少，但始终没有坚持下去。刚
      
    
    </summary>
    
    
      <category term="think" scheme="http://www.kavience.com/categories/think/"/>
    
    
      <category term="坚持" scheme="http://www.kavience.com/tags/%E5%9D%9A%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>程序员的焦虑</title>
    <link href="http://www.kavience.com/think/programmers-anxiety.html"/>
    <id>http://www.kavience.com/think/programmers-anxiety.html</id>
    <published>2020-07-29T08:44:24.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在开头">写在开头</h2><p>有时候我一直怀疑自己不适合做一个程序员，出身普普通通，小学六年从未接触过英语，接触计算机也是因为去网吧打游戏。小时候的我像大多数的人的童年一样，希望以后做个科学家，从没想过去做程序员，那时候连程序员这个职业是什么都不知道。一直到高中，吵着跟爸妈说要买电脑，说是为了学习，实则是为了打游戏。最疯狂的时候，痴迷到什么程度呢？高一高二每次开运动会的时候，我都是在家打游戏度过的。基本不参加一些这样的活动，每天中午回家吃饭的时候，要是没人管着，也会开一把游戏。每年的元旦都放一天假，年年都去网吧通宵。经常晚自习后，还去网吧打两把游戏。（主要是英雄联盟）</p><p>那个时候互联网还不发达，智能手机也刚刚起步，马云的支付宝和淘宝也在那个时候开始火起来，比特币大约 200 多 RMB，虽然那个时候是高中生，但我总希望有一天靠电脑挣钱。在网上查资料，还用自己家的电脑去挖矿，虽然那个时候啥也不懂，但在网上看到说这个值钱。后来，高三毕业，高考总分 500 分，数学 120 多，语文 100 多，英语 120 多，理科才 150 几分，进入了一所二本学校，那个时候不顾任何人反对，就是要填计算机专业。</p><p>在大学里面，学的关于计算机的理论知识太多，且丝毫难以提起学习的兴趣，只能花时间自学，而且还是在第二年才认真开始学习。我觉得这跟大学也有非常大的关系，当然了，主要还是自己的问题，就不展开细说了。</p><p>以上是我的背景，就目前为止，我主要有哪些焦虑呢？</p><h2 id="生活">生活</h2><h3 id="生活成本">生活成本</h3><p>我觉得一切的一切，都是为了生活，不管哪个行业。你想要好的生活，生活成本就会相应的变高，那就必须要好好工作，这是一切努力的前提。</p><p>现在在国内，只要四肢健全，随便找份工作，应该就饿不死，但是大部分人应该都不仅仅想要饿不死吧。虚荣、贪婪等等欲望放大了生活成本。</p><h3 id="生活节奏">生活节奏</h3><p>为了提高工资待遇，前往一线城市打拼，生活节奏就越来越快，就拿自己举例，我发现我的时间变得越来越少，每天都感觉时间不够用。</p><h3 id="生活方式">生活方式</h3><p>每天三点一线，宿舍 - 上班/下班的路上 - 公司，虽然在楼下有办健身卡，但是难以提起动力，下班后就只想回家洗个澡躺着。在公司每天又坐着，腰又累。长此以往，恶性循环。</p><h2 id="技术">技术</h2><p>在大学的时候，我学了汇编、C、C++、Java、安卓、PHP，还研究过微信小程序。学的杂，又学的不深，简直就是一个野生程序员，野蛮生长。</p><p>与其它行业不一样，程序员是要一直保持学习的，倘若长时间不学习，动手能力就会衰退，这是对程序员最致命的一点，<br>我相信大部分的人应该意识到了这一点。昨天想学 ReactNative，今天又想学 flutter，明天又想学 kotlin。这简直就是我的写照，我想学好多好多东西，但说实在的，自己的学习能力和坚持能力，只能处于一个中等水平。导致自己在技术上的焦虑更深。</p><h2 id="我该怎么做？">我该怎么做？</h2><p>我现在还是处于这个不定漂浮的状态，我还是没有找到解决的方式处理自己的焦虑，感觉自己就像是处于一个不断恶性循环的牢笼中。我不知道该怎么办，但是，我告诫自己，不要走极端。想起曾经看过的一句话，<code>如果不知道该做什么的时候，就去看书吧，这是唯一不会做错的事情</code>。嗯，于是我开始学起日语了（英语都还没学好，也不知道自己是咋想的）。我不断告诉自己，焦虑是没有用的，只能自己体会这份焦虑和孤独，时间会磨平这一切，我想我要做的应该就是默默努力，不要放弃自己，等待时机。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在开头&quot;&gt;写在开头&lt;/h2&gt;
&lt;p&gt;有时候我一直怀疑自己不适合做一个程序员，出身普普通通，小学六年从未接触过英语，接触计算机也是因为去网吧打游戏。小时候的我像大多数的人的童年一样，希望以后做个科学家，从没想过去做程序员，那时候连程序员这个职业是什么都不知道。一直
      
    
    </summary>
    
    
      <category term="think" scheme="http://www.kavience.com/categories/think/"/>
    
    
      <category term="焦虑" scheme="http://www.kavience.com/tags/%E7%84%A6%E8%99%91/"/>
    
  </entry>
  
  <entry>
    <title>未来的路</title>
    <link href="http://www.kavience.com/think/the-way-forward.html"/>
    <id>http://www.kavience.com/think/the-way-forward.html</id>
    <published>2020-07-27T01:50:32.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言">序言</h2><h3 id="初衷">初衷</h3><p>突然有那么一刻，我想写点什么，关于人生的一些思考。本来我曾希望只在博客里面写关于技术的东西，但是有的时候，我觉得总想写点什么才行，脑海里时不时会冒出一些 idea，如果不写下来，没过多久我觉得我就会忘记。所以，这将是我写这个系列的初衷，观点不一定正确，但从我开始写的时候，我也没想过让多少人看，也许根本没有人看，但这无关紧要，几十年后，让年纪大了的自己回头看看曾经 20 多岁的自己的一些想法，我想应该也是及其有趣的。</p><h3 id="关于取名">关于取名</h3><p>为什么叫「 未来的路 」？我没有指明主语，所以我想写的这个系列，肯定不是只关于自己，这条路，也许关于在看这篇文章的你，或者你熟知的某个人，或者是我，亦或者是整个人类。受阮一峰老师的启发，他有一个系列名叫「 未来世界幸存者 」 ，看完后我也给我的这个系列取名为「 未来的路 」。</p><h3 id="关于内容">关于内容</h3><p>我觉得内容将以生活中的小事为主，所谓见微知著，一些小事往往能展现一些大的人生与智慧。其次以国际政治、历史、文化等为背景，可能会谈到一些关乎人类命运的东西，我谈这些主要不是为了要说明什么，更多地可能是关于人性，在我眼里，我觉得有的时候人类与动物并无二样，通过所见所闻，剖析人类人性，直面人的本性，我觉得这也正是我想记录下来的。</p><h3 id="关于计划">关于计划</h3><p>我也是临时起意，感觉并无具体的计划，也许写个三五年，也许写个八年十年，想到哪写到哪，随心所欲，唯一一点对自己的要求就是不写反人类的内容，在所有文章中，保持最中立的一面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;h3 id=&quot;初衷&quot;&gt;初衷&lt;/h3&gt;
&lt;p&gt;突然有那么一刻，我想写点什么，关于人生的一些思考。本来我曾希望只在博客里面写关于技术的东西，但是有的时候，我觉得总想写点什么才行，脑海里时不时会冒出一些 idea，如果不写下来，没过多久我觉得我
      
    
    </summary>
    
    
      <category term="think" scheme="http://www.kavience.com/categories/think/"/>
    
    
      <category term="路" scheme="http://www.kavience.com/tags/%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Terminal翻墙代理</title>
    <link href="http://www.kavience.com/tools/terminal-over-the-wall-proxy.html"/>
    <id>http://www.kavience.com/tools/terminal-over-the-wall-proxy.html</id>
    <published>2020-07-21T02:06:58.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what？">What？</h2><blockquote><p>通过 <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">proxychains-ng</a> 实现 terminal 代理</p></blockquote><h2 id="why？">Why？</h2><blockquote><p>目前的代理功能，大部分底层都是基于 socks5、http 等，然后配合插件如 SwitchyOmega 等，实现在浏览器端代理，或者是全局代理，但问题是在 terminal 下仍然不走代理。即使通过 <code>export http_proxy=http://127.0.0.1:1081 https_proxy=http://127.0.0.1:1081</code> 发现还是不行。这几天终于忍受不了，我觉得一定有人跟我一样的想法，肯定有人已经着手在做这件事情。果然，偶然发现 <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">proxychains-ng</a> 这款开源软件，决定试一下。</p></blockquote><h2 id="how？">How？</h2><p>经过昨天的实践，经过一顿操作后，发现不行，然后就果断关机下班了。今早到公司再打开 terminal 试下，发现昨天已经成功了。</p><h3 id="关闭-mac-的-sip">关闭 Mac 的 SIP</h3><p>重启 Mac，按住 Option 键进入启动盘选择模式，再按 <code>⌘ + R</code> 进入 Recovery 模式。实用工具( Utilities )-&gt; 终端( Terminal )。输入命令 <code>csrutil disable</code> 运行。重启进入系统后，终端里输入 <code>csrutil status</code>，结果中如果有 <code>System Integrity Protection status:disabled</code>。则说明关闭成功。</p><h3 id="brew-安装-proxychains-ng">brew 安装 proxychains-ng</h3><pre><code class="highlight bash">brew install proxychains-ng</code></pre><h3 id="配置代理">配置代理</h3><p>brew 安装后，proxychains-ng 的配置文件在 <code>/usr/local/etc/proxychains.conf</code> 下，在文件最后</p><pre><code class="highlight bash">......<span class="comment"># 找到 ProxyList</span>[ProxyList]<span class="comment"># 配置本地已经有的 socks5代理</span>socks5  127.0.0.1 1086</code></pre><h3 id="测试效果">测试效果</h3><p>运行命令</p><pre><code class="highlight bash">proxychains4 curl ipinfo.io</code></pre><p>输出结果如下：</p><pre><code class="highlight bash">[proxychains] config file found: /usr/<span class="built_in">local</span>/etc/proxychains.conf[proxychains] preloading /usr/<span class="built_in">local</span>/Cellar/proxychains-ng/4.14/lib/libproxychains4.dylib[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  127.0.0.1:1080  ...  ipinfo.io:80  ...  OK&#123;  <span class="string">"ip"</span>: <span class="string">"103.121.211.104"</span>,  <span class="string">"city"</span>: <span class="string">"Tokyo"</span>,  <span class="string">"region"</span>: <span class="string">"Tokyo"</span>,  <span class="string">"country"</span>: <span class="string">"JP"</span>,  <span class="string">"loc"</span>: <span class="string">"35.6895,139.6917"</span>,  <span class="string">"org"</span>: <span class="string">"AS4785 xTom"</span>,  <span class="string">"postal"</span>: <span class="string">"151-0052"</span>,  <span class="string">"timezone"</span>: <span class="string">"Asia/Tokyo"</span>,  <span class="string">"readme"</span>: <span class="string">"https://ipinfo.io/missingauth"</span>&#125;</code></pre><h3 id="增加别名">增加别名</h3><p>每次使用都需要输入 <code>proxychains4</code> ，显得太长了，增加别名在 .zshrc 下进行优化，</p><pre><code class="highlight bash"><span class="comment"># 增加 alias</span><span class="built_in">alias</span> out=<span class="string">'proxychains4'</span></code></pre><h3 id="结语">结语</h3><p>此后，每次在需要翻墙的情况下，只需要在命令前，加上 <code>out</code> 即可。</p><p>当然 proxychains-ng 还有更加丰富的功能，貌似可以实现任意软件的翻墙，但由于我不需要，也没有去研究这个，以后有需要再说吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what？&quot;&gt;What？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通过 &lt;a href=&quot;https://github.com/rofl0r/proxychains-ng&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proxychains-n
      
    
    </summary>
    
    
      <category term="tools" scheme="http://www.kavience.com/categories/tools/"/>
    
    
      <category term="翻墙" scheme="http://www.kavience.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>今年计划</title>
    <link href="http://www.kavience.com/think/plan-this-year.html"/>
    <id>http://www.kavience.com/think/plan-this-year.html</id>
    <published>2020-07-11T02:26:29.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what">What?</h2><p>工作闲暇之余想做的一些事。</p><h2 id="why">Why?</h2><p>发现自己想做的事情实在是太多了，一直想做点什么属于自己的东西，零零散散之前一直没做，从现在开始专注于每件事吧！</p><p>终身学习！</p><h2 id="how">How?</h2><h3 id="运营一款关于家乡的论坛">运营一款关于家乡的论坛</h3><p>这个想法其实很早就有，也一直没有行动，现在终于下定决心了。</p><p><a href="https://www.yichunbendi.com" target="_blank" rel="noopener">宜春本地论坛</a> 是一款关于家乡本地的，涵盖交友、话题讨论、本地活动、本地资讯的论坛。配合公众号，推送一下关于家乡的东西。</p><h3 id="开发一个通用的-cms-系统">开发一个通用的 CMS 系统</h3><p>这个想法也是刚刚冒出来的，这个 CMS 系统可能与其他系统不一样，我决定基于 Laravel + React 开发。</p><p>主要功能是：</p><ul><li>包涵基本管理系统功能: RBAC、系统监控等基本功能</li><li>基于 ant-design 和 React，开发一个动态表单功能，通过数据库配置生成表单</li><li>基于配置生成数据列表</li><li>除以上基本功能之外灵活度极高</li></ul><h3 id="其它">其它</h3><ul><li>继续熟练 React 生态</li><li>继续熟练 Laravel 生态</li><li>偶尔看看 Spring Boot</li><li>练习吉他（好久没练了）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;what&quot;&gt;What?&lt;/h2&gt;
&lt;p&gt;工作闲暇之余想做的一些事。&lt;/p&gt;
&lt;h2 id=&quot;why&quot;&gt;Why?&lt;/h2&gt;
&lt;p&gt;发现自己想做的事情实在是太多了，一直想做点什么属于自己的东西，零零散散之前一直没做，从现在开始专注于每件事吧！&lt;/p&gt;
&lt;p&gt;终身学习！
      
    
    </summary>
    
    
      <category term="think" scheme="http://www.kavience.com/categories/think/"/>
    
    
      <category term="随笔闲谈" scheme="http://www.kavience.com/tags/%E9%9A%8F%E7%AC%94%E9%97%B2%E8%B0%88/"/>
    
      <category term="2020计划" scheme="http://www.kavience.com/tags/2020%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>PSR-1基本规范</title>
    <link href="http://www.kavience.com/php/psr1-basic-specification.html"/>
    <id>http://www.kavience.com/php/psr1-basic-specification.html</id>
    <published>2020-07-08T06:31:52.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读建议">阅读建议</h2><blockquote><p>本文是根据 PSR 规范英文文档翻译而来，建议多次阅读以便熟悉这些规范，并在工作中用到这些规范。</p></blockquote><h2 id="what">What?</h2><blockquote><p>一篇翻译而来的 PSR-1 规范</p></blockquote><h2 id="why">Why?</h2><blockquote><p>通过翻译 PSR 规范，掌握 PHP 的开发规范</p></blockquote><h2 id="how">How?</h2><h3 id="关键字">关键字</h3><p>本文中的关键词 <code>&quot;必须&quot;</code>, <code>&quot;禁止&quot;</code>, <code>&quot;必要&quot;</code>, <code>&quot;最好&quot;</code>, <code>&quot;最好不要&quot;</code>, <code>&quot;应该&quot;</code>, <code>&quot;不应该&quot;</code>, <code>&quot;建议&quot;</code>, <code>&quot;可以&quot;</code>, <code>&quot;可选&quot;</code> 应按照 <a href="https://www.ietf.org/rfc/rfc2119.txt" target="_blank" rel="noopener">RFC 2119</a> 的规定进行解释。</p><h3 id="概览">概览</h3><ul><li><p>PHP 文件<code>必须</code>使用 <code>&lt;?php</code> 或者 <code>&lt;?=</code> 标签开始</p></li><li><p>PHP 文件<code>必须</code>使用不带 bom 的 UTF-8 编码</p></li><li><p>PHP 文件<code>应该</code>要么只声明类、函数、变量等，要么引起副作用（例如生成输出，改变 .ini 配置文件等操作），但是<code>不应该</code>两者都做。</p></li><li><p>命名空间和类<code>必须</code>遵循自动加载规范 [PSR-0, PSR-4]</p></li><li><p>PHP 类名<code>必须</code>以大驼峰规范命名，例如 <code>HomeClass</code></p></li><li><p>PHP 类文件中的常量<code>必须</code>使用下划线分隔且以大写形式声明，例如 <code>APP_KEY</code></p></li><li><p>方法名<code>必须</code>以小驼峰规范命名，例如 <code>updateUser</code></p></li></ul><h3 id="文件">文件</h3><h3 id="php-标签">PHP 标签</h3><p>PHP 便签<code>必须</code>使用 <code>&lt;?php ?&gt;</code> 或者 <code>&lt;?= ?&gt;</code> , <code>禁止</code>使用其它标签代替。</p><h3 id="字符编码">字符编码</h3><p>PHP 代码<code>必须</code>使用不带 Bom 的 UTF-8 编码</p><h3 id="副作用">副作用</h3><p>PHP 文件<code>应该</code>要么只声明类、函数、变量等，要么引起副作用（例如生成输出，改变 .ini 配置文件等操作），但是<code>不应该</code>两者都做。</p><p>「副作用」(side effects) 一词的意思是，通过包含文件，但不直接声明类、函数、常量等而执行的逻辑操作。</p><p>「副作用」包含却不仅限于：</p><ul><li>生成输出</li><li>直接的 require 或 include</li><li>连接外部服务</li><li>修改 ini 配置</li><li>抛出错误或异常</li><li>修改全局或静态变量</li><li>读或写文件等</li></ul><p>以下是一个违反此规范的例子：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="comment">// 副作用: 根本 ini 设置</span>ini_set(<span class="string">'error_reporting'</span>, E_ALL);<span class="comment">// 副作用: 加载文件</span><span class="keyword">include</span> <span class="string">"file.php"</span>;<span class="comment">// 副作用: 生成输出</span><span class="keyword">echo</span> <span class="string">"&lt;html&gt;\n"</span>;<span class="comment">// 声明</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span><span class="function"></span>&#123;&#125;</code></pre><p>以下是一个符合此规范的例子：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="comment">// 声明 foo 函数</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span><span class="function"></span>&#123;&#125;<span class="comment">// 有条件的声明不产生副作用</span><span class="keyword">if</span> (! function_exists(<span class="string">'bar'</span>)) &#123;    <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span><span class="function">    </span>&#123;    &#125;&#125;</code></pre><h3 id="命名空间和类名">命名空间和类名</h3><p>命名空间和类<code>必须</code>遵循 PSR 自动加载规范：[PSR-0, PSR-4]。</p><p>根据规范，每个类都独立为一个文件，且命名空间至少有一个层次：顶级的组织名称（vendor name）。</p><p>类的命名<code>必须</code>遵循 StudlyCaps 大写开头的驼峰命名规范。</p><p>PHP 5.3 及以后版本的代码<code>必须</code>使用正式的命名空间。</p><p>例如：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="comment">// PHP 5.3 以后版本:</span><span class="keyword">namespace</span> <span class="title">Vendor</span>\<span class="title">Model</span>;<span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span><span class="class"></span>&#123;&#125;</code></pre><p>5.2.x 及之前的版本<code>应该</code>使用伪命名空间的写法，约定俗成使用顶级的组织名称（vendor name）如 Vendor_ 为类前缀。</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="comment">// PHP 5.2.x 及更早版本:</span><span class="class"><span class="keyword">class</span> <span class="title">Vendor_Model_Foo</span></span><span class="class"></span>&#123;&#125;</code></pre><h3 id="类常量-类属性-方法">类常量、类属性、方法</h3><p>此处的「类」指代所有的类、接口以及可复用代码块（traits）。</p><h4 id="常量">常量</h4><ul><li>PHP 类文件中的常量<code>必须</code>使用下划线分隔且以大写形式声明，例如:</li></ul><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="keyword">namespace</span> <span class="title">Vendor</span>\<span class="title">Model</span>;<span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span><span class="class"></span>&#123;    <span class="keyword">const</span> VERSION = <span class="string">'1.0'</span>;    <span class="keyword">const</span> DATE_APPROVED = <span class="string">'2012-06-01'</span>;&#125;</code></pre><h4 id="属性">属性</h4><p>类的属性命名<code>可以</code>遵循：</p><ul><li>大写开头的驼峰式 ($StudlyCaps)</li><li>小写开头的驼峰式 ($camelCase)</li><li>下划线分隔式 ($under_score)</li><li>本规范不做强制要求，但无论遵循哪种命名方式，都<code>应该</code>在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。</li></ul><h4 id="方法">方法</h4><p>方法名<code>必须</code>为小驼峰命名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读建议&quot;&gt;阅读建议&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是根据 PSR 规范英文文档翻译而来，建议多次阅读以便熟悉这些规范，并在工作中用到这些规范。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;what&quot;&gt;What?&lt;/h2&gt;
&lt;blockqu
      
    
    </summary>
    
    
      <category term="php" scheme="http://www.kavience.com/categories/php/"/>
    
    
      <category term="PSR规范" scheme="http://www.kavience.com/tags/PSR%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>自建前端错误监控系统</title>
    <link href="http://www.kavience.com/tools/selfbuilt-frontend-error-monitoring-system.html"/>
    <id>http://www.kavience.com/tools/selfbuilt-frontend-error-monitoring-system.html</id>
    <published>2020-06-16T08:22:55.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读建议">阅读建议</h2><blockquote><p>先整体快速阅读一遍，再回头看其中的配置。</p></blockquote><h2 id="what？">What？</h2><blockquote><p>使用开源工具<a href="https://github.com/getsentry/sentry" target="_blank" rel="noopener">sentry</a>，自建一套 bug 监控系统。</p></blockquote><h2 id="why？">Why？</h2><blockquote><p>在日常前端的开发中，当产品部署到线上的时候，前端页面一旦发生错误往往是非常严重，并且难以重现 bug ，为了使得项目中的 bug 可控，bug 监控就显得尤其重要了。然而，现在市面上的 bug 监控软件，可以说并不便宜，这个时候我们可以选择自建一套监控系统。</p></blockquote><h2 id="how？">How？</h2><h3 id="准备工具">准备工具</h3><ul><li>Docker 17.05.0+</li></ul><h3 id="下载项目">下载项目</h3><pre><code class="highlight bash">git <span class="built_in">clone</span> git@github.com:getsentry/onpremise.git</code></pre><h3 id="配置文件">配置文件</h3><ul><li>复制 <strong>sentry/config.example.yml</strong> 为 config.yml</li><li>复制 <strong>sentry/sentry.conf.example.py</strong> 为 <a href="http://sentry.conf.py" target="_blank" rel="noopener">sentry.conf.py</a></li><li>按需编辑 .env 文件</li></ul><p>配置文件上面都有相应的说明，这里就不赘述。</p><p>执行目录下的 <a href="http://install.sh" target="_blank" rel="noopener">install.sh</a> 。<strong>(执行前请调到下一步看常见错误，节省时间。)</strong></p><pre><code class="highlight bash">./install.sh</code></pre><h3 id="常见错误">常见错误</h3><h4 id="数据库连接失败">数据库连接失败</h4><pre><code class="highlight bash">django.db.utils.OperationalError: could not connect to server: Connection refused</code></pre><p>发生以上错误是由于数据库配置失败的问题，sentry 采用的是 postgresSQL ，我在安装的时候，数据库配置的是本机地址，之前也不怎么了解 postgresSQL ，下面是<br>postgresSQL 的一些安装配置</p><ul><li>安装 postgresSQL</li></ul><pre><code class="highlight bash"><span class="comment"># 我采用的是 brew 安装，便于管理</span>brew info postgresql@9.5<span class="comment"># 注意安装后的说明</span>...If you need to have postgresql@9.5 first <span class="keyword">in</span> your PATH run:  <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/postgresql@9.5/bin:$PATH"'</span> &gt;&gt; ~/.zshrcFor compilers to find postgresql@9.5 you may need to <span class="built_in">set</span>:  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/postgresql@9.5/lib"</span>  <span class="built_in">export</span> CPPFLAGS=<span class="string">"-I/usr/local/opt/postgresql@9.5/include"</span>To have launchd start postgresql@9.5 now and restart at login:  brew services start postgresql@9.5Or, <span class="keyword">if</span> you dont want/need a background service you can just run:  pg_ctl -D /usr/<span class="built_in">local</span>/var/postgresql@9.5 start...<span class="comment"># 这里执行以下几个命令即可</span><span class="comment"># 输出到 zsh</span><span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/postgresql@9.5/bin:$PATH"'</span> &gt;&gt; ~/.zshrc<span class="comment"># 更新环境</span><span class="built_in">source</span> ~/.zshrc<span class="comment"># 安装后我的文件目录为 /usr/local/var/postgresql@9.5</span><span class="comment"># 编辑 postgresql.conf ，修改 listen_addresses</span>listen_addresses = <span class="string">'*'</span>          <span class="comment"># what IP address(es) to listen on;</span><span class="comment"># 编辑 pg_hba.conf ，修改 listen_addresses</span><span class="comment"># 在文件最后添加</span>host  all  all 0.0.0.0/0 md5<span class="comment"># 启动 postgresql</span>brew services start postgresql@9.5<span class="comment"># 创建数据库用户</span>createuser <span class="built_in">test</span> -P<span class="comment"># 创建数据库</span>createdb bug-monitor<span class="comment"># 登录数据库查看</span>psql -U <span class="built_in">test</span><span class="comment"># 进入后查看表</span>\l<span class="comment"># 可以看到已经存在 bug-monitor 表了</span></code></pre><ul><li>安装 psequel 测试连接（这一步非必须）<br>下载安装 psequel ，查看局域网 ip 地址，我的 ip 地址为 192.168.123.95，输入局域网地址测试能否登录，如果可以就说明没什么问题了。</li></ul><h4 id="docker-服务未启动">docker 服务未启动</h4><pre><code class="highlight bash">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></pre><p>检查 docker 服务是否正常启动</p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读建议&quot;&gt;阅读建议&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;先整体快速阅读一遍，再回头看其中的配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;what？&quot;&gt;What？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;使用开源工具&lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="tools" scheme="http://www.kavience.com/categories/tools/"/>
    
    
      <category term="sentry" scheme="http://www.kavience.com/tags/sentry/"/>
    
  </entry>
  
  <entry>
    <title>记一次React项目搭建</title>
    <link href="http://www.kavience.com/frontend/remember-to-build-a-react-project.html"/>
    <id>http://www.kavience.com/frontend/remember-to-build-a-react-project.html</id>
    <published>2020-06-15T10:30:09.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读建议">阅读建议</h2><blockquote><p>先整体快速阅读一遍，再回头看其中的配置。</p></blockquote><h2 id="what？">What？</h2><blockquote><p>通过 npm、webpack、babel、typescript 等工具，自己搭建一次 React 的 typescript 项目。</p></blockquote><h2 id="why？">Why？</h2><blockquote><p>之前用过 next.js、ant-design-pro、create-react-app 等各种脚手架搭建过 react 项目，但是在使用过程中发现这些框架要么灵活性不足、要么打包后的文件过大等，所以决定手动搭建一次项目。</p></blockquote><h2 id="how？">How？</h2><h3 id="准备工具">准备工具</h3><ul><li>node &gt; v10</li></ul><h3 id="所需依赖项">所需依赖项</h3><p>package.json 文件如下：</p><pre><code class="highlight json">&#123;  <span class="attr">"name"</span>: <span class="string">"react-demo"</span>,  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,  <span class="attr">"scripts"</span>: &#123;    <span class="attr">"dev"</span>: <span class="string">"cross-env ENVIRONMENT_MODE=dev env-cmd node index.js"</span>,    <span class="attr">"start"</span>: <span class="string">"cross-env ENVIRONMENT_MODE=production env-cmd node index.js"</span>,    <span class="attr">"build"</span>: <span class="string">"webpack --config webpack.product.config.js"</span>,    <span class="attr">"build:dll"</span>: <span class="string">"webpack --config webpack.config.dll.js"</span>  &#125;,  <span class="attr">"author"</span>: <span class="string">"kavience"</span>,  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,  <span class="attr">"dependencies"</span>: &#123;    <span class="comment">// babel 包</span>    <span class="attr">"@babel/core"</span>: <span class="string">"^7.10.2"</span>,    <span class="attr">"@babel/plugin-proposal-class-properties"</span>: <span class="string">"^7.10.1"</span>,    <span class="attr">"@babel/plugin-proposal-object-rest-spread"</span>: <span class="string">"^7.10.1"</span>,    <span class="attr">"@babel/preset-env"</span>: <span class="string">"^7.10.2"</span>,    <span class="attr">"@babel/preset-react"</span>: <span class="string">"^7.10.1"</span>,    <span class="attr">"@babel/preset-typescript"</span>: <span class="string">"^7.10.1"</span>,    <span class="attr">"babel-loader"</span>: <span class="string">"^8.1.0"</span>,    <span class="attr">"babel-plugin-import"</span>: <span class="string">"^1.13.0"</span>,    <span class="comment">// koa 相关的包，用于启动服务，代替 webpack-dev-server</span>    <span class="attr">"koa"</span>: <span class="string">"^2.12.0"</span>,    <span class="attr">"koa-proxies"</span>: <span class="string">"^0.11.0"</span>,    <span class="attr">"koa-static"</span>: <span class="string">"^5.0.0"</span>,    <span class="attr">"koa2-connect-history-api-fallback"</span>: <span class="string">"^0.1.2"</span>,    <span class="attr">"koa-webpack"</span>: <span class="string">"^5.3.0"</span>,    <span class="comment">// react 相关</span>    <span class="attr">"react"</span>: <span class="string">"^16.13.1"</span>,    <span class="attr">"react-dom"</span>: <span class="string">"^16.13.1"</span>,    <span class="attr">"redux"</span>: <span class="string">"^4.0.5"</span>,    <span class="attr">"redux-thunk"</span>: <span class="string">"^2.3.0"</span>,    <span class="comment">// typescript相关</span>    <span class="attr">"typescript"</span>: <span class="string">"^3.9.5"</span>,    <span class="attr">"@types/react"</span>: <span class="string">"^16.9.35"</span>,    <span class="attr">"@types/react-dom"</span>: <span class="string">"^16.9.8"</span>,    <span class="attr">"@types/react-redux"</span>: <span class="string">"^7.1.9"</span>,    <span class="attr">"@types/react-router-dom"</span>: <span class="string">"^5.1.5"</span>,    <span class="comment">// webpack 相关</span>    <span class="attr">"webpack"</span>: <span class="string">"^4.43.0"</span>,    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span>,    <span class="attr">"webpack-merge"</span>: <span class="string">"^4.2.2"</span>,    <span class="attr">"webpack-bundle-analyzer"</span>: <span class="string">"^3.8.0"</span>,    <span class="attr">"clean-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>,    <span class="attr">"copy-webpack-plugin"</span>: <span class="string">"^6.0.2"</span>,    <span class="attr">"css-loader"</span>: <span class="string">"^3.5.3"</span>,    <span class="attr">"file-loader"</span>: <span class="string">"^6.0.0"</span>,    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.3.0"</span>,    <span class="attr">"less"</span>: <span class="string">"^3.11.3"</span>,    <span class="attr">"less-loader"</span>: <span class="string">"^6.1.0"</span>,    <span class="attr">"less-vars-to-js"</span>: <span class="string">"^1.3.0"</span>,    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,    <span class="attr">"optimize-css-assets-webpack-plugin"</span>: <span class="string">"^5.0.3"</span>,    <span class="attr">"postcss-loader"</span>: <span class="string">"^3.0.0"</span>,    <span class="attr">"url-loader"</span>: <span class="string">"^4.1.0"</span>,    <span class="attr">"compression"</span>: <span class="string">"^1.7.4"</span>,    <span class="attr">"cross-env"</span>: <span class="string">"^7.0.2"</span>,    <span class="attr">"env-cmd"</span>: <span class="string">"^10.1.0"</span>,    <span class="attr">"terser-webpack-plugin"</span>: <span class="string">"^3.0.3"</span>,    <span class="comment">// prettierrc 格式化，直接引用 umijs</span>    <span class="attr">"@umijs/fabric"</span>: <span class="string">"^2.1.0"</span>  &#125;&#125;</code></pre><p>以上这些包，直接网上搜这些就能明白其用处，在此就不赘述。</p><h3 id="配置-babel">配置 babel</h3><p>在根目录下新建 .babelrc 文件：</p><pre><code class="highlight json">&#123;  <span class="attr">"presets"</span>: [    <span class="string">"@babel/preset-env"</span>,    <span class="string">"@babel/preset-typescript"</span>,    <span class="string">"@babel/preset-react"</span>  ],  <span class="attr">"plugins"</span>: [    <span class="string">"@babel/proposal-class-properties"</span>,    <span class="string">"@babel/proposal-object-rest-spread"</span>,    <span class="comment">// 这里是配置 antd 按需加载</span>    [      <span class="string">"import"</span>,      &#123;        <span class="attr">"libraryName"</span>: <span class="string">"antd"</span>,        <span class="attr">"style"</span>: <span class="literal">true</span>      &#125;    ]  ]&#125;</code></pre><h3 id="配置-tsconfig-json">配置 tsconfig.json</h3><pre><code class="highlight json">&#123;  <span class="attr">"compilerOptions"</span>: &#123;    <span class="attr">"outDir"</span>: <span class="string">"build/dist"</span>,    <span class="attr">"module"</span>: <span class="string">"esnext"</span>,    <span class="attr">"target"</span>: <span class="string">"esnext"</span>,    <span class="attr">"lib"</span>: [<span class="string">"esnext"</span>, <span class="string">"dom"</span>],    <span class="attr">"sourceMap"</span>: <span class="literal">true</span>,    <span class="attr">"allowUnreachableCode"</span>: <span class="literal">true</span>,    <span class="attr">"allowUnusedLabels"</span>: <span class="literal">true</span>,    <span class="attr">"baseUrl"</span>: <span class="string">"."</span>,    <span class="attr">"jsx"</span>: <span class="string">"preserve"</span>,    <span class="attr">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>,    <span class="attr">"forceConsistentCasingInFileNames"</span>: <span class="literal">false</span>,    <span class="attr">"noImplicitReturns"</span>: <span class="literal">true</span>,    <span class="attr">"suppressImplicitAnyIndexErrors"</span>: <span class="literal">true</span>,    <span class="attr">"noUnusedLocals"</span>: <span class="literal">true</span>,    <span class="attr">"allowJs"</span>: <span class="literal">true</span>,    <span class="attr">"skipLibCheck"</span>: <span class="literal">true</span>,    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>,    <span class="attr">"strict"</span>: <span class="literal">true</span>,    <span class="attr">"paths"</span>: &#123;      <span class="comment">// 这里是添加别名，用 @ 代替 src 目录</span>      <span class="attr">"@/*"</span>: [<span class="string">"./src/*"</span>]    &#125;,    <span class="attr">"noEmit"</span>: <span class="literal">true</span>,    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,    <span class="attr">"resolveJsonModule"</span>: <span class="literal">true</span>,    <span class="attr">"isolatedModules"</span>: <span class="literal">true</span>  &#125;,  <span class="attr">"exclude"</span>: [    <span class="string">"node_modules"</span>,    <span class="string">"build"</span>,    <span class="string">"dist"</span>,    <span class="string">"scripts"</span>,    <span class="string">"acceptance-tests"</span>,    <span class="string">"webpack"</span>,    <span class="string">"jest"</span>,    <span class="string">"src/setupTests.ts"</span>,    <span class="string">"tslint:latest"</span>,    <span class="string">"tslint-config-prettier"</span>  ]&#125;</code></pre><h3 id="配置-webpack-基本配置">配置 webpack 基本配置</h3><p>在根目录下新建 webpack.base.config.js：</p><pre><code class="highlight JavaScript"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);<span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);<span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);<span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);<span class="keyword">const</span> miniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);<span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);<span class="keyword">const</span> lessToJS = <span class="built_in">require</span>(<span class="string">'less-vars-to-js'</span>);<span class="keyword">const</span> FilterWarningsPlugin = <span class="built_in">require</span>(<span class="string">'webpack-filter-warnings-plugin'</span>);<span class="comment">// 这里是替换 ant-design 的less 样式变量，新建 variables.less</span><span class="keyword">const</span> themeVariables = lessToJS(fs.readFileSync(path.resolve(__dirname, <span class="string">'./src/assets/less/variables.less'</span>), <span class="string">'utf8'</span>));<span class="built_in">module</span>.exports = &#123;  entry: [<span class="string">'./src/index.tsx'</span>],  output: &#123;    filename: <span class="string">'js/vendor.[hash].js'</span>,    path: path.join(__dirname, <span class="string">'/dist'</span>),    publicPath: <span class="string">'/'</span>,  &#125;,  resolve: &#123;    <span class="comment">// 配置别名</span>    alias: &#123;      <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'src'</span>),    &#125;,    extensions: [<span class="string">'.ts'</span>, <span class="string">'.tsx'</span>, <span class="string">'.js'</span>],  &#125;,  <span class="built_in">module</span>: &#123;    rules: [      &#123;        test: <span class="regexp">/\.(ts|js)x?$/</span>,        use: &#123;          loader: <span class="string">'babel-loader'</span>,        &#125;,        exclude: <span class="regexp">/node_modules/</span>,      &#125;,      &#123;        test: <span class="regexp">/\.(png|jpg|gif|svg|jpeg)$/</span>,        use: [          &#123;            loader: <span class="string">'file-loader'</span>,            options: &#123;              name: <span class="string">'img/[name]_[hash:6].[ext]'</span>,            &#125;,          &#125;,        ],      &#125;,      &#123;        test: <span class="regexp">/\.css$/</span>,        use: [          &#123;            loader: miniCssExtractPlugin.loader,          &#125;,          <span class="string">'css-loader'</span>,        ],      &#125;,      &#123;        test: <span class="regexp">/\.less$/</span>,        use: [          &#123;            loader: miniCssExtractPlugin.loader,          &#125;,          <span class="string">'css-loader'</span>,          &#123;            loader: <span class="string">'less-loader'</span>,            options: &#123;              lessOptions: &#123;                javascriptEnabled: <span class="literal">true</span>,                modifyVars: themeVariables,              &#125;,            &#125;,          &#125;,        ],      &#125;,    ],  &#125;,  plugins: [    <span class="comment">// 如果没有按需加载，这句是为了忽略浏览器警告</span>    <span class="keyword">new</span> FilterWarningsPlugin(&#123;      exclude: <span class="regexp">/mini-css-extract-plugin[^]*Conflicting order between:/</span>,    &#125;),    <span class="comment">// 配置 html</span>    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;      template: <span class="string">'./public/index.html'</span>,      favicon: <span class="string">'./public/assets/favicon.png'</span>,    &#125;),    <span class="comment">// 采用 css 就好了，不用 style-loader ，把 css 统一压缩放入 dist/css 文件夹即可</span>    <span class="keyword">new</span> miniCssExtractPlugin(&#123;      filename: <span class="string">'css/[name].css'</span>,    &#125;),    <span class="comment">// 配置 dll，基本不会修改的包，采用 dll 的方式引入，</span>    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;      manifest: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'dll'</span>, <span class="string">'manifest.json'</span>),    &#125;),    <span class="comment">// 重新打包的时候，忽略这些文件</span>    <span class="keyword">new</span> CleanWebpackPlugin(&#123;      cleanOnceBeforeBuildPatterns: [<span class="string">'**/*'</span>, <span class="string">'!dll'</span>, <span class="string">'!dll/**'</span>],    &#125;),  ],&#125;;</code></pre><h3 id="配置-webpack-开发环境">配置 webpack 开发环境</h3><p>在根目录下新建 webpack.dev.config.js，直接合并，设置 mode ，打开 source-map 即可。</p><pre><code class="highlight JavaScript"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);<span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.config.js'</span>);<span class="built_in">module</span>.exports = merge(baseConfig, &#123;  mode: <span class="string">'development'</span>,  devtool: <span class="string">'inline-source-map'</span>,&#125;);</code></pre><h3 id="配置-webpack-生产环境">配置 webpack 生产环境</h3><p>在根目录下新建 webpack.production.config.js：</p><pre><code class="highlight JavaScript"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);<span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.config.js'</span>);<span class="keyword">const</span> opimizeCss = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);<span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);<span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;<span class="built_in">module</span>.exports = merge(baseConfig, &#123;  mode: <span class="string">'production'</span>,  optimization: &#123;    runtimeChunk: &#123;      name: <span class="string">'manifest'</span>,    &#125;,    <span class="comment">// 拆分打包后的 js 文件</span>    splitChunks: &#123;      cacheGroups: &#123;        <span class="keyword">default</span>: &#123;          filename: <span class="string">'common.js'</span>,          chunks: <span class="string">'initial'</span>,          priority: <span class="number">-20</span>,        &#125;,        vendors: &#123;          chunks: <span class="string">'initial'</span>,          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,          filename: <span class="string">'vendor.js'</span>,          priority: <span class="number">-10</span>,        &#125;,        vendorsAsync: &#123;          chunks: <span class="string">'async'</span>,          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,          name: <span class="string">'vendorsAsync'</span>,          priority: <span class="number">0</span>,        &#125;,        antv: &#123;          chunks: <span class="string">'async'</span>,          test: <span class="regexp">/[\\/]node_modules[\\/]@antv[\\/]/</span>,          name: <span class="string">'antv'</span>,          priority: <span class="number">10</span>,        &#125;,        antd: &#123;          chunks: <span class="string">'initial'</span>,          test: <span class="regexp">/[\\/]node_modules[\\/]antd[\\/]/</span>,          filename: <span class="string">'antd.js'</span>,          priority: <span class="number">20</span>,        &#125;,        moment: &#123;          chunks: <span class="string">'async'</span>,          test: <span class="regexp">/[\\/]node_modules[\\/]moment[\\/]/</span>,          name: <span class="string">'moment'</span>,          priority: <span class="number">30</span>,        &#125;,      &#125;,    &#125;,    minimizer: [      <span class="keyword">new</span> opimizeCss(),      <span class="keyword">new</span> TerserPlugin(&#123;        cache: <span class="literal">true</span>,        parallel: <span class="literal">true</span>,        sourceMap: <span class="literal">true</span>,      &#125;),    ],  &#125;,  <span class="comment">// 打包后分析文件</span>  plugins: [<span class="keyword">new</span> BundleAnalyzerPlugin()],&#125;);</code></pre><h3 id="配置-webpack-dll-编译">配置 webpack dll 编译</h3><pre><code class="highlight JavaScript"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);<span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);<span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>);<span class="built_in">module</span>.exports = &#123;  entry: &#123;    <span class="comment">// 把 react、react-dom 作为 dll 文件引入</span>    react: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>],  &#125;,  mode: <span class="string">'production'</span>,  output: &#123;    filename: <span class="string">'[name].dll.[hash:6].js'</span>,    path: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'dll'</span>),    library: <span class="string">'[name]_dll'</span>,  &#125;,  plugins: [    <span class="keyword">new</span> webpack.DllPlugin(&#123;      name: <span class="string">'[name]_dll'</span>,      path: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'dll'</span>, <span class="string">'manifest.json'</span>),    &#125;),  ],&#125;;</code></pre><h3 id="添加项目启动文件">添加项目启动文件</h3><pre><code class="highlight JavaScript"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);<span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);<span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);<span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);<span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);<span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'koa-proxies'</span>);<span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.dev.config.js'</span>);<span class="keyword">const</span> koaWebpack = <span class="built_in">require</span>(<span class="string">'koa-webpack'</span>);<span class="keyword">const</span> &#123; historyApiFallback &#125; = <span class="built_in">require</span>(<span class="string">'koa2-connect-history-api-fallback'</span>);<span class="comment">// 从 process 中获取变量</span><span class="keyword">const</span> &#123;  HOST_URL = <span class="string">'http://api.example.com'</span>,  FORM_DESCRIPTION_URL = <span class="string">'http://api-form.example.com/'</span>,  APP_PORT = <span class="number">3333</span>,  ENVIRONMENT_MODE = <span class="string">'dev'</span>,&#125; = process.env;<span class="keyword">const</span> isDev = ENVIRONMENT_MODE === <span class="string">'dev'</span>;<span class="keyword">const</span> server = <span class="keyword">new</span> Koa();<span class="comment">// 打包后的文件的目录</span><span class="keyword">const</span> staticPath = <span class="string">'./dist'</span>;<span class="comment">// 代理白名单</span>server.use(historyApiFallback(&#123; <span class="attr">whiteList</span>: [<span class="string">'/api/*'</span>] &#125;));<span class="comment">// 指向静态文件</span>server.use(<span class="keyword">static</span>(path.join(__dirname, staticPath)));<span class="comment">// proxy 代理</span>server.use(  proxy(<span class="string">'/api/form-descriptions(.*)'</span>, &#123;    target: FORM_DESCRIPTION_URL,    changeOrigin: <span class="literal">true</span>,    logs: <span class="literal">true</span>,    secure: <span class="literal">false</span>,  &#125;),);server.use(  proxy(<span class="string">'/api/(.*)'</span>, &#123;    target: HOST_URL,    changeOrigin: <span class="literal">true</span>,    logs: <span class="literal">true</span>,    secure: <span class="literal">false</span>,  &#125;),);<span class="comment">// 获取本机地址</span><span class="function"><span class="keyword">function</span> <span class="title">getIPAdress</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">const</span> interfaces = os.networkInterfaces();  <span class="keyword">for</span> (<span class="keyword">const</span> devName <span class="keyword">in</span> interfaces) &#123;    <span class="keyword">const</span> iface = interfaces[devName];    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iface.length; i++) &#123;      <span class="keyword">const</span> alias = iface[i];      <span class="keyword">if</span> (alias.family === <span class="string">'IPv4'</span> &amp;&amp; alias.address !== <span class="string">'127.0.0.1'</span> &amp;&amp; !alias.internal) &#123;        <span class="keyword">return</span> alias.address;      &#125;    &#125;  &#125;&#125;<span class="keyword">if</span> (isDev) &#123;  <span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);  <span class="keyword">const</span> compiler = webpack(config);  <span class="comment">// 支持热更新</span>  koaWebpack(&#123;    configPath: path.join(__dirname, <span class="string">'.'</span>, <span class="string">'webpack.dev.config.js'</span>),  &#125;).then(<span class="function">(<span class="params">middleware</span>) =&gt;</span> &#123;    server.use(middleware);    server.listen(APP_PORT, () =&gt; &#123;      <span class="built_in">console</span>.log(<span class="string">`apiHostUrl: <span class="subst">$&#123;HOST_URL&#125;</span>, formDescriptionUrl: <span class="subst">$&#123;FORM_DESCRIPTION_URL&#125;</span>`</span>);      <span class="built_in">console</span>.log(<span class="string">`App running at: http://localhost:<span class="subst">$&#123;APP_PORT&#125;</span>`</span>);      <span class="built_in">console</span>.log(<span class="string">`- Local: http://localhost:<span class="subst">$&#123;APP_PORT&#125;</span>`</span>);      <span class="built_in">console</span>.log(<span class="string">`- Network: http://<span class="subst">$&#123;getIPAdress()&#125;</span>:<span class="subst">$&#123;APP_PORT&#125;</span>`</span>);      <span class="keyword">if</span> (isDev) &#123;        <span class="keyword">switch</span> (process.platform) &#123;          <span class="keyword">case</span> <span class="string">'darwin'</span>:            cp.exec(<span class="string">`open http://localhost:<span class="subst">$&#123;APP_PORT&#125;</span>`</span>);            <span class="keyword">break</span>;          <span class="keyword">case</span> <span class="string">'win32'</span>:            cp.exec(<span class="string">`start http://localhost:<span class="subst">$&#123;APP_PORT&#125;</span>`</span>);            <span class="keyword">break</span>;          <span class="keyword">default</span>:            cp.exec(<span class="string">`open http://localhost:<span class="subst">$&#123;APP_PORT&#125;</span>`</span>);        &#125;      &#125;    &#125;);  &#125;);&#125; <span class="keyword">else</span> &#123;  server.listen(APP_PORT, () =&gt; &#123;    <span class="built_in">console</span>.log(<span class="string">`apiHostUrl: <span class="subst">$&#123;HOST_URL&#125;</span>, formDescriptionUrl: <span class="subst">$&#123;FORM_DESCRIPTION_URL&#125;</span>`</span>);    <span class="built_in">console</span>.log(<span class="string">`App running at: http://localhost:<span class="subst">$&#123;APP_PORT&#125;</span>`</span>);    <span class="built_in">console</span>.log(<span class="string">`- Local: http://localhost:<span class="subst">$&#123;APP_PORT&#125;</span>`</span>);    <span class="built_in">console</span>.log(<span class="string">`- Network: http://<span class="subst">$&#123;getIPAdress()&#125;</span>:<span class="subst">$&#123;APP_PORT&#125;</span>`</span>);  &#125;);&#125;</code></pre><h3 id="编辑-env-文件">编辑 .env 文件</h3><p>.env 文件主要是为了通过配置文件的方式配置变量。</p><pre><code class="highlight bash"><span class="comment"># 端口</span>APP_PORT=3333<span class="comment"># api 接口地址</span>HOST_URL=<span class="string">"http://api.example.com"</span><span class="comment"># 表单配置</span>FORM_DESCRIPTION_URL=<span class="string">"http://api-form.example.com"</span></code></pre><h3 id="启动命令">启动命令</h3><p>再回到 script 命令：</p><pre><code class="highlight json">&#123;  <span class="attr">"scripts"</span>: &#123;    <span class="comment">// 开发模式</span>    <span class="attr">"dev"</span>: <span class="string">"cross-env ENVIRONMENT_MODE=dev env-cmd node index.js"</span>,    <span class="comment">// 生产模式</span>    <span class="attr">"start"</span>: <span class="string">"cross-env ENVIRONMENT_MODE=production env-cmd node index.js"</span>,    <span class="comment">// 打包文件</span>    <span class="attr">"build"</span>: <span class="string">"webpack --config webpack.product.config.js"</span>,    <span class="comment">// 打包 dll 文件</span>    <span class="attr">"build:dll"</span>: <span class="string">"webpack --config webpack.config.dll.js"</span>  &#125;&#125;</code></pre><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读建议&quot;&gt;阅读建议&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;先整体快速阅读一遍，再回头看其中的配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;what？&quot;&gt;What？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通过 npm、webpack、babe
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="Reactjs" scheme="http://www.kavience.com/tags/Reactjs/"/>
    
  </entry>
  
  <entry>
    <title>Mocha单元测试</title>
    <link href="http://www.kavience.com/frontend/mocha-unit-test.html"/>
    <id>http://www.kavience.com/frontend/mocha-unit-test.html</id>
    <published>2019-12-15T06:26:11.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单元测试">什么是单元测试?</h2><p>单元测试( unit testing )，是指对软件中的最小可测试单元进行检查和验证。在前端领域来说，我们主要是针对 JavaScript 的类( class ) 或者方法( function ) 进行单元测试，以增强代码的可靠性和可维护性。下面介绍的是 mocha 单元测试框架。</p><h2 id="mocha-测试框架">mocha 测试框架</h2><p>mocha 是一个测试框架，可以通过 npm 全局安装在本地，或者是局部安装在项目中。</p><pre><code class="highlight bash"><span class="comment"># 全局安装</span>npm i -g mocha<span class="comment"># 局部安装在 dev 环境下</span>npm i --save-dev mocha</code></pre><p>在测试文件中，写入如下代码:</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n, m</span>) </span>&#123;    <span class="keyword">return</span> n + m;&#125;describe(<span class="string">"add"</span>, () =&gt; &#123;    it(<span class="string">'should return 2'</span>, () =&gt; &#123;        <span class="keyword">const</span> count = add(<span class="number">1</span>, <span class="number">1</span>);        <span class="keyword">if</span> ( count !== <span class="number">2</span>) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"1 + 1 应该等于2"</span>)；        &#125;    &#125;);&#125;);</code></pre><p>运行 mocha</p><pre><code class="highlight bash">mocha<span class="comment"># 或</span>./node_modules/.bin/mocha<span class="comment"># 或指定文件</span>./node_modules/.bin/mocha --file ./src/__test__/*.test.js</code></pre><p>mocha 命令常用参数</p><pre><code class="highlight plain">Options:    -h, --help                  输出帮助信息    -V, --version               输出mocha的版本号    -A, --async-only            强制所有的测试用例必须使用callback或者返回一个promise的格式来确定异步的正确性    -c, --colors                在报告中显示颜色    -C, --no-colors             在报告中禁止显示颜色    -g, --growl                 在桌面上显示测试报告的结果    -O, --reporter-options &lt;k&#x3D;v,k2&#x3D;v2,...&gt;  设置报告的基本选项    -R, --reporter &lt;name&gt;       指定测试报告的格式    -S, --sort                  对测试文件进行排序    -b, --bail                  在第一个测试没有通过的时候就停止执行后面所有的测试    -d, --debug                 启用node的debugger功能    -g, --grep &lt;pattern&gt;        用于搜索测试用例的名称，然后只执行匹配的测试用例    -f, --fgrep &lt;string&gt;        只执行测试用例的名称中含有string的测试用例    -gc, --expose-gc            展示垃圾回收的log内容    -i, --invert                只运行不符合条件的测试用例，必须和--grep或--fgrep之一同时运行    -r, --require &lt;name&gt;        require指定模块    -s, --slow &lt;ms&gt;             指定slow的时间，单位是ms，默认是75ms    -t, --timeout &lt;ms&gt;          指定超时时间，单位是ms，默认是200ms    -u, --ui &lt;name&gt;             指定user-interface (bdd|tdd|exports)中的一种    -w, --watch                 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha    --check-leaks               检测全局变量造成的内存泄漏问题    --full-trace                展示完整的错误栈信息    --compilers &lt;ext&gt;:&lt;module&gt;,...  使用给定的模块来编译文件    --debug-brk                 启用nodejs的debug模式    --es_staging                启用全部staged特性    --harmony&lt;_classes,_generators,...&gt;     all node --harmony* flags are available    --preserve-symlinks                     告知模块加载器在解析和缓存模块的时候，保留模块本身的软链接信息    --icu-data-dir                          include ICU data    --inline-diffs              用内联的方式展示actual&#x2F;expected之间的不同    --inspect                   激活chrome浏览器的控制台    --interfaces                展示所有可用的接口    --no-deprecation            不展示warning信息    --no-exit                   require a clean shutdown of the event loop: mocha will not call process.exit    --no-timeouts               禁用超时功能    --opts &lt;path&gt;               定义option文件路径    --perf-basic-prof           启用linux的分析功能    --prof                      打印出统计分析信息    --recursive                 包含子目录中的测试用例    --reporters                 展示所有可以使用的测试报告的名称    --retries &lt;times&gt;           设置对于失败的测试用例的尝试的次数    --throw-deprecation         无论任何时候使用过时的函数都抛出一个异常    --trace                     追踪函数的调用过程    --trace-deprecation         展示追踪错误栈    --use_strict                强制使用严格模式    --watch-extensions &lt;ext&gt;,... --watch监控的扩展    --delay                     异步测试用例的延迟时间    --extension                 指定测试文件后缀    --file                      指定测试文件目录    ...</code></pre><p>除了以上命令参数外，可以输入 <code>mocha -h</code> 查看更多命令参数。更多关于 mocha 的使用，请看<a href="https://mochajs.org/" target="_blank" rel="noopener">文档</a>。</p><h2 id="chai-断言库">chai 断言库</h2><p>为了更友好的显示测试结果，可以使用 chai 断言库:</p><pre><code class="highlight bash"><span class="comment"># 安装 chai</span>npm i --save-dev chai</code></pre><p>使用方法:</p><pre><code class="highlight javascript"><span class="comment">// 这里是 es5 的使用方法，使用 ES6 在下面会讲到</span><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">"chai"</span>).expect;<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n, m</span>) </span>&#123;  <span class="keyword">return</span> n + m;&#125;describe(<span class="string">"add"</span>, () =&gt; &#123;  it(<span class="string">"should return 2"</span>, () =&gt; &#123;    <span class="keyword">const</span> count = add(<span class="number">1</span>, <span class="number">1</span>);    expect(count).to.eqls(<span class="number">2</span>);  &#125;);&#125;);</code></pre><p>更多关于 chai 的使用请看<a href="https://www.chaijs.com/" target="_blank" rel="noopener">文档</a>。</p><h2 id="使用-es6">使用 ES6</h2><p>如果我们要在测试文件中写 ES6 语法的话，需要通过 <code>@babel/register</code> 编译</p><pre><code class="highlight bash"><span class="comment"># 安装 babel</span>npm i @babel/register<span class="comment"># 运行时添加 --require</span>./node_modules/.bin/mocha --require @babel/register --file ./src/__test__/*.js</code></pre><p>这个时候测试文件就可以写 ES6 的语法了</p><pre><code class="highlight javascript"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">"chai"</span>;<span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">"./add"</span>;describe(<span class="string">"add"</span>, () =&gt; &#123;  it(<span class="string">"should return 2"</span>, () =&gt; &#123;    <span class="keyword">const</span> count = add(<span class="number">1</span>, <span class="number">1</span>);    expect(count).to.eqls(<span class="number">2</span>);  &#125;);&#125;);</code></pre><h2 id="使用-sinon-进行截取和模拟函数">使用 sinon 进行截取和模拟函数</h2><p>sinon 提供 stub 和 spy 等函数进行截取和模拟真实函数，以更简单的方式进行测试:</p><pre><code class="highlight javascript"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">"chai"</span>;<span class="keyword">import</span> &#123; stub &#125; <span class="keyword">from</span> <span class="string">"sinon"</span>;<span class="keyword">import</span> calc <span class="keyword">from</span> <span class="string">"./calc"</span>;<span class="comment">// describe 可以嵌套，通常一个测试只测试某一个文件，现在测试 calc 整个文件</span>describe(<span class="string">"calc"</span>, () =&gt; &#123;  <span class="comment">// 最好不要这样直接 stub 要测试的方法，不然还测试什么呢？</span>  decribe(<span class="string">"add"</span>, () =&gt; &#123;    it(<span class="string">"should return 2"</span>, () =&gt; &#123;      calcAddStub = stub(calc, <span class="string">"add"</span>).returns(<span class="number">2</span>); <span class="comment">// 仅仅为了举例</span>      expect(calcAddStub()).to.eqls(<span class="number">2</span>);    &#125;);  &#125;);  <span class="comment">// 还可以通过 resolves 模拟异步操作</span>  decribe(<span class="string">"calc time"</span>, () =&gt; &#123;    it(<span class="string">"should return correct time"</span>, <span class="keyword">async</span> () =&gt; &#123;      <span class="keyword">const</span> calcTimeStub = stub(calc, <span class="string">"add"</span>).resolves(<span class="number">2</span>); <span class="comment">// 仅仅为了举例</span>      <span class="keyword">const</span> count = <span class="keyword">await</span> calcTimeStub();      expect(count).to.eqls(<span class="number">2</span>);    &#125;);  &#125;);&#125;);</code></pre><p>更多关于 sinon 的使用请看<a href="https://sinonjs.org/" target="_blank" rel="noopener">文档</a>。</p><h2 id="使用-enzyme-浅拷贝-react-组件">使用 enzyme 浅拷贝 React 组件</h2><p>如果要测试 React 组件，可以使用 enzyme 进行模拟</p><pre><code class="highlight javascript"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">"chai"</span>;<span class="keyword">import</span> &#123; stub &#125; <span class="keyword">from</span> <span class="string">"sinon"</span>;<span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">"enzyme"</span>;<span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./App"</span>;describe(<span class="string">"App"</span>, () =&gt; &#123;  <span class="keyword">const</span> defaultProps = &#123;    count: <span class="number">1</span>,  &#125;;  <span class="keyword">const</span> render = <span class="function">(<span class="params">props</span>) =&gt;</span> shallow(<span class="xml"><span class="tag">&lt;<span class="name">App</span> &#123;<span class="attr">...props</span>&#125; &#123;<span class="attr">...defaultProps</span>&#125; /&gt;</span></span>);  decribe(<span class="string">"add"</span>, () =&gt; &#123;    it(<span class="string">"should return 2"</span>, () =&gt; &#123;      <span class="keyword">const</span> component = render();      <span class="keyword">const</span> count = component.instance().add(<span class="number">1</span>, <span class="number">1</span>);      expect(count).to.eqls(<span class="number">2</span>);    &#125;);  &#125;);&#125;);</code></pre><p>更多关于 enzyme 的使用请看<a href="https://airbnb.io/enzyme/" target="_blank" rel="noopener">文档</a>。</p><h2 id="使用-istanbul-查看测试覆盖率">使用 Istanbul 查看测试覆盖率</h2><p>一般项目都需要达到某一覆盖率以上，以确保代码的健壮性，可以使用 Istanbul (伊斯坦布尔) 包。</p><pre><code class="highlight bash"><span class="comment"># 安装，Istanbul 包改名了，叫 nyc</span>npm i --save-dev nyc<span class="comment"># 运行</span>./node_modules/.bin/nyc ./node_modules/.bin/mocha --require @babel/register --file ./src/__test__/*.test.js</code></pre><p>运行会重新跑一次测试，并且在当前目录生成 .coverage 目录，可以直接在浏览器打开并且查看覆盖率。</p><p>更多关于 enzyme 的使用请看<a href="https://istanbul.js.org/" target="_blank" rel="noopener">文档</a>。</p><h2 id="结语">结语</h2><p>本篇文章只是简单介绍 js 的单元测试流程，使用的技术包括但不限于 mocha (测试框架), chai (断言库), sinon (截取和模拟函数), enzyme (测试 React 等库), Istanbul (查看覆盖率)。在实际应用中，还需要更多的实际操作，例如测试流程和规范，有的项目中需要测试 渲染的 dom 和 dom 中的属性是否正确，有的仅测试方法，当然还有其他的测试框架例如 jest 等，由于 <s>太懒</s> 篇幅有限，点到为止。</p><p>(done)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是单元测试&quot;&gt;什么是单元测试?&lt;/h2&gt;
&lt;p&gt;单元测试( unit testing )，是指对软件中的最小可测试单元进行检查和验证。在前端领域来说，我们主要是针对 JavaScript 的类( class ) 或者方法( function ) 进行单元测试，
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="mocha" scheme="http://www.kavience.com/tags/mocha/"/>
    
      <category term="单元测试" scheme="http://www.kavience.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Js 进阶之执行上下文和执行栈</title>
    <link href="http://www.kavience.com/frontend/js-advanced-execution-context-and-stack.html"/>
    <id>http://www.kavience.com/frontend/js-advanced-execution-context-and-stack.html</id>
    <published>2019-10-19T02:50:06.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-javascript-执行上下文？">什么是 JavaScript 执行上下文？</h2><blockquote><p>执行上下文是评估和执行 JavaScript 代码的环境的抽象概念，Javascript 代码都是在执行上下文中运行。</p></blockquote><h2 id="什么是-javascript-执行栈？">什么是 JavaScript 执行栈？</h2><blockquote><p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。<br>首次运行 JS 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。<br>根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文控制权将移到当前执行栈的下一个执行上下文。</p></blockquote><h2 id="执行上下文的类型">执行上下文的类型</h2><p>执行上下文总共有三种类型</p><ul><li>全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，nodejs 中的全局对象就是 module 对象, this 指向这个全局对象。</li><li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</li><li>Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用。</li></ul><h2 id="执行上下文的创建">执行上下文的创建</h2><p>执行上下文分两个阶段创建：</p><ol><li>创建阶段</li><li>执行阶段</li></ol><h3 id="创建阶段">创建阶段</h3><p>1、确定 this 的值，也被称为 This Binding。<br>2、LexicalEnvironment（词法环境） 组件被创建。<br>3、VariableEnvironment（变量环境） 组件被创建。</p><h4 id="this-binding">This Binding</h4><ul><li>全局执行上下文中， this 的值指向全局对象，在浏览器中 this 的值指向 window 对象，而在 nodejs 中指向这个文件的 module 对象。</li><li>函数执行上下文中， this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new 绑定、箭头函数等，详情请看<a href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">函数执行上下文</a></li></ul><h4 id="词法环境-lexical-environment">词法环境（Lexical Environment）</h4><p>词法环境有两个组成部分</p><ol><li><p>环境记录：存储变量和函数声明的实际位置</p></li><li><p>对外部环境的引用：可以访问其外部词法环境</p></li></ol><p>词法环境有两种类型</p><ol><li><p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null 。拥有一个全局对象（ window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量， this 的值指向这个全局对象。</p></li><li><p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p></li></ol><h4 id="变量环境">变量环境</h4><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，词法环境和变量环境的区别在于前者用于存储 <strong>函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）</strong> 绑定。</p><blockquote><p><strong>变量提升</strong>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p></blockquote><pre><code class="highlight javascript">foo(); <span class="comment">// foo2</span><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">"foo1"</span>);&#125;;foo(); <span class="comment">// foo1，foo重新赋值</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">"foo2"</span>);&#125;foo(); <span class="comment">// foo1</span></code></pre><p><strong>注意：</strong> 函数声明优先级高于变量声明，同一作用域下存在多个同名函数声明，后面的会替换前面的函数声明。</p><h3 id="执行阶段">执行阶段</h3><p>此阶段，完成对所有变量的分配，最后执行代码。</p><p>如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。</p><h2 id="执行上下文栈">执行上下文栈</h2><p>因为 JS 引擎创建了很多的执行上下文，所以 JS 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p><p>当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext 。</p><p>观察以下两段代码：</p><pre><code class="highlight javascript"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;<span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> scope;  &#125;  <span class="keyword">return</span> f();&#125;checkscope();</code></pre><pre><code class="highlight javascript"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;<span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> scope;  &#125;  <span class="keyword">return</span> f;&#125;checkscope()();</code></pre><p>它们的运行结果是一样的，但执行上下文栈的变化不一样。<br>第一段代码：</p><pre><code class="highlight javascript">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">checkscope</span>&gt;</span> functionContext);</span>ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();</code></pre><p>第二段代码：</p><pre><code class="highlight javascript">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">checkscope</span>&gt;</span> functionContext);</span><span class="xml">ECStack.pop();</span>ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h2 id="函数执行上下文">函数执行上下文</h2><p>上面提到过<a href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%B1%BB%E5%9E%8B">执行上下文的类型</a>有全局执行上下文和函数执行上下文。</p><p>在函数上下文中，用活动对象( activation object, AO )来表示变量对象。</p><p>活动对象和变量对象的区别在于</p><p>1、变量对象（ VO ）是规范上或者是 JS 引擎上实现的，并不能在 JS 环境中直接访问。<br>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（ AO ），这时候活动对象上的各种属性才能被访问。<br>调用函数时，会为其创建一个 Arguments 对象，并自动初始化局部变量 arguments ，指代该 Arguments 对象。所有作为参数传入的值都会成为 Arguments 对象的数组元素。</p><h3 id="执行过程">执行过程</h3><p>执行上下文的代码会分成两个阶段进行处理</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><h4 id="进入执行上下文">进入执行上下文</h4><p>很明显，这个时候还没有执行代码，此时的变量对象会包括（如下顺序初始化）：</p><ol><li><strong>函数的所有形参 ( only 函数上下文)</strong>：没有实参，属性值设为 undefined 。</li><li><strong>函数声明</strong>：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</li><li><strong>变量声明</strong>：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</li></ol><h4 id="代码执行">代码执行</h4><p>这个阶段会顺序执行代码，修改变量对象的值，执行完成后 AO 如下</p><h3 id="总结如下：">总结如下：</h3><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ol><p>(done)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-javascript-执行上下文？&quot;&gt;什么是 JavaScript 执行上下文？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;执行上下文是评估和执行 JavaScript 代码的环境的抽象概念，Javascript 代码都是在执行上下文中运行。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="frontend" scheme="http://www.kavience.com/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://www.kavience.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.kavience.com/think/hello-world.html"/>
    <id>http://www.kavience.com/think/hello-world.html</id>
    <published>2019-10-16T15:02:43.000Z</published>
    <updated>2021-05-18T07:51:15.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hello-world">Hello World</h2><p>试过各种各样的博客搭建平台，最终还是决定依托 HEXO 搭建，我觉得我的博客不需要有多少多复杂的功能，只需要简单清新一点就好了。</p><h2 id="目的">目的</h2><p>做事总是带点目的性，个人博客于我而言，就像是网络上的一个家，这是属于自己的地盘，在网络上有了归属感，我想写点什么、记录点什么，都是自己决定。</p><p>希望能一直纯粹下去。^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;p&gt;试过各种各样的博客搭建平台，最终还是决定依托 HEXO 搭建，我觉得我的博客不需要有多少多复杂的功能，只需要简单清新一点就好了。&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;目的&lt;/h2&gt;
&lt;p&gt;做事总是带点目
      
    
    </summary>
    
    
      <category term="think" scheme="http://www.kavience.com/categories/think/"/>
    
    
      <category term="开始" scheme="http://www.kavience.com/tags/%E5%BC%80%E5%A7%8B/"/>
    
  </entry>
  
</feed>
