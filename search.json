[{"title":"Git常用命令记录","url":"/tools/git-common-command-record.html","content":"<h2 id=\"what\">what</h2>\n<p>一篇关于 Git 常用命令的记录文章。</p>\n<h2 id=\"why\">why</h2>\n<p>Git 在工作中成了必不可少的工具，个人比较喜欢使用 Git 命令，但是 Git 命令其实比较繁杂，有点难记，例如 <code>rebase</code>, <code>reset</code> 等，只要不用的时间久了，就会忘记。所以特此记录。</p>\n<h2 id=\"how\">how</h2>\n<h3 id=\"git-clone\">git clone</h3>\n<p>用法： <code>git clone [&lt;options&gt;] [--] &lt;repo&gt; [&lt;dir&gt;]</code></p>\n<p>作用： 克隆一个仓库到本地</p>\n<p>常用：</p>\n<ul>\n<li>-b\n<ul>\n<li>克隆指定分支： <code>git clone -b test git@github.com:kavience/blog.git</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-status\">git status</h3>\n<p>用法： <code>git status [&lt;options&gt;] [--] &lt;pathspec&gt;...</code></p>\n<p>作用： 查看暂存区</p>\n<p>常用：</p>\n<ul>\n<li>s\n<ul>\n<li>简要显示暂存区</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-add\">git add</h3>\n<p>用法： <code>git add [&lt;options&gt;] [--] &lt;pathspec&gt;...</code></p>\n<p>作用： 添加修改（包括添加、删除、修改等操作）到暂存区</p>\n<p>常用：</p>\n<ul>\n<li>A\n<ul>\n<li>添加所有修改到暂存区，等同于 <code>git add .</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-log\">git log</h3>\n<p>用法： <code>git log [&lt;options&gt;] [&lt;revision-range&gt;] [[--] &lt;path&gt;...]</code></p>\n<p>作用： 查看日志</p>\n<p>常用：</p>\n<ul>\n<li>统计个人代码量\n<ul>\n<li><code>git log --author=&quot;username&quot; --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc }' -</code></li>\n</ul>\n</li>\n<li>统计所有人增删行数\n<ul>\n<li><code>git log --format='%aN' | sort -u | while read name; do echo -en &quot;$name\\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc }' -; done</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-commit\">git commit</h3>\n<p>用法： <code>git commit [&lt;options&gt;] [--] &lt;pathspec&gt;...</code></p>\n<p>作用： 提交暂存区里面的修改，并生成一个唯一的 commit 号</p>\n<p>常用：</p>\n<h3 id=\"git-push\">git push</h3>\n<p>用法： <code>git push [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;...]]</code></p>\n<p>作用： 上传当前仓库的 commit 到远程仓库地址</p>\n<p>常用：</p>\n<ul>\n<li>上传一个远程仓库不存在的分支\n<ul>\n<li><code>git push --set-upstream [origin] [branch]</code></li>\n</ul>\n</li>\n<li>强制上传，会强制替换远程仓库（<code>慎用！！！</code>）\n<ul>\n<li><code>git push -f [origin] [branch]</code></li>\n</ul>\n</li>\n<li>上传 tag 到仓库\n<ul>\n<li><code>git push [origin] [tag name]</code></li>\n<li><code>git push [origin] --tags</code> 上传所有 tag</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-fetch\">git fetch</h3>\n<p>用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;...]]</span><br><span class=\"line\">   or: git fetch [&lt;options&gt;] &lt;group&gt;</span><br><span class=\"line\">   or: git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)...]</span><br><span class=\"line\">   or: git fetch --all [&lt;options&gt;]</span><br></pre></td></tr></table></figure>\n<p>作用： 拉取远程分支</p>\n<p>常用：</p>\n<ul>\n<li>拉取指定远程分支\n<ul>\n<li><code>git fetch [origin] [branch]</code></li>\n</ul>\n</li>\n<li>拉取所有分支\n<ul>\n<li><code>git fetch --all</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-merge\">git merge</h3>\n<p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git merge [&lt;options&gt;] [&lt;commit&gt;...]</span><br><span class=\"line\">   or: git merge --abort</span><br><span class=\"line\">   or: git merge --continue</span><br></pre></td></tr></table></figure>\n<p>作用： 合并分支</p>\n<p>常用：</p>\n<ul>\n<li>合并指定分支到当前分支\n<ul>\n<li><code>git merge [target_branch]</code></li>\n</ul>\n</li>\n<li>当有冲突的时候，继续合并（必须先解决冲突）\n<ul>\n<li><code>git merge --continue</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-pull\">git pull</h3>\n<p>用法： <code>git pull [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;...]]</code></p>\n<p>作用： 拉取远程分支并与本地分支合并</p>\n<p>常用：</p>\n<ul>\n<li>本地分支与远程分支合并\n<ul>\n<li><code>git pull origin [origin_branch]:[local_branch]</code></li>\n<li>如果本地分支与远程分支存在跟踪关系，可以直接使用  <code>git pull origin [branch]</code> ，建立跟踪关系可以使用 <code>git branch --set-upstream [local_branch] origin/[origin_branch]</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-branch\">git branch</h3>\n<p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch [&lt;options&gt;] [-r | -a] [--merged | --no-merged]</span><br><span class=\"line\">   or: git branch [&lt;options&gt;] [-l] [-f] &lt;branch-name&gt; [&lt;start-point&gt;]</span><br><span class=\"line\">   or: git branch [&lt;options&gt;] [-r] (-d | -D) &lt;branch-name&gt;...</span><br><span class=\"line\">   or: git branch [&lt;options&gt;] (-m | -M) [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class=\"line\">   or: git branch [&lt;options&gt;] (-c | -C) [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class=\"line\">   or: git branch [&lt;options&gt;] [-r | -a] [--points-at]</span><br><span class=\"line\">   or: git branch [&lt;options&gt;] [-r | -a] [--format]</span><br></pre></td></tr></table></figure>\n<p>作用： 查看、新建、删除、跟踪等操作分支</p>\n<p>常用：</p>\n<ul>\n<li>查看本地所有分支\n<ul>\n<li><code>git branch</code></li>\n<li><code>git branch -v</code> 带最后一次 commit</li>\n</ul>\n</li>\n<li>建立新分支\n<ul>\n<li><code>git branch [branch_name]</code></li>\n</ul>\n</li>\n<li>删除分支\n<ul>\n<li><code>git branch -d [branch]</code></li>\n<li><code>git branch -D [branch]</code> 强制删除，丢弃修改（慎用！！！）</li>\n</ul>\n</li>\n<li>本地分支和远程分支建立跟踪关系\n<ul>\n<li><code>git branch --set-upstream [local_branch] origin/[origin_branch]</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-checkout\">git checkout</h3>\n<p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout [&lt;options&gt;] &lt;branch&gt;</span><br><span class=\"line\">   or: git checkout [&lt;options&gt;] [&lt;branch&gt;] -- &lt;file&gt;...</span><br></pre></td></tr></table></figure>\n<p>作用： 切换分支、 tag 、 commit ，或创建且切换到新分支</p>\n<p>常用：</p>\n<ul>\n<li>切换分支或指定 commit ，或者指定 tag\n<ul>\n<li><code>git checkout [branch|commit|tag]</code></li>\n</ul>\n</li>\n<li>创建新分支，且切换到该分支\n<ul>\n<li><code>git checkout -b [branch]</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-stash\">git stash</h3>\n<p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git stash list [&lt;options&gt;]</span><br><span class=\"line\">   or: git stash show [&lt;options&gt;] [&lt;stash&gt;]</span><br><span class=\"line\">   or: git stash drop [-q|--quiet] [&lt;stash&gt;]</span><br><span class=\"line\">   or: git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]</span><br><span class=\"line\">   or: git stash branch &lt;branchname&gt; [&lt;stash&gt;]</span><br><span class=\"line\">   or: git stash clear</span><br><span class=\"line\">   or: git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class=\"line\">          [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]</span><br><span class=\"line\">          [--] [&lt;pathspec&gt;...]]</span><br><span class=\"line\">   or: git stash save [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class=\"line\">          [-u|--include-untracked] [-a|--all] [&lt;message&gt;]</span><br></pre></td></tr></table></figure>\n<p>作用： 暂存和恢复进度</p>\n<p>常用：</p>\n<ul>\n<li>查看所有暂存的进度\n<ul>\n<li><code>git stash list</code></li>\n</ul>\n</li>\n<li>暂存当前修改\n<ul>\n<li><code>git stash</code></li>\n</ul>\n</li>\n<li>恢复进度\n<ul>\n<li><code>git stash apply</code> 恢复最近的一次进度</li>\n<li><code>git stash apply [stash]</code> 恢复指定的进度</li>\n<li><code>git stash drop [stash]</code> 删除该进度</li>\n<li><code>git stash pop [stash]</code> 恢复指定的进度并删除该进度</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-rebase\">git rebase</h3>\n<p>用法： <code>git commit [&lt;options&gt;] [--] &lt;pathspec&gt;...</code></p>\n<p>作用： 合并多次 commit 、分支合并、保持一个简洁的 commit 信息</p>\n<p>常用：</p>\n<ul>\n<li>合并多次 commit\n<ul>\n<li><code>git rebase -i HEAD~[n]</code> n 为 commit 次数</li>\n</ul>\n</li>\n<li>分支合并\n<ul>\n<li><code>git rebase [branch]</code>  合并分支到当前分支，和 merge 不一样的是不会产生 commit 信息，确保当前分支是只有本人使用，否则可能会产生丢失别人的 commit 信息。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git-reset\">git reset</h3>\n<p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</span><br><span class=\"line\">   or: git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;...</span><br><span class=\"line\">   or: git reset --patch [&lt;tree-ish&gt;] [--] [&lt;paths&gt;...]</span><br><span class=\"line\"></span><br><span class=\"line\">    -q, --quiet           be quiet, only report errors</span><br><span class=\"line\">    --mixed               reset HEAD and index</span><br><span class=\"line\">    --soft                reset only HEAD</span><br><span class=\"line\">    --hard                reset HEAD, index and working tree</span><br><span class=\"line\">    --merge               reset HEAD, index and working tree</span><br><span class=\"line\">    --keep                reset HEAD but keep local changes</span><br><span class=\"line\">    --recurse-submodules[&#x3D;&lt;reset&gt;]</span><br><span class=\"line\">                          control recursive updating of submodules</span><br><span class=\"line\">    -p, --patch           select hunks interactively</span><br><span class=\"line\">    -N, --intent-to-add   record only the fact that removed paths will be added later</span><br></pre></td></tr></table></figure>\n<p>作用： 回滚到某个 commit</p>\n<p>常用：</p>\n<ul>\n<li>软回滚，保留文件修改，硬回滚，丢失文件修改\n<ul>\n<li><code>git reset --[soft|hard] HEAD</code> 最近一次，等同于 <code>git reset --[soft|hard] HEAD~0</code></li>\n<li><code>git reset --[soft|hard] HEAD^</code> 上一次，等同于 <code>git reset --[soft|hard] HEAD~1</code></li>\n<li><code>git reset --[soft|hard] HEAD^^</code> 上两次，等同于 <code>git reset --[soft|hard] HEAD~2</code></li>\n<li><code>git reset --[soft|hard] HEAD^n^</code> 上n次，等同于 <code>git reset --[soft|hard] HEAD~n</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>这只是个人工作中总结常用的一些命令，并不全面，会持续更新。</p>\n<p>（完）</p>\n","categories":["tools"],"tags":["git"]},{"title":"Js-彻底了解This的指向","url":"/front-end/js-thoroughly-understand-the-point-of-this.html","content":"<h2 id=\"起因\">起因</h2>\n<p>对 js 的 this 指向问题还是会有点模糊，我决定下点功夫，写下这篇文章，彻底把 this 搞明白。</p>\n<h2 id=\"什么是-this-？\">什么是 this ？</h2>\n<p>这也是我发出的第一个问题，究竟什么是 this ？在 js 中 this 代表的到底是什么？根据 <a href=\"https://www.w3schools.com/js/js_this.asp\" target=\"_blank\" rel=\"noopener\">w3c</a> 的描述：</p>\n<blockquote>\n<p>The JavaScript this keyword refers to the object it belongs to.</p>\n</blockquote>\n<blockquote>\n<p>在 js 中 this 关键字代表它所属对象的引用。</p>\n</blockquote>\n<p>再根据 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"noopener\">MDN</a> 的描述，</p>\n<blockquote>\n<p>In the global execution context (outside of any function), this refers to the global object whether in strict mode or not.</p>\n</blockquote>\n<blockquote>\n<p>this 表示当前执行上下文( global、function 或 eval )的一个属性，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值。</p>\n</blockquote>\n<p>由此可见 this 的指向是不确定的，是在运行时确定的，而且 this 在不同的情况下，其代表的含义也不一样。</p>\n<p>下面我将通过本文，彻底分析 this 的所有形式。</p>\n<blockquote>\n<p>注：全局对象，在浏览器端代表 window 对象，在 nodejs 环境下代表 global 对象，以下不再区分，简称全局对象。</p>\n</blockquote>\n<h2 id=\"this-存在的情形\">this 存在的情形</h2>\n<p>首先要考虑 this 一般会出现在哪些情况呢？</p>\n<ol>\n<li>全局状态下</li>\n<li>一般函数内</li>\n<li>this 和对象转换</li>\n<li>原型链中</li>\n<li>与 DOM 相关</li>\n</ol>\n<p>其实 this 一般都是出现在函数内，所以在第六点单独称之为 「一般函数」，下面分别分析。</p>\n<h3 id=\"全局状态下\">全局状态下</h3>\n<p>无论是否在严格模式下，在全局执行环境中(在任何函数体外部) this 都指向<code>全局对象</code>。如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// 全局对象</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"一般函数内\">一般函数内</h3>\n<p>在全局状态下、对象内、class 内等的函数，我称之为一般函数，也是使用最多的情况。</p>\n<h4 id=\"函数在全局状态下\">函数在全局状态下</h4>\n<p><code>在普通函数内部，this 的值取决于函数被调用的方式。</code>在严格模式下，如果进入执行环境时没有设置 this 的值，this 会保持为 undefined，非严格模式下指向全局对象。</p>\n<p><code>在箭头函数中，this 取决于函数被创建时的环境。</code>因此在全局情况下，无论是否为严格模式，this 指向都是全局对象。</p>\n<p>请务必记住以上重点标记的两句话，在很多地方也都用到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> f4 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> f5 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">f2(); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">f3(); <span class=\"comment\">// 全局对象</span></span><br><span class=\"line\">f4(); <span class=\"comment\">// 全局对象</span></span><br><span class=\"line\">f5(); <span class=\"comment\">// 全局对象</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"函数在对象内部\">函数在对象内部</h4>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  type: <span class=\"number\">1</span>,</span><br><span class=\"line\">  func1: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  func2: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.func1(); <span class=\"comment\">// obj</span></span><br><span class=\"line\">obj.func2(); <span class=\"comment\">// 全局对象</span></span><br><span class=\"line\"><span class=\"comment\">// 把 func1，func2 单独拿出来调用，在当前情况下等同于全局状态下的调用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; func1, func2 &#125; = obj;</span><br><span class=\"line\">func1(); <span class=\"comment\">// 全局对象</span></span><br><span class=\"line\">func2(); <span class=\"comment\">// 全局对象</span></span><br></pre></td></tr></table></figure>\n<p>在严格模式下再运行一遍</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  type: <span class=\"number\">1</span>,</span><br><span class=\"line\">  func1: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  func2: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.func1(); <span class=\"comment\">// obj</span></span><br><span class=\"line\">obj.func2(); <span class=\"comment\">// 全局对象</span></span><br><span class=\"line\"><span class=\"comment\">// 把 func1，func2 单独拿出来调用，在当前情况下等同于全局状态下的调用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; func1, func2 &#125; = obj;</span><br><span class=\"line\">func1(); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">func2(); <span class=\"comment\">// 全局对象</span></span><br></pre></td></tr></table></figure>\n<p>当作为对象的函数时，this 的绑定只受最接近的成员引用的影响。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">independent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.prop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> independent2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.prop;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  prop: <span class=\"number\">37</span>,</span><br><span class=\"line\">  func1: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.prop;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  func2: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.prop;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.func3 = independent;</span><br><span class=\"line\">obj.func4 = independent2;</span><br><span class=\"line\">obj.child = &#123; <span class=\"attr\">func5</span>: independent, <span class=\"attr\">func6</span>: independent2, <span class=\"attr\">prop</span>: <span class=\"number\">42</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.func1()); <span class=\"comment\">// 37</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.func2()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.func3()); <span class=\"comment\">// 37</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.func4()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.child.func5()); <span class=\"comment\">// 42</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.child.func6()); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"函数在-class-内\">函数在 class 内</h4>\n<p>this 在类中的表现与在函数中类似，因为类本质上也是函数，但也有一些区别和注意事项。在类的构造函数中，this 是一个常规对象。<code>类中所有非静态的方法都会被添加到 this 的原型中</code>。</p>\n<p>和其他普通函数一样，类方法中的 this 值取决于它们如何被调用。需要注意的是类内部<code>总是严格模式</code>。类的方法内部如果含有 this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> </span>&#123;</span><br><span class=\"line\">  normalFunction() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"normal function:\"</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  arrowFunction = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"arrow function:\"</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> t = <span class=\"keyword\">new</span> TestClass();</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; normalFunction, arrowFunction &#125; = t;</span><br><span class=\"line\">normalFunction(); <span class=\"comment\">// normal function: undefined</span></span><br><span class=\"line\">arrowFunction(); <span class=\"comment\">// arrow function: TestClass &#123;arrowFunction: ƒ&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在上面代码中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; normalFunction, arrowFunction &#125; = t;</span><br></pre></td></tr></table></figure>\n<p>其实相当于如下代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalFunction2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"normal function:\"</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为普通函数的 this 是由调用者确定的，如果在非严格模式下，直接调用，则 this 指向全局对象，如果是严格模式下，this 则为 undefined。而箭头函数是由创建时就确定了，所以 arrowFunction 实际指向的仍是 TestClass 实例。</p>\n<p>有时，也可以通过 bind 方法使类中的 this 值总是指向这个类实例。为了做到这一点，可在构造函数中绑定类方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意 bind 和无 bind 的区别</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sayBye = <span class=\"keyword\">this</span>.sayBye.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayHi() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello from <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayBye() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Bye from <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Ferrari\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Tweety\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> car = <span class=\"keyword\">new</span> Car();</span><br><span class=\"line\"><span class=\"keyword\">const</span> bird = <span class=\"keyword\">new</span> Bird();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class 中方法的调用取决于调用者</span></span><br><span class=\"line\">car.sayHi(); <span class=\"comment\">// Hello from Ferrari</span></span><br><span class=\"line\">bird.sayHi = car.sayHi;</span><br><span class=\"line\">bird.sayHi(); <span class=\"comment\">// Hello from Tweety</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于已绑定的函数，this 就不在依赖调用者</span></span><br><span class=\"line\">bird.sayBye = car.sayBye;</span><br><span class=\"line\">bird.sayBye(); <span class=\"comment\">// Bye from Ferrari</span></span><br></pre></td></tr></table></figure>\n<p>在派生类中的构造函数没有初始的 this 绑定。在构造函数中调用 <code>super()</code> 会生成一个 this 绑定。所以在子类的构造函数中，如果要使用 this 的话必须要调用 <code>super()</code> ，相当于 <code>this = new Base();</code>。派生类不能在调用 super() 之前返回，除非其构造函数返回的是一个对象，或者根本没有构造函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Good</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlsoGood</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">a</span>: <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bad</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Good();</span><br><span class=\"line\"><span class=\"keyword\">new</span> AlsoGood();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Bad(); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>更多关于 class 的内容可以查看阮一峰老师<a href=\"https://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"noopener\">关于 class 的说明</a></p>\n<h4 id=\"改变-this-指向\">改变 this 指向</h4>\n<p>通过函数的 call, apply, bind 方法是可以改变 this 的指向的，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"string\">\"Custom\"</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"Global\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ECMAScript 5 引入了 Function.prototype.bind()。调用 f.bind(someObject)会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> func2 = func1.bind(obj);</span><br><span class=\"line\">func1(obj);</span><br><span class=\"line\">func1.call(obj);</span><br><span class=\"line\">func1.apply(obj);</span><br><span class=\"line\">func2(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意：如果将this传递给call、bind、或者apply来调用箭头函数，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数(thisArg)应该设置为null。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"this-和对象转换\">this 和对象转换</h3>\n<p>在非严格模式下使用 call 和 apply 时，如果用作 this 的值不是对象，则会被尝试转换为对象。null 和 undefined 被转换为全局对象。原始值如 7 或 ‘foo’ 会使用相应构造函数转换为对象。因此 7 会被转换为 new Number(7) 生成的对象，字符串 ‘foo’ 会转换为 new String(‘foo’) 生成的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非严格模式下</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处也属于函数内的 this ，下面会继续分析</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar.call(<span class=\"number\">7</span>); <span class=\"comment\">// Number &#123;7&#125;</span></span><br><span class=\"line\">bar.call(<span class=\"string\">\"foo\"</span>); <span class=\"comment\">// String &#123;\"foo\"&#125;</span></span><br><span class=\"line\">bar.call(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 全局对象</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 严格模式下</span></span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar.call(<span class=\"number\">7</span>); <span class=\"comment\">// 7</span></span><br><span class=\"line\">bar.call(<span class=\"string\">\"foo\"</span>); <span class=\"comment\">// foo</span></span><br><span class=\"line\">bar.call(<span class=\"literal\">undefined</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>ECMAScript 5 引入了 <code>Function.prototype.bind()</code> 。调用 f.bind(someObject)会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f.bind(&#123; <span class=\"attr\">a</span>: <span class=\"string\">\"azerty\"</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g()); <span class=\"comment\">// azerty</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> h = g.bind(&#123; <span class=\"attr\">a</span>: <span class=\"string\">\"yoo\"</span> &#125;); <span class=\"comment\">// bind只生效一次！</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(h()); <span class=\"comment\">// azerty</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>: <span class=\"number\">37</span>, <span class=\"attr\">f</span>: f, <span class=\"attr\">g</span>: g, <span class=\"attr\">h</span>: h &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.a, o.f(), o.g(), o.h()); <span class=\"comment\">// 37, 37, azerty, azerty</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"原型链中\">原型链中</h3>\n<p>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。虽然最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p 。也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p 。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  f: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"keyword\">this</span>.b;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">Object</span>.create(o);</span><br><span class=\"line\">p.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">p.b = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.f()); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"keyword\">this</span>.b + <span class=\"keyword\">this</span>.c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span>,</span><br><span class=\"line\">  c: <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> average() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.a + <span class=\"keyword\">this</span>.b + <span class=\"keyword\">this</span>.c) / <span class=\"number\">3</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o, <span class=\"string\">\"sum\"</span>, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: sum,</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">  configurable: true,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(o.average, o.sum); // 2, 6</span><br></pre></td></tr></table></figure>\n<h3 id=\"与-dom-相关\">与 DOM 相关</h3>\n<p>当函数被用作事件处理函数时，它的 this 指向触发事件的元素(一些浏览器在使用非 addEventListener 的函数动态地添加监听函数时不遵守这个约定)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被调用时，将关联的元素变成蓝色</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bluify</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === e.currentTarget); <span class=\"comment\">// 总是 true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 当 currentTarget 和 target 是同一个对象时为 true</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === e.target);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.style.backgroundColor = <span class=\"string\">\"#A5D9F3\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取文档中的所有元素的列表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> elements = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class=\"line\">  elements[i].addEventListener(<span class=\"string\">\"click\"</span>, bluify, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当代码被内联 on-event 处理函数 调用时，它的 this 指向监听器所在的 DOM 元素：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"alert(this.tagName.toLowerCase());\"</span>&gt;</span>Show this<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 在下面这种情况下，没有设置内部函数的 this，所以它指向 global/window 对象(即非严格模式下调用的函数未设置 this 时指向的默认对象)。 --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"alert((function()&#123;return this&#125;)());\"</span>&gt;</span>Show inner this<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\">最后</h2>\n<p>分析一道题</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  prop = &#123;</span><br><span class=\"line\">    func1: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    func2: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> t = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\">t.prop.func1(); <span class=\"comment\">// object prop</span></span><br><span class=\"line\">t.prop.func2(); <span class=\"comment\">// object t</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; prop &#125; = t;</span><br><span class=\"line\">prop.func1(); <span class=\"comment\">// object prop</span></span><br><span class=\"line\">prop.func2(); <span class=\"comment\">// t</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; func1, func2 &#125; = prop;</span><br><span class=\"line\">func1(); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">func2(); <span class=\"comment\">// t</span></span><br></pre></td></tr></table></figure>\n<p>答案已经公布，想想为什么呢？</p>\n","categories":["front-end"],"tags":["JavaScript"]},{"title":"Web前端优化总结","url":"/front-end/summary-of-web-frontend-optimization.html","content":"<h2 id=\"what\">What</h2>\n<p>针对 web 前端优化方案的总结, 主要技术栈为 React。</p>\n<h2 id=\"why\">Why</h2>\n<p>与以往 PHP, JSP 等服务端渲染不同, 现如今大多数 web 端采用 React, Vue, Angular 等客户端渲染方案。单页应用带来的好处是显而易见的, 前端开发人员可以专注于前端页面的交互, 后端人员专注于数据的处理, 分工明确。另一方面得益于 nodejs 的生态, 例如 npm 包管理, webpack, gulp 打包等, 前端开发人员可以避免重复造轮子, 开发也变得越来越迅速。然而单页应用也带来另一个问题, 随着引入的库越来越多, 项目也越来越臃肿, 页面加载速度奇慢无比, 本文主要讨论针对 webpack 手动搭建的 React 项目为例做优化。</p>\n<h2 id=\"how\">How</h2>\n<p>首先简单罗列一下 web 开发中可以优化的点有哪些:</p>\n<ul>\n<li>引入 CDN 资源, 图片、视频等大文件资源也可以通过 oss 等其它方式引入;</li>\n<li>图片、icon 等使用 SVG;</li>\n<li>样式优化( style-loader, mini css );</li>\n<li>代码优化(减少 re-render 次数);</li>\n<li>文件开启 GZip 压缩( Nodejs, Nginx );</li>\n<li>代码拆分( webpack DllPlugin, webpack splitChunks, React.lazy );</li>\n<li>客户端缓存( Cache-Control )。</li>\n</ul>\n<p>下面依次讲解。</p>\n<h3 id=\"cdn-资源引入\">CDN 资源引入</h3>\n<p>这是最简单粗暴的, 打包后的资源文件, 如果不做任何优化, 大部分项目中压缩后的 vender.xxx.js 文件, 大概会有 5-8 M,在国内采用 CDN 加载, 时间大概 1 - 2 s 左右, 在次基础上, 还可以进行 GZip 压缩, 以 <a href=\"https://help.aliyun.com/knowledge_detail/39645.html\" target=\"_blank\" rel=\"noopener\">阿里 oss</a> 为例子, 采用 GZip 压缩后的资源, 大小会差不多减少三分之二, 访问时间会在 1 秒左右, 如果对项目访问速度要求不高, 这完全足够了。</p>\n<p>另外, 例如图片、视频、音频等大文件, 肯定是要采用 CDN 的, 可能还要引入流的概念, 这里就不累述了(关键我也不熟悉)。</p>\n<h3 id=\"图片-icon-等使用-svg\">图片、icon 等使用 SVG</h3>\n<p>SVG 的优势(来源谷歌):</p>\n<ul>\n<li>SVG 图像可通过文本编辑器来创建和修改；</li>\n<li>SVG 图像可被搜索、索引、脚本化或压缩；</li>\n<li>SVG 是可伸缩的；</li>\n<li>SVG 图像可在任何的分辨率下被高质量地打印；</li>\n<li>SVG 可在图像质量不下降的情况下被放大；</li>\n</ul>\n<p>另外还有些个人认为的优势, SVG 可以做动画, 可以嵌入 HTML 文件, 减少 HTTP 请求。</p>\n<h3 id=\"样式优化-style-loader-mini-css\">样式优化( style-loader, mini css )</h3>\n<p>针对样式, 大部分项目中会使用 less,sass 或者 stylus, 通过 <code>less-loader</code>, <code>sass-loader</code> 等各种 loader, 最后基本有两种方案, 一是通过 <code>css-loader</code> 和 <code>style-loader</code> 把生成后的样式嵌入 HTML, 作为 style 标签引入, 另一种是通过 <code>css-loader</code> 和 <code>miniCssExtractPlugin</code> 生成压缩后的 css 引入。两种方式我觉得都没什么问题, 差不多, 但我更喜欢后者。嵌入到 HTML 可以减少 HTTP 请求, 但是压缩后的样式再经过 GZip 压缩其实也就几十毫秒左右。</p>\n<h3 id=\"代码优化-减少-re-render-次数\">代码优化(减少 re-render 次数)</h3>\n<p>代码优化根据项目采用的框架不同, 优化方案也不同, 但万变不离其宗, 主要是减少重渲染次数。</p>\n<p>以 React 为例, 减少 <code>componentWillReceiveProps</code> , 使用 hooks 等, 注意 state 的值, 注意什么时候该用 props, 什么时候该用 state。props 和 state 的改变都会引起 re-render , 我的总结就是: 「 在组件中, 这个值会经常改变, 再<code>考虑</code>把这个值设为 state 。」 其实也不一定准确, 还是得看具体情况, 比如, <code>editable</code>, <code>visible</code> 等这类表示某些状态的, 大多数时候都作为 state, 但也有例外, 比如 <code>loading</code>, 业务不一样, 可能在会引入 <code>redux</code> 全局状态, 在发生 HTTP 请求的时候, 设置 <code>loading</code> 为 true, 组件可以从全局去拿这个状态值。</p>\n<h3 id=\"文件开启-gzip-压缩-nodejs-nginx-等\">文件开启 GZip 压缩( Nodejs, Nginx 等 )</h3>\n<p>GZip 在上述方案中多次提到, 如果你不想使用 CDN, 就想部署在自己的服务器中, 开启 GZip 根据不同的 web 容器, 设置的方式也不一样, 但总体思路差不多。</p>\n<p>先说 nodejs , 基于 nodejs 的 <a href=\"https://nodejs.org/docs/latest-v12.x/api/zlib.html#zlib_class_zlib_gzip\" target=\"_blank\" rel=\"noopener\">GZip</a> , 根据不同的 nodejs 框架有不同的使用方案, 我使用的是 koa, 引入的是 <code>koa-compress</code>, 使用方式如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> compress = <span class=\"built_in\">require</span>(<span class=\"string\">\"koa-compress\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">\"koa\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\">server.use(</span><br><span class=\"line\">  compress(&#123;</span><br><span class=\"line\">    threshold: <span class=\"number\">1024</span>,</span><br><span class=\"line\">    gzip: &#123;</span><br><span class=\"line\">      flush: <span class=\"built_in\">require</span>(<span class=\"string\">\"zlib\"</span>).Z_SYNC_FLUSH,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    deflate: &#123;</span><br><span class=\"line\">      flush: <span class=\"built_in\">require</span>(<span class=\"string\">\"zlib\"</span>).Z_SYNC_FLUSH,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    br: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>Nginx, Apache 等 web 容器, 编辑 conf 文件即可, 以 Nginx 为例:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\"># 开启gzip</span></span><br><span class=\"line\">gzip on;</span><br><span class=\"line\"><span class=\"comment\"># 启用gzip压缩的最小文件, 小于设置值的文件将不会压缩</span></span><br><span class=\"line\">gzip_min_length 1k;</span><br><span class=\"line\"><span class=\"comment\"># gzip 压缩级别, 1-9, 数字越大压缩的越好, 也越占用CPU时间, 后面会有详细说明</span></span><br><span class=\"line\">gzip_comp_level 1;</span><br><span class=\"line\"><span class=\"comment\"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span></span><br><span class=\"line\">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;</span><br><span class=\"line\"><span class=\"comment\"># 是否在http header中添加Vary: Accept-Encoding, 建议开启</span></span><br><span class=\"line\">gzip_vary on;</span><br><span class=\"line\"><span class=\"comment\"># 禁用IE 6 gzip</span></span><br><span class=\"line\">gzip_disable <span class=\"string\">\"MSIE [1-6]\\.\"</span>;</span><br><span class=\"line\"><span class=\"comment\"># 设置压缩所需要的缓冲区大小</span></span><br><span class=\"line\">gzip_buffers 32 4k;</span><br><span class=\"line\"><span class=\"comment\"># 设置gzip压缩针对的HTTP协议版本, 没做负载的可以不用</span></span><br><span class=\"line\"><span class=\"comment\"># gzip_http_version 1.0;</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>Apache 类似。</p>\n<h3 id=\"代码拆分-webpack-dllplugin-webpack-splitchunks-react-lazy\">代码拆分( webpack DllPlugin, webpack splitChunks, React.lazy )</h3>\n<h4 id=\"webpack-dllplugin\">webpack DllPlugin</h4>\n<p>使用 <code>webpack.DllPlugin</code> , 可以把常用的且基本不变的库, 单独拆分出去, 且仅需 build 一次, 可以提升打包的速度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.dll.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CopyWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"copy-webpack-plugin\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    react: [<span class=\"string\">\"react\"</span>, <span class=\"string\">\"react-dom\"</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mode: <span class=\"string\">\"production\"</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">\"[name].dll.[hash:6].js\"</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">\"dist\"</span>, <span class=\"string\">\"dll\"</span>),</span><br><span class=\"line\">    library: <span class=\"string\">\"[name]_dll\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DllPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">\"[name]_dll\"</span>,</span><br><span class=\"line\">      path: path.resolve(__dirname, <span class=\"string\">\"dist\"</span>, <span class=\"string\">\"dll\"</span>, <span class=\"string\">\"manifest.json\"</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在项目中使用:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">      manifest: path.resolve(__dirname, <span class=\"string\">'dist'</span>, <span class=\"string\">'dll'</span>, <span class=\"string\">'manifest.json'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\"><span class=\"keyword\">new</span> CleanWebpackPlugin(&#123;</span><br><span class=\"line\">    cleanOnceBeforeBuildPatterns: [<span class=\"string\">'**/*'</span>, <span class=\"string\">'!dll'</span>, <span class=\"string\">'!dll/**'</span>, <span class=\"string\">'!pdfjs'</span>, <span class=\"string\">'!pdfjs/**'</span>],</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>第一次使用 webpack.dll.config.js 文件会对第三方库打包, 打包完成后就不会再打包它了, 然后每次运行 webpack.config.js 文件的时候, 都会打包项目中本身的文件代码, 当需要使用第三方依赖的时候, 会使用 DllReferencePlugin 插件去读取第三方依赖库。所以说它的打包速度会得到一个很大的提升。</p>\n</blockquote>\n<h4 id=\"webpack-splitchunks\">webpack splitChunks</h4>\n<p>通过 splitChunks, 会把这些库再单独拆分出去</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-merge\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> baseConfig = <span class=\"built_in\">require</span>(<span class=\"string\">\"./webpack.config.js\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> opimizeCss = <span class=\"built_in\">require</span>(<span class=\"string\">\"optimize-css-assets-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> TerserPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"terser-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打包后文件大小分析</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> BundleAnalyzerPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-bundle-analyzer\"</span>)</span><br><span class=\"line\">  .BundleAnalyzerPlugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(baseConfig, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">\"production\"</span>,</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    runtimeChunk: &#123;</span><br><span class=\"line\">      name: <span class=\"string\">\"manifest\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      maxInitialRequests: <span class=\"number\">10</span>,</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendor: &#123;</span><br><span class=\"line\">          priority: <span class=\"number\">1</span>,</span><br><span class=\"line\">          name: <span class=\"string\">\"vendor\"</span>,</span><br><span class=\"line\">          test: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          minSize: <span class=\"number\">0</span>,</span><br><span class=\"line\">          minChunks: <span class=\"number\">1</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        moment: &#123;</span><br><span class=\"line\">          name: <span class=\"string\">\"moment\"</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">5</span>,</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\/]node_modules[\\/]moment[\\/]/</span>,</span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          minSize: <span class=\"number\">100</span>,</span><br><span class=\"line\">          minChunks: <span class=\"number\">1</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        lodash: &#123;</span><br><span class=\"line\">          name: <span class=\"string\">\"lodash\"</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">6</span>,</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\/]node_modules[\\/]lodash[\\/]/</span>,</span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          minSize: <span class=\"number\">100</span>,</span><br><span class=\"line\">          minChunks: <span class=\"number\">1</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        antd: &#123;</span><br><span class=\"line\">          name: <span class=\"string\">\"antd\"</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">7</span>,</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\/]node_modules[\\/]antd[\\/]es[\\/]/</span>,</span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          minSize: <span class=\"number\">100</span>,</span><br><span class=\"line\">          minChunks: <span class=\"number\">1</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    minimizer: [</span><br><span class=\"line\">      <span class=\"keyword\">new</span> opimizeCss(),</span><br><span class=\"line\">      <span class=\"keyword\">new</span> TerserPlugin(&#123;</span><br><span class=\"line\">        cache: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        parallel: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        sourceMap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      &#125;),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [<span class=\"keyword\">new</span> BundleAnalyzerPlugin()],</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"react-lazy\">React.lazy</h4>\n<p>理论上你可以对你的任何代码使用懒加载, 但我觉得仅对页面级别使用懒加载足以, 通过路由懒加载界面:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 路由列表</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> routesMapping = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// 首页</span></span><br><span class=\"line\">  <span class=\"string\">\"/\"</span>: React.lazy(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">\"@/pages/welcome\"</span>)),</span><br><span class=\"line\">  <span class=\"string\">\"/welcome\"</span>: React.lazy(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">\"@/pages/welcome\"</span>)),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  map(routesMapping, (Component, key) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"keyword\">get</span>(permissionsMapping, key) &amp;&amp; (</span><br><span class=\"line\">        &lt;Route</span><br><span class=\"line\">          exact</span><br><span class=\"line\">          path=&#123;key&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">         &lt;Component</span><br><span class=\"line\">            &#123;...this.props&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Route&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">...</span></span><br></pre></td></tr></table></figure>\n<p>至此, 生产环境下打包后, 你的 js 文件将会分散为多个。</p>\n<h3 id=\"客户端缓存-cache-control\">客户端缓存( Cache-Control )</h3>\n<p>经过以上的各种优化, 界面的访问速度已经很快了, 还有一个针对本地缓存的方案, 这个与开启 GZip 压缩类似, 以 nodejs 为例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">server.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.request.path.indexOf(<span class=\"string\">'/api'</span>) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    ctx.set(<span class=\"string\">'Cache-Control'</span>, <span class=\"string\">'public'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ctx.set(<span class=\"string\">'Cache-Control'</span>, <span class=\"string\">'no-store, no-cache, must-revalidate'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ctx.set(<span class=\"string\">'max-age'</span>, <span class=\"number\">7200</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>对除了 api 请求以外的请求进行缓存, 除了第一次访问需要网络请求资源以外, 下一次刷新将直接从本地缓存获取资源。</p>\n<h2 id=\"总结\">总结</h2>\n<p>优化 web 体验, 基本上是围绕 <code>减少资源大小( 压缩, 拆分 )</code>, <code>减少HTTP请求( svg , 样式优化 )</code>, <code>避免重绘和重排( 优化代码 )</code>, <code>提高 HTTP 访问速度( CDN )</code>, 如果大家有更好的优化方式, 欢迎一起讨论。</p>\n","categories":["front-end"],"tags":["JavaScript","优化"]},{"title":"利用travis做CI和CD","url":"/tools/use-travis-for-ci-and-cd.html","content":"<h2 id=\"ci-cd-简介\">CI/CD 简介</h2>\n<p>CI: Continuous Integration ( 持续集成 )</p>\n<p>CD: Continuous Delivery ( 持续交付 ) / Continuous Deployment ( 持续部署 )</p>\n<p><img src=\"/img/blog_img/ci-cd-flow.png\" alt=\"ci-cd-flow\"></p>\n<p>先看 Readhat 的解释：</p>\n<blockquote>\n<p>CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在集成新代码时所引发的问题（亦称：“集成地狱”）。具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。</p>\n</blockquote>\n<p>再看维基百科的解释：</p>\n<blockquote>\n<p>在软件工程中，CI/CD或CICD通常指的是持续集成和持续交付或持续部署的组合实践。CI/CD通过在应用程序的构建、测试和部署中实施自动化，在开发和运营团队之间架起了桥梁。</p>\n</blockquote>\n<p>以下是个人观点：</p>\n<p>持续集成的概念，类似开发者在合并新的代码到主干分支的时候，系统自动执行构建并执行测试，并将结果通知到开发者。</p>\n<p>持续交付的概念，在代码集成且验证通过后，自动将验证的代码放入存储库，持续交付的目标是可以拥有一个随时部署的代码版本。</p>\n<p>持续部署的概念，作为持续交付的延伸，可以自动将代码发布到生产环境。</p>\n<h2 id=\"ci-cd-实战\">CI/CD 实战</h2>\n<p>基于以上概念的描述，我举 <a href=\"https://github.com/kavience/masos-web\" target=\"_blank\" rel=\"noopener\">masos-web</a> 这个例子</p>\n<p>现在 masos-web 有三个分支，分别是 <code>master</code>, <code>dev</code>, <code>feat-test</code> 。</p>\n<h3 id=\"git-工作流\">Git 工作流</h3>\n<p>基于 Git 工作流开发， <code>master</code> 作为稳定的主分支代码，保证可以随时部署到生产环境。 <code>dev</code> 分支作为开发分支，是 <code>master</code> 分支的延伸，与 <code>master</code> 分支不会且不应该存在冲突。 <code>feat-test</code> 是相关的开发功能分支，编写相应的代码， <code>feat-test</code> 与 <code>dev</code> 存在冲突是正常的，因为有多个功能分支同时基于 <code>dev</code> 分支开发，功能分支<strong>禁止</strong>直接合并到 <code>master</code> 分支。</p>\n<h3 id=\"持续集成\">持续集成</h3>\n<ul>\n<li>在 <code>feat-test</code> 分支上做了部分修改，然后合并到 <code>dev</code> 分支，通过 <code>review</code> 后，再执行合并。</li>\n<li>将 <code>dev</code> 分支与 <code>master</code> 分支合并，触发自动构建、代码检查等。</li>\n</ul>\n<h3 id=\"持续交付\">持续交付</h3>\n<p>持续交付，可生产多个版本，保证项目有多个可用的版本，一旦新版本发生了不可预知的错误，可随时使用旧版本。</p>\n<ul>\n<li>自动生成 tag，发布版本</li>\n</ul>\n<h3 id=\"持续部署\">持续部署</h3>\n<ul>\n<li>自动发布最新的版本到生产环境</li>\n</ul>\n<p>除自动发布外，还可随时手动选择不同的版本发布。</p>\n<h2 id=\"travis-使用流程\">Travis 使用流程</h2>\n<ul>\n<li>\n<p>注册登录</p>\n<p>到 <a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">Travis</a> 官网登录，安装指引注册、登录、授权。如下图：</p>\n<p><img src=\"/img/blog_img/travis1.png\" alt=\"ci-cd-flow\"></p>\n<p><img src=\"/img/blog_img/travis2.png\" alt=\"ci-cd-flow\"></p>\n</li>\n<li>\n<p>申请 GitHub token</p>\n<p>申请路径为： GitHub &gt; settings &gt; Developer settings &gt; Personal access tokens &gt; Generate new token</p>\n<p>申请后，会得到一个例如 ghp_mZuC0e0gGxxxxxxxxxxxxxxxxx 的一个 token。</p>\n</li>\n<li>\n<p>加密 GitHub token<br>\n使用 travis 加密这个 token。步骤为：</p>\n<ul>\n<li>使用 sudo gem install travis 安装 travis</li>\n<li>运行命令加密：<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">travis encrypt GITHUB_TOKEN=ghp_mZuC0e0gGxxxxxxxxxxxxxxxxx --com</span><br></pre></td></tr></table></figure>\n</li>\n<li>会有个确认仓库的提示，输入 yes 后回车，得到一个 <code>secure</code></li>\n</ul>\n</li>\n<li>\n<p>编写 .travis.yml<br>\n在项目下新建一个文件 <code>.travis.yml</code> ， 内容如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目为 node 开发</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></span><br><span class=\"line\"><span class=\"comment\"># node 版本</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"number\">14</span></span><br><span class=\"line\"><span class=\"comment\"># 任务队列 </span></span><br><span class=\"line\"><span class=\"attr\">jobs:</span> </span><br><span class=\"line\">  <span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">  <span class=\"attr\">install:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">yarn</span> <span class=\"string\">install</span></span><br><span class=\"line\">  <span class=\"comment\"># 执行一下自定义的脚本</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"comment\"># 因为 conventional-changelog-cli 和 standard-version 不用写在 package.json ，而是采用全局安装的方式</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">yarn</span> <span class=\"string\">global</span> <span class=\"string\">add</span> <span class=\"string\">conventional-changelog-cli</span> <span class=\"string\">standard-version</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">yarn</span> <span class=\"string\">build</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">yarn</span> <span class=\"string\">release</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">yarn</span> <span class=\"string\">changelog</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">cp</span> <span class=\"string\">CHANGELOG.md</span> <span class=\"string\">build/CHANGELOG.md</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">mv</span> <span class=\"string\">build/</span> <span class=\"string\">/tmp/build</span></span><br><span class=\"line\">  <span class=\"comment\"># 只有 master 分支触发构建</span></span><br><span class=\"line\">  <span class=\"attr\">branches:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">master</span></span><br><span class=\"line\">  <span class=\"comment\"># 部署到 github pages</span></span><br><span class=\"line\">  <span class=\"attr\">deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">provider:</span> <span class=\"string\">pages</span></span><br><span class=\"line\">    <span class=\"attr\">local_dir:</span> <span class=\"string\">/tmp/build</span></span><br><span class=\"line\">    <span class=\"attr\">skip_cleanup:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">github_token:</span> <span class=\"string\">\"$GITHUB_TOKEN\"</span></span><br><span class=\"line\">    <span class=\"attr\">keep_history:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">on:</span></span><br><span class=\"line\">      <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br><span class=\"line\">  <span class=\"comment\"># 部署后发布 tags</span></span><br><span class=\"line\">  <span class=\"attr\">after_deploy:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">push</span> <span class=\"string\">--follow-tags</span> <span class=\"string\">origin</span> <span class=\"string\">master</span></span><br><span class=\"line\"><span class=\"attr\">env:</span></span><br><span class=\"line\">  <span class=\"attr\">global:</span></span><br><span class=\"line\">    <span class=\"comment\"># &lt;secure&gt; 替换为上一步生成的 secure</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">secure:</span> <span class=\"string\">&lt;secure&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>最新消息，travis 不再为开源项目免费提供使用。换成 GitHub action 吧。</p>\n</blockquote>\n</li>\n</ul>\n","categories":["tools"],"tags":["CI/CD"]},{"title":"Nodejs模块addons入门","url":"/front-end/getting-started-with-nodejs-module-addons.html","content":"<h2 id=\"what\">what</h2>\n<p>打算好好学习一下 nodejs，那就先从 nodejs 官方文档看起吧，这篇博客主要是记录一下 nodejs 下的 c++ addnos 模块，看 nodejs 为什么要引入 c++ ，以及如何引入 c++ 代码。</p>\n<p><a href=\"https://nodejs.org/docs/latest-v9.x/api/addons.html\" target=\"_blank\" rel=\"noopener\">c++ addons 官方文档</a></p>\n<h2 id=\"why\">why</h2>\n<blockquote>\n<p>nodejs 采用事件驱动、异步编程，为网络服务而设计。其实 Javascript 的匿名函数和闭包特性非常适合事件驱动、异步编程。非阻塞模式的 IO 处理给 Node.js 带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它 IO 资源的中间层服务。</p>\n</blockquote>\n<p>Nodejs 虽然有着不错的异步能力，但是在密集型计算的时候却并不出众，简单来说所有的异步任务会维护在一个事件循环中(队列)，线程会不断的去事件循环中取任务来执行，当 CPU 密集型的任务造成执行时间过长，就会导致其他任务无法执行，这样整个程序的性能就不行了。这个时候就可以用 c++ 来编写一些 nodejs 模块，加快运算时间。</p>\n<h2 id=\"how\">how</h2>\n<p>以 fibonacci 函数为例，先看一下运行结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fibonacciC = <span class=\"built_in\">require</span>(<span class=\"string\">\"./build/Release/fibonacci.node\"</span>).fibonacci;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacciJS</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> fibonacciJS(n - <span class=\"number\">1</span>) + fibonacciJS(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">\"c++\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fibonacciC(<span class=\"number\">40</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"c++\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">\"js\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fibonacciJS(<span class=\"number\">40</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"js\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"number\">102334155</span></span><br><span class=\"line\">c++: <span class=\"number\">524.515</span>ms</span><br><span class=\"line\"><span class=\"number\">102334155</span></span><br><span class=\"line\">js: <span class=\"number\">1.335</span>s</span><br></pre></td></tr></table></figure>\n<p>在 40 次的递归运算中，可以看到采用原生 js 实现的方式，时间是 c++ 方式实现的两倍多，如果计算时间更长的话，原生 js 实现的效率更低。</p>\n<p>接下来看一下是如何把 c++ 的代码结合到 nodejs 中。</p>\n<h3 id=\"编写-c-代码\">编写 c++ 代码</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fibonacci.cc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;node.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> demo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> v8::FunctionCallbackInfo;</span><br><span class=\"line\"><span class=\"keyword\">using</span> v8::Isolate;</span><br><span class=\"line\"><span class=\"keyword\">using</span> v8::Local;</span><br><span class=\"line\"><span class=\"keyword\">using</span> v8::Object;</span><br><span class=\"line\"><span class=\"keyword\">using</span> v8::Number;</span><br><span class=\"line\"><span class=\"keyword\">using</span> v8::Value;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 通过 FunctionCallbackInfo&lt;Value&gt;&amp; args 可以设置返回值 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fibonacci</span><span class=\"params\">(<span class=\"keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class=\"line\">  Isolate *isolate = args.GetIsolate();</span><br><span class=\"line\">  <span class=\"comment\">// node v10 版本之前是这样获取 number 参数的</span></span><br><span class=\"line\">  <span class=\"comment\">// args[0]-&gt;NumberValue()</span></span><br><span class=\"line\">  <span class=\"comment\">// v10 版本之后是这样获取的</span></span><br><span class=\"line\">  <span class=\"comment\">// args[0].As&lt;Number&gt;()-&gt;Value()</span></span><br><span class=\"line\">  Local&lt;Number&gt; num = Number::New(isolate, fib(args[<span class=\"number\">0</span>].As&lt;Number&gt;()-&gt;Value()));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置函数调用的返回值</span></span><br><span class=\"line\">  args.GetReturnValue().Set(num);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Initialize</span><span class=\"params\">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 指定 module 名字</span></span><br><span class=\"line\">  NODE_SET_METHOD(exports, <span class=\"string\">\"fibonacci\"</span>, fibonacci);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载 module</span></span><br><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编译-c-代码\">编译 c++ 代码</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首先要安装 node-gyp</span></span><br><span class=\"line\">npm i -g node-gyp</span><br></pre></td></tr></table></figure>\n<p>在当前目录下添加 <code>binding.gyp</code> 文件，内容为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"targets\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"target_name\"</span>: <span class=\"string\">\"fibonacci\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"sources\"</span>: [ <span class=\"string\">\"fibonacci.cc\"</span> ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行打包编译命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先打包</span></span><br><span class=\"line\">node-gyp  configure</span><br><span class=\"line\"><span class=\"comment\"># 会生成一个 build 目录，然后进入这个目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\"><span class=\"comment\"># 编译文件</span></span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>这个时候会生成一个 build 目录，以及 build 目录下的 Release 目录。</p>\n<h3 id=\"引入-c-模块\">引入 c++ 模块</h3>\n<p>接下来就可以像这样引入该模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fibonacciC = <span class=\"built_in\">require</span>(<span class=\"string\">\"./build/Release/fibonacci.node\"</span>).fibonacci;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fibonacciC(<span class=\"number\">40</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>引入 c++ ，借助其高效的计算能力，可以让 nodejs 也进行一些密集型的计算，本文只是一个简单的实例，更多强大的功能还需要看官方文档以及熟悉 c++ 才行。</p>\n","categories":["front-end"],"tags":["JavaScript","nodejs"]},{"title":"Apple M1 下的 Rosetta 与 Npm","url":"/tools/rosetta-and-npm-under-apple-m1.html","content":"<h2 id=\"what\">what</h2>\n<p>新版的 Apple M1 是基于 arm 架构的，然而大部分的软件 和 npm 包都还没有适配 arm 架构，所以苹果公司就使用 Rosetta 来兼容 x86 架构的软件。</p>\n<h2 id=\"why\">why</h2>\n<p>第一次使用 x86 软件的时候，系统会自动提示安装 Rosetta ，安装后直接运行软件即可。</p>\n<p>然而，今天遇到一个非常奇怪的问题，在安装依赖的时候我发现无法安装 <code>node-canvas</code> 这个包，经过一系列的排查，我发现问题出在这里：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">npm ERR! node-pre-gyp http 404 status code downloading tarball https://github.com/Automattic/node-canvas/releases/download/v2.7.0/canvas-v2.7.0-node-v88-darwin-unknown-arm64.tar.gz</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>无法找到 <code>canvas-v2.7.0-node-v88-darwin-unknown-arm64.tar.gz</code> 这个包，顺着 node-canvas 的 releases 发现，根本就没有发布这个包，只有 <code>canvas-v2.7.0-node-v88-darwin-unknown-x64.tar.gz</code>，这个时候我突然意识到，当前是以 arm 架构运行的 terminal 和 npm，所以识别出来后，自动去寻找适合 arm 架构的包，然而并没有适配 arm 的包，所以就导致无法安装。</p>\n<h2 id=\"how\">how</h2>\n<p>我顺着使用 x86 架构的软件的思路，我觉得既然软件可以移植到 M1 上，npm 肯定也是可以的，一定有某种方法，而且肯定与 Rosetta 有关。终于，想到办法了。</p>\n<ol>\n<li>在应用程序中找到 terminal ，然后右键 <code>显示简介</code>，发现有个选项 <code>使用Rosetta打开</code></li>\n<li>打开一个 terminal，然后卸载 node ，再重新安装一次。(我是使用 nvm 安装的 node)</li>\n<li>使用该版本的 node 安装依赖，发现成功了。</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>简而言之就是安装依赖的时候，发现依赖不适用于 arm 架构的 M1，只能使用 x86 架构的依赖，所以需要借助于 Rosetta 去安装依赖。</p>\n","categories":["tools"],"tags":["apple"]},{"title":"Mobx的学习与使用","url":"/front-end/study-and-use-of-mobx.html","content":"<h2 id=\"mobx-简介\">mobx 简介</h2>\n<blockquote>\n<p>简单、可扩展的状态管理，相比于 redux，更轻巧，更简单，更灵活，在某些时候性能甚至更优越。</p>\n</blockquote>\n<p>在这里简单的记录和介绍一下 mobx 的使用。</p>\n<h2 id=\"简单例子\">简单例子</h2>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; observable &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"mobx\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; observer &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"mobx-react\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> numStore = observable(&#123;</span><br><span class=\"line\">  num: <span class=\"number\">1</span>,</span><br><span class=\"line\">  addNum: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.num++;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">@observer</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  handleAdd = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.numStore.addNum();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;span&gt; num: &#123;<span class=\"keyword\">this</span>.props.numStore.num&#125; &lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;this.handleAdd&#125;&gt;&lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(&lt;TimerView numStore=&#123;numStore&#125; /</span>&gt;, <span class=\"built_in\">document</span>.body);</span><br></pre></td></tr></table></figure>\n<h2 id=\"主要的-api\">主要的 api</h2>\n<h3 id=\"observable\">observable</h3>\n<p>使用：</p>\n<ul>\n<li>observable(value)</li>\n<li>@observable classProperty = value</li>\n</ul>\n<p>Observable 值可以是 JS 基本数据类型、引用类型、普通对象、类实例、数组和映射。 主要作用是指定该值的是被观察的、可修改的。其装饰器写法为 <code>@observable</code>。例如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; observable, computed &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"mobx\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法1，直接使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> NumStore = observable(&#123;</span><br><span class=\"line\">  num: <span class=\"number\">1</span>,</span><br><span class=\"line\">  addNum: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.num++;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二，装饰器写法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumStore</span> </span>&#123;</span><br><span class=\"line\">  @observable price = <span class=\"number\">0</span>;</span><br><span class=\"line\">  @observable num = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  @computed <span class=\"keyword\">get</span> total() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.price * <span class=\"keyword\">this</span>.num;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"computed\">computed</h3>\n<p>如果任何影响计算值的值发生变化了，计算值将根据状态自动进行衍生。 计算值在大多数情况下可以被 MobX 优化的，因为它们被认为是纯函数。 例如，如果前一个计算中使用的数据没有更改，计算属性将不会重新运行。 如果某个其它计算属性或 reaction 未使用该计算属性，也不会重新运行。 在这种情况下，它将被暂停。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; observable, computed &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"mobx\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumStore</span> </span>&#123;</span><br><span class=\"line\">  @observable price = <span class=\"number\">0</span>;</span><br><span class=\"line\">  @observable num = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  @computed <span class=\"keyword\">get</span> total() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.price * <span class=\"keyword\">this</span>.num;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"autorun\">autorun</h3>\n<p>autorun 可以用来监听值的变化，不要把 <code>computed</code> 和 <code>autorun</code> 搞混。它们都是响应式调用的表达式，但是，如果你想响应式的产生一个可以被其它 observer 使用的值，请使用 @computed，如果你不想产生一个新值，而想要达到一个效果，请使用 autorun。 举例来说，效果是像打印日志、发起网络请求等这样命令式的副作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">\"axios\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; observable, configure, action, runInAction, autorun &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"mobx\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">configure(&#123; <span class=\"attr\">enforceActions</span>: <span class=\"string\">\"observed\"</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Session</span> </span>&#123;</span><br><span class=\"line\">  @observable num = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    autorun(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 每次调用 addNum / subNum都会执行此函数</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"auto log num:\"</span> + <span class=\"keyword\">this</span>.num);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @action addNum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.num);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.num++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @action subNum = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.num--;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Session();</span><br></pre></td></tr></table></figure>\n<h3 id=\"action\">action</h3>\n<p>用法:</p>\n<ul>\n<li>action(fn)</li>\n<li>action(name, fn)</li>\n<li>@action classMethod() {}</li>\n<li>@action(name) classMethod () {}</li>\n<li>@action boundClassMethod = (args) =&gt; { body }</li>\n<li>@action(name) boundClassMethod = (args) =&gt; { body }</li>\n<li>@action.bound classMethod() {}</li>\n</ul>\n<p>action 主要是用来修改状态，也可以使用异步的方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">\"axios\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; observable, configure, action, runInAction &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"mobx\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 强制使用 action 来修改状态，否则会打印 waring</span></span><br><span class=\"line\">configure(&#123; <span class=\"attr\">enforceActions</span>: <span class=\"string\">\"observed\"</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Session</span> </span>&#123;</span><br><span class=\"line\">  @observable num = <span class=\"number\">1</span>;</span><br><span class=\"line\">  @observable loading = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  @action addNum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.num);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.num++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @action subNum = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.num--;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @action directGetHundred = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loading = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    setTimeout(</span><br><span class=\"line\">      <span class=\"comment\">// 所有的修改状态都需要放在 action 中</span></span><br><span class=\"line\">      action(<span class=\"string\">\"directAddHundred\"</span>, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.num += <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loading = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;),</span><br><span class=\"line\">      <span class=\"number\">1000</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @action directGetTwoHundred = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loading = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> axios(<span class=\"string\">\"/\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 调用其他异步操作</span></span><br><span class=\"line\">    <span class=\"comment\">// await axios(\"/\");</span></span><br><span class=\"line\">    <span class=\"comment\">// runInAction 是 action 的语法糖，鼓励你不要到处写 action，而是在整个过程结束时尽可能多地对所有状态进行修改</span></span><br><span class=\"line\">    runInAction(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.loading = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.num += <span class=\"number\">200</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Session();</span><br></pre></td></tr></table></figure>\n<h2 id=\"flows\">flows</h2>\n<p>flows 的工作原理与 async / await 是一样的。只是使用 function * 来代替 async，使用 yield 代替 await 。 使用 flow 的优点是它在语法上基本与 async / await 是相同的 (只是关键字不同)，并且不需要手动用 @action 来包装异步代码，这样代码更简洁。</p>\n<p>flow 只能作为函数使用，不能作为装饰器使用。 flow 可以很好的与 MobX 开发者工具集成，所以很容易追踪 async 函数的过程。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mobx.configure(&#123; <span class=\"attr\">enforceActions</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Store</span> </span>&#123;</span><br><span class=\"line\">  @observable githubProjects = [];</span><br><span class=\"line\">  @observable state = <span class=\"string\">\"pending\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  fetchProjects = flow(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// &lt;- 注意*号，这是生成器函数！</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.githubProjects = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = <span class=\"string\">\"pending\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> projects = <span class=\"keyword\">yield</span> fetchGithubProjectsSomehow(); <span class=\"comment\">// 用 yield 代替 await</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> filteredProjects = somePreprocessing(projects);</span><br><span class=\"line\">      <span class=\"comment\">// 异步代码块会被自动包装成动作并修改状态</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = <span class=\"string\">\"done\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.githubProjects = filteredProjects;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = <span class=\"string\">\"error\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>之前一直使用 redux，看到了有赞前端技术团队的 <a href=\"https://tech.youzan.com/mobx_vs_redux/\" target=\"_blank\" rel=\"noopener\">我为什么从 Redux 迁移到了 Mobx<br>\n</a> 文章，决定了解一下 mobx ，现在这里只记录 mobx 的简单使用，详细的还是需要查看<a href=\"https://cn.mobx.js.org/\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n","categories":["front-end"],"tags":["mobx","mobx-react"]},{"title":"Typescript常见知识总结","url":"/front-end/typescript-common-knowledge-summary.html","content":"<h2 id=\"never-unknown-any-三者之间的区别\">never, unknown, any 三者之间的区别</h2>\n<p>三者都是 TypeScript 的类型, never 是最具体的类型，因为没有哪个集合比空集合更小了；而 unknown 是最弱的类型，因为它包含了全部可能的值。 any 则不为集合，它破坏了类型检查，因此请尽量不要使用 any。在 TypeScript 中， nerver 可以赋值为 unknown 和 any ，但是 unknown 和 any 不可以赋值给 never，never 只能赋值 never。</p>\n<p>那 nerver 的作用是什么呢？举个尤雨溪提到的<a href=\"https://www.zhihu.com/question/354601204/answer/888551021\" target=\"_blank\" rel=\"noopener\">例子</a>：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Foo &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"string\">\"foo\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bar &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"string\">\"bar\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> All = Foo | Bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleValue</span>(<span class=\"params\">val: All</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (val.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"foo\"</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 这里 val 被收窄为 Foo</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"bar\"</span>:</span><br><span class=\"line\">      <span class=\"comment\">// val 在这里是 Bar</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">// val 在这里是 never</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> exhaustiveCheck: never = val;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事改了 All 的类型：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> All = Foo | Bar | Baz;</span><br></pre></td></tr></table></figure>\n<p>然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 All 的可能类型。</p>\n<h2 id=\"interface-与-type-的区别\">interface 与 type 的区别</h2>\n<h3 id=\"相同点：\">相同点：</h3>\n<h4 id=\"都可以描述一个对象或者函数\">都可以描述一个对象或者函数</h4>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 interface</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> User &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SetUser &#123;</span><br><span class=\"line\">  (name: <span class=\"built_in\">string</span>, age: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 type</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> User = &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SetUser = <span class=\"function\">(<span class=\"params\">name: <span class=\"built_in\">string</span>, age: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"都允许扩展\">都允许扩展</h4>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Name &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> User <span class=\"keyword\">extends</span> Name &#123;</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Name = &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> User = Name &amp; &#123; age: <span class=\"built_in\">number</span> &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不同点\">不同点</h3>\n<h4 id=\"type-可以而-interface-不行\">type 可以而 interface 不行</h4>\n<p>type 可以声明基本类型别名，联合类型，元组等类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本类型别名</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Name = <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 联合类型</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Dog &#123;</span><br><span class=\"line\">  wong();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cat &#123;</span><br><span class=\"line\">  miao();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pet = Dog | Cat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体定义数组每个位置的类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PetList = [Dog, Pet];</span><br></pre></td></tr></table></figure>\n<p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当你想获取一个变量的类型时，使用 typeof</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">type</span> B = <span class=\"keyword\">typeof</span> div;</span><br></pre></td></tr></table></figure>\n<p>其它用法</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> StringOrNumber = <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Text = <span class=\"built_in\">string</span> | &#123; text: <span class=\"built_in\">string</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> NameLookup = Dictionary&lt;<span class=\"built_in\">string</span>, Person&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Callback&lt;T&gt; = <span class=\"function\">(<span class=\"params\">data: T</span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Pair&lt;T&gt; = [T, T];</span><br><span class=\"line\"><span class=\"keyword\">type</span> Coordinates = Pair&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;; right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"interface-可以而-type-不行\">interface 可以而 type 不行</h4>\n<p>interface 能够声明合并</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> User &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> User &#123;</span><br><span class=\"line\">  sex: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">User 接口为 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  name: string</span></span><br><span class=\"line\"><span class=\"comment\">  age: number</span></span><br><span class=\"line\"><span class=\"comment\">  sex: string </span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n","categories":["front-end"],"tags":["typescript"]},{"title":"前端面试题之Js进阶(持续更新)","url":"/front-end/advanced-js-for-frontend-interview-questions-continuous-update.html","content":"<h2 id=\"数据类型\">数据类型</h2>\n<p>Number, String, Bool, Null, Undefined, Symbol, 引用数据类型( Object, Function, Array )。</p>\n<p>Null 与 Undefined 的区别:</p>\n<p>Null</p>\n<ul>\n<li>\n<p>作为函数的参数, 表示该函数的参数不是对象。</p>\n</li>\n<li>\n<p>作为对象原型链的终点。</p>\n</li>\n</ul>\n<p>Undefined</p>\n<ul>\n<li>\n<p>变量被声明了, 但没有赋值时, 就等于 undefined。</p>\n</li>\n<li>\n<p>调用函数时, 应该提供的参数没有提供, 该参数等于 undefined。</p>\n</li>\n<li>\n<p>对象没有赋值的属性, 该属性的值为 undefined。</p>\n</li>\n<li>\n<p>函数没有返回值时, 默认返回 undefined。</p>\n</li>\n</ul>\n<h2 id=\"var-const-let-的区别\">var, const, let 的区别</h2>\n<ul>\n<li>var 命令存在变量提升现象, 可在声明之前使用, let 与 const 则不存在</li>\n<li>let 与 const 存在暂时性死区的现象, 这个区块对这些命令声明的变量, 从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量, 就会报错。</li>\n<li>let 与 const 不可以重复声明。</li>\n<li>const 声明的是只读的常量, 一旦声明, 就必须立即初始化, 声明之后值不能改变。</li>\n<li>let 与 const 是块级作用域。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>声明方式</th>\n<th>变量提升</th>\n<th>暂时性死区</th>\n<th>重复声明</th>\n<th>初始值</th>\n<th>作用域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>var</td>\n<td>允许</td>\n<td>不存在</td>\n<td>允许</td>\n<td>不需要</td>\n<td>除块级</td>\n</tr>\n<tr>\n<td>let</td>\n<td>不允许</td>\n<td>存在</td>\n<td>不允许</td>\n<td>不需要</td>\n<td>块级</td>\n</tr>\n<tr>\n<td>const</td>\n<td>不允许</td>\n<td>存在</td>\n<td>不允许</td>\n<td>需要</td>\n<td>块级</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"new-的过程\">new 的过程</h2>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">    sayName: function() &#123;</span><br><span class=\"line\">         alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jack = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Jack\"</span>);</span><br></pre></td></tr></table></figure>\n<p>首先, 必须保证 new 运算符后跟着的是一个有<code>[[Construct]]</code>内部方法的对象, 否则会抛出异常。</p>\n<p>接下来就是创建对象的过程:</p>\n<ol>\n<li>\n<p>先创建一个原生对象, 假定为 obj = {} 或 obj = new Object。</p>\n</li>\n<li>\n<p>获得构造函数 Person 的 prototype 对象, 并将其赋给 obj 的<code>[[Prototype]]</code>属性, 表现为<code>__proto__</code>。</p>\n</li>\n<li>\n<p>call 构造函数的内部方法, 把其中的 this 赋值为新创建的对象 obj, 并传入所需参数。</p>\n</li>\n<li>\n<p>执行构造函数, 并返回创建的对象。</p>\n</li>\n</ol>\n<p>这里有一点需要说明: 正常来讲构造函数中是不用写 return 语句的, 因为它会默认返回新创建的对象。但是, 如果在构造函数中写了 return 语句, 如果 return 的是一个对象, 那么函数就会覆盖掉新创建的对象, 而返回此对象；如果 return 的是基本类型如字符串、数字、布尔值等, 那么函数会忽略掉 return 语句, 还是返回新创建的对象。</p>\n<h3 id=\"实现一个-new\">实现一个 new</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myNew</span>(<span class=\"params\">Fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> Fn === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">    obj.__proto__ = Fn.prototype;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>).slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">    Fn.call(obj, ...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = myNew(Person, <span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name);</span><br></pre></td></tr></table></figure>\n<h2 id=\"this-的指向\">this 的指向</h2>\n<p>在 js 中 this 一般会出现在如下情况:</p>\n<ol>\n<li>全局状态下</li>\n<li>一般函数内</li>\n<li>this 和对象转换</li>\n<li>原型链中</li>\n<li>与 DOM 相关</li>\n</ol>\n<p>详见另一篇文章 - <a href=\"../js-%E5%BD%BB%E5%BA%95%E4%BA%86%E8%A7%A3this%E7%9A%84%E6%8C%87%E5%90%91\">js-彻底了解 this 的指向</a></p>\n<h2 id=\"apply-call-bind-的区别与实现\">apply, call, bind 的区别与实现</h2>\n<p>bind 与 call 或 apply 最大的区别就是 bind 不会被立即调用, 而是返回一个函数, 函数内部的 this 指向与 bind 执行时的第一个参数, 而传入 bind 的第二个及以后的参数作为原函数的参数来调用原函数。</p>\n<p>call, apply 都是为了改变某个函数运行时的上下文而存在的, 简单点说就是为了改变某个运行时函数内部 this 指向, 区别在于 apply 第二参数需要是一个参数数组, call 的第二参数及其之后的参数需要是数组里面的元素。</p>\n<h3 id=\"apply-的实现\">apply 的实现</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 基础类型转包装对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (context === <span class=\"literal\">undefined</span> || context === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    context = <span class=\"built_in\">window</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> context === <span class=\"string\">\"string\"</span>) &#123;</span><br><span class=\"line\">    context = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(context);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> context === <span class=\"string\">\"number\"</span>) &#123;</span><br><span class=\"line\">    context = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(context);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> context === <span class=\"string\">\"boolean\"</span>) &#123;</span><br><span class=\"line\">    context = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(context);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 非对象, 非undefined, 非null的值才会抛错</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> arr !== <span class=\"string\">\"object\"</span> &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> arr !== <span class=\"string\">\"undefined\"</span> &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> arr !== <span class=\"string\">\"null\"</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"CreateListFromArrayLike called on non-object\"</span>);</span><br><span class=\"line\">  arr = (<span class=\"built_in\">Array</span>.isArray(arr) &amp;&amp; arr) || []; <span class=\"comment\">// 非数组就赋值空数组</span></span><br><span class=\"line\">  <span class=\"comment\">// 保存原函数至指定对象的fn属性上</span></span><br><span class=\"line\">  context.fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 通过指定对象的fn属性执行原函数并出入参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fnValue = context.fn(...arr);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn; <span class=\"comment\">// 从context中删除fn原函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fnValue;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"call-的实现\">call 的实现</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.call = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 基础类型转包装对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (context === <span class=\"literal\">undefined</span> || context === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    context = <span class=\"built_in\">window</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> context === <span class=\"string\">\"string\"</span>) &#123;</span><br><span class=\"line\">    context = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(context);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> context === <span class=\"string\">\"number\"</span>) &#123;</span><br><span class=\"line\">    context = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(context);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> context === <span class=\"string\">\"boolean\"</span>) &#123;</span><br><span class=\"line\">    context = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(context);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 保存原函数至指定对象的fn属性上</span></span><br><span class=\"line\">  context.fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 获取除第一个参数之后的所有参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>).slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 通过指定对象的fn属性执行原函数并出入参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fnValue = context.fn(...args);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn; <span class=\"comment\">// 从context中删除fn原函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fnValue;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"bind-的实现\">bind 的实现</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 保存原函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ofn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 获取除第一个参数之后的所有参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>).slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">O</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第一个参数的判断是为了忽略使用new实例化函数时让this指向它自己, 否则就指向这个context指定对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 第二个参数的处理做了参数合并,  就是 bind &amp; fn 两个函数的参数合并</span></span><br><span class=\"line\">    ofn.apply(</span><br><span class=\"line\">      <span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> O ? <span class=\"keyword\">this</span> : context,</span><br><span class=\"line\">      args.concat(<span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>))</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  O.prototype = <span class=\"keyword\">this</span>.prototype;</span><br><span class=\"line\">  fn.prototype = <span class=\"keyword\">new</span> O();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包\">闭包</h2>\n<h2 id=\"时间循环\">时间循环</h2>\n<h2 id=\"类型判断\">类型判断</h2>\n<h2 id=\"手写-promise\">手写 promise</h2>\n<h2 id=\"垃圾回收机制\">垃圾回收机制</h2>\n<h2 id=\"原型链\">原型链</h2>\n<blockquote>\n<p>概要: 每个构造函数( construct ) 都有一个原型对象, 原型对象( prototype )都包含一个指向构造函数的内部指针, 而实例( instance ) 都包含指向原型对象的内部指针。实例与原型的链条称作<code>原型链</code>。</p>\n</blockquote>\n<p>网上看到一张图, 感觉很全面的描述了原型链之间的关系:</p>\n<p><img src=\"/img/blog_img/prototype.png\" alt=\"prototype\"></p>\n<p>注意: <code>prototype</code> 是函数(ES6 中箭头函数除外)特有的属性, 实例对象不存在该属性, <code>__proto__</code> 则在两者内都存在, 因为函数也是对象。</p>\n<h2 id=\"继承的实现\">继承的实现</h2>\n<p>七种 JS 继承方式分别是:</p>\n<ul>\n<li>原型链继承</li>\n<li>构造函数式继承</li>\n<li>组合式继承</li>\n<li>原型式继承</li>\n<li>寄生式继承</li>\n<li>寄生组合式继承</li>\n<li>ES6 关键字 extends 继承</li>\n</ul>\n<h3 id=\"原型链继承\">原型链继承</h3>\n<p>基本思想: 通过直接改变子类的 prototype 实现。</p>\n<p>优点: 实例可继承的属性有: 实例的构造函数的属性, 父类构造函数的属性, 父类原型上的属性（新实例不会继承父类实例的属性）。</p>\n<p>缺点: 新实例无法向父类构造函数传参, 继承单一, 所有新实例都会共享父类实例的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">\"frontend\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">\"child\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.job); <span class=\"comment\">// frontend</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数式继承\">构造函数式继承</h3>\n<p>基本思想: 在子类型构造函数的内部调用超类型构造函数.</p>\n<p>优点: 保证了原型链中引用类型值的独立, 不再被所有实例共享, 子类型创建时也能够向父类型传递参数。</p>\n<p>缺点: 方法都在构造函数中定义, 函数难以复用, 而且父类中定义的方法, 对子类而言也是不可见的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  Father.call(<span class=\"keyword\">this</span>); <span class=\"comment\">//继承了Father,且向父类型传递参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">\"black\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors); <span class=\"comment\">//\"red,blue,green,black\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors); <span class=\"comment\">//\"red,blue,green\" 可见引用类型值是独立的</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"组合式继承\">组合式继承</h3>\n<p>基本思路: 使用原型链实现对原型属性和方法的继承, 通过借用构造函数来实现对实例属性的继承。</p>\n<p>优点: 通过在原型上定义方法实现了函数复用, 又能保证每个实例都有它自己的属性。</p>\n<p>缺点: 调用了两次父类构造函数, 造成了不必要的消耗。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Father.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Father.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">//继承实例属性, 第一次调用Father()</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Father(); <span class=\"comment\">//继承父类方法,第二次调用Father()</span></span><br><span class=\"line\">Son.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">\"louis\"</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">\"black\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors); <span class=\"comment\">//\"red,blue,green,black\"</span></span><br><span class=\"line\">instance1.sayName(); <span class=\"comment\">//louis</span></span><br><span class=\"line\">instance1.sayAge(); <span class=\"comment\">//5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">\"zhai\"</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors); <span class=\"comment\">//\"red,blue,green\"</span></span><br><span class=\"line\">instance1.sayName(); <span class=\"comment\">//zhai</span></span><br><span class=\"line\">instance1.sayAge(); <span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"原型式继承\">原型式继承</h3>\n<p>基本思想: 也是通过 prototype 完成继承, 只不过在多了一层函数调用。</p>\n<p>优点: 用一个函数包装一个对象, 然后返回这个函数的调用, 这个函数就变成了可以随意增添属性的实例或对象。<code>Object.create()</code> 就是这个原理。</p>\n<p>缺点: 所有的实例都会继承原型上的属性, 无法实现复用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先封装一个函数容器, 用来承载继承的原型和输出对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = obj;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> super0 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> super1 = object(super0);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(super1 <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生式继承\">寄生式继承</h3>\n<p>基本思想: 寄生式继承的思路与(寄生)构造函数和工厂模式类似, 即创建一个仅用于封装继承过程的函数, 该函数在内部以某种方式来增强对象, 最后再像真的是它做了所有工作一样返回对象。</p>\n<p>优点: 借助原型可以基于已有的对象创建新对象, 同时还不必因此创建自定义类型。</p>\n<p>缺点: 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率, 这一点与构造函数模式类似。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过 prototype 继承</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = obj;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sup = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subobject</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sub = object(obj);</span><br><span class=\"line\">  sub.name = <span class=\"string\">\"ming\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sup2 = subobject(sup);</span><br><span class=\"line\"><span class=\"comment\">// 这个函数经过声明后就成了可增添属性的对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sup2.name); <span class=\"comment\">// 'ming'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sup2 <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生组合式继承\">寄生组合式继承</h3>\n<p>基本思想: 不必为了指定子类型的原型而调用超类型的构造函数。</p>\n<p>优点: 集寄生式继承和组合继承的优点于一身, 是实现基于类型继承的最有效方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 寄生</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = obj;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// object是F实例的另一种表示方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = object(Person.prototype);</span><br><span class=\"line\"><span class=\"comment\">// obj实例（F实例）的原型继承了父类函数的原型</span></span><br><span class=\"line\"><span class=\"comment\">// 上述更像是原型链继承, 只不过只继承了原型属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组合</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">100</span>;</span><br><span class=\"line\">  Person.call(<span class=\"keyword\">this</span>); <span class=\"comment\">// 这个继承了父类构造函数的属性</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 解决了组合式两次调用构造函数属性的特点</span></span><br><span class=\"line\"></span><br><span class=\"line\">Sub.prototype = obj;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Sub.prototype.constructor); <span class=\"comment\">// Person</span></span><br><span class=\"line\">obj.constructor = Sub; <span class=\"comment\">// 重点, 一定要修复实例</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Sub.prototype.constructor); <span class=\"comment\">// Sub</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sub1 = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\"><span class=\"comment\">// Sub实例就继承了构造函数属性, 父类实例, object的函数属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sub1.job); <span class=\"comment\">// frontend</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sub1 <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"es6-关键字-extends-继承\">ES6 关键字 extends 继承</h3>\n<p>ES6 关键字 extends 继承本质也是组合式继承。</p>\n","categories":["front-end"],"tags":["前端面试题"]},{"title":"前端面试题之其它概念(持续更新)","url":"/front-end/other-concepts-of-frontend-interview-questions-continuous-update.html","content":"<h2 id=\"浏览器垃圾回收机制\">浏览器垃圾回收机制</h2>\n<p>浏览器的垃圾回收机制（Garbage collection<br>\n）, 简称 GC, 它会周期性运行以释放那些不需要的内存, 否则, JavaScript 的解释器将会耗尽全部系统内存而导致系统崩溃。具体到浏览器中的实现, 通常有两个策略: 标记清除和引用计数。</p>\n<h3 id=\"引用计数法\">引用计数法</h3>\n<p>此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用）, 对象将被垃圾回收机制回收。引用计数法是最初级的垃圾收集算法, 如果某对象没有其他对象指向它了, 那就说明它可以被回收。但是它无法处理循环引用的问题。我们执行 f 函数, 它返回了一个数字, 和内部的 o1,o2 没什么关系, 但是对引用计数法来说, o1,o2 它们之间还存在着相互引用, 并不会被回收。这就造成了内存泄漏。</p>\n<h3 id=\"标记清除法\">标记清除法</h3>\n<p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。<br>\n从 2012 年起, 所有现代浏览器都使用了标记-清除垃圾回收算法。标记清除法假定存在一个根对象（相当于 js 的全局对象）, 垃圾回收器将定期从根对象开始查找, 凡是从根部出发能扫描到的都会保留, 扫描不到的将被回收。</p>\n<p>内部流程</p>\n<ul>\n<li>垃圾收集器找到所有的根, 并“标记”（记住）它们。</li>\n<li>然后它遍历并“标记”来自它们的所有引用。</li>\n<li>然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住, 以免将来再次遍历到同一个对象。</li>\n<li>……如此操作, 直到所有可达的（从根部）引用都被访问到。</li>\n<li>没有被标记的对象都会被删除。</li>\n</ul>\n<h3 id=\"几种常见的内存泄漏\">几种常见的内存泄漏</h3>\n<ol>\n<li>\n<p>全局变量</p>\n<p>全局变量什么时候需要自动释放内存空间很难判断, 所以在开发中尽量避免使用全局变量, 以提高内存有效使用率。</p>\n</li>\n<li>\n<p>未移除的事件绑定</p>\n<p>dom 元素虽然被移除了, 但元素绑定的事件还在, 如果不及时移除事件绑定, 在 IE9 以下版本容易导致内存泄漏。现代浏览器不存在这个问题了, 了解一下即可</p>\n</li>\n<li>\n<p>定时器 setInterval/setTimeout</p>\n<p>看下面的一段定时器代码, 一旦我们在其它地方移除了 node 节点, 定时器的回调便失去了意义, 然而它一直在执行导致 callback 无法回收, 进而造成 callback 内部掉数据 resData 也无法被回收。所以我们应该及时 clear 定时器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> resData = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> callback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = <span class=\"built_in\">document</span>.querySelecter(<span class=\"string\">\".p\"</span>);</span><br><span class=\"line\">  node &amp;&amp; (node.innerHTML = resData);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">setInterval(callback, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"weakmap-weakset\">WeakMap、WeakSet</h3>\n<p>es6 的 WeakMap 和 Map 类似, 都是用于生成键值对的集合, 不同的是 WeakMap 是一种弱引用, 它的键名所指向的对象, 不计入垃圾回收机制, 另外就是 WeakMap 只接受对象作为键名（null 除外）, 而 Map 可以接受各种类型的数据作为键。</p>\n<p>WeakMap 这种结构有助于防止内存泄漏, 一旦消除对键的引用, 它占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对, 也会自动消失。包括 WeakSet 也是类似的, 内部存储的都是弱引用对象, 不会被计入垃圾回收。</p>\n<p>看一个阮一峰 ES6 文档上举的例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myWeakmap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">myWeakmap.set(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"logo\"</span>), &#123; <span class=\"attr\">timesClicked</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"logo\"</span>).addEventListener(</span><br><span class=\"line\">  <span class=\"string\">\"click\"</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> logoData = myWeakmap.get(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"logo\"</span>));</span><br><span class=\"line\">    logoData.timesClicked++;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">false</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码中, 我们将 dom 对象作为键名, 每次点击, 我们就更新一下状态。我们将这个状态作为键值放在 WeakMap 里。一旦这个 DOM 节点删除, 该状态就会自动消失, 不存在内存泄漏风险。</p>\n<p>WeakSet 和 WeakMap 类似, 它和 set 结构的区别也是两点:</p>\n<p>WeakSet 中的对象都是弱引用, 不会被计入垃圾回收<br>\n成员只能是对象, 而不能是其他类型的值<br>\n所以从垃圾回收的角度来看, 合理的使用 WeakMap 和 WeakSet, 能帮助我们避免内存泄漏。</p>\n<h2 id=\"浏览器工作原理\">浏览器工作原理</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Performance/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\" target=\"_blank\" rel=\"noopener\">MDN 链接</a></p>\n","categories":["front-end"],"tags":["前端面试题"]},{"title":"前端面试题之界面与样式(持续更新)","url":"/front-end/interface-and-style-of-frontend-interview-questions-continuous-update.html","content":"<h2 id=\"html-概念\">Html 概念</h2>\n<h3 id=\"doctype-的作用\">DOCTYPE 的作用</h3>\n<p>告诉浏览器使用哪个版本的 HTML 规范来渲染文档。DOCTYPE 不存在或形式不正确会导致 HTML 文档以混杂模式呈现。<br>\n标准模式（Standards mode）以浏览器支持的最高标准运行；混杂模式（Quirks mode）中页面是一种比较宽松的向后兼容的方式显示。</p>\n<h3 id=\"常见的行内元素有哪些？块级元素有哪些？-空-void-元素有那些？\">常见的行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3>\n<p>行内元素: a span img input select<br>\n块级元素: div h1 p ul ol li dl dt dd<br>\n空元素: <br> <hr> <link> <meta></p>\n<h3 id=\"页面导入样式时-使用-link-和-import-有什么区别？\">页面导入样式时, 使用 link 和@import 有什么区别？</h3>\n<p>相同的地方, 都是外部引用 CSS 方式, 区别:</p>\n<p>link 是 xhtml 标签, 除了加载 css 外, 还可以定义 RSS 等其他事务；@import 属于 CSS 范畴, 只能加载 CSS<br>\nlink 引用 CSS 时候, 页面载入时同时加载；@import 需要在页面完全加载以后加载, 而且@import 被引用的 CSS 会等到引用它的 CSS 文件被加载完才加载<br>\nlink 是 xhtml 标签, 无兼容问题；@import 是在 css2.1 提出来的, 低版本的浏览器不支持<br>\nlink 支持使用 javascript 控制去改变样式, 而@import 不支持<br>\nlink 方式的样式的权重高于@import 的权重<br>\nimport 在 html 使用时候需要<code>&lt;style type=&quot;text/css&quot;&gt;</code>标签</p>\n<h3 id=\"介绍一下你对浏览器内核的理解？\">介绍一下你对浏览器内核的理解？</h3>\n<p>主要分成两部分: 渲染引擎(Layout Engine 或 Rendering Engine)和 JS 引擎。</p>\n<p>渲染引擎: 负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等）, 以及计算网页的显示方式, 然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同, 所以渲染的效果也不相同。<br>\nJS 引擎: 解析和执行 javascript 来实现网页的动态效果。</p>\n<p>最开始渲染引擎和 JS 引擎并没有区分的很明确, 后来 JS 引擎越来越独立, 内核就倾向于只指渲染引擎。</p>\n<h3 id=\"常见的浏览器内核有哪些？\">常见的浏览器内核有哪些？</h3>\n<p>Trident( MSHTML ): IE MaxThon TT The World 360 搜狗浏览器<br>\nGeckos: Netscape6 及以上版本 FireFox Mozilla Suite/SeaMonkey<br>\nPresto: Opera7 及以上(Opera 内核原为: Presto, 现为: Blink)<br>\nWebkit: Safari Chrome</p>\n<h3 id=\"html5-有哪些新特性-移除了那些元素？如何处理-html5-新标签的浏览器兼容问题？如何区分-html-和-html5\">HTML5 有哪些新特性,移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5</h3>\n<p>新增加了图像、位置、存储、多任务等功能。</p>\n<p>新增元素:</p>\n<ul>\n<li>canvas</li>\n<li>用于媒介回放的 video 和 audio 元素</li>\n<li>本地离线存储。localStorage 长期存储数据, 浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除</li>\n<li>语意化更好的内容元素, 比如 article footer header nav section</li>\n<li>位置 API: Geolocation</li>\n<li>表单控件, calendar date time email url search</li>\n<li>新的技术: web worker(web worker 是运行在后台的 JavaScript, 独立于其他脚本, 不会影响页面的性能。您可以继续做任何愿意做的事情: 点击、选取内容等等, 而此时 web worker 在后台运行)</li>\n<li>web socket</li>\n<li>拖放 API: drag、drop</li>\n</ul>\n<p>移除的元素:</p>\n<ul>\n<li>纯表现的元素: basefont big center font s strike tt u</li>\n<li>性能较差元素: frame frameset noframes</li>\n</ul>\n<p>区分:</p>\n<p>DOCTYPE 声明的方式是区分重要因素<br>\n根据新增加的结构、功能来区分</p>\n<h3 id=\"对-html-语义化的理解？\">对 HTML 语义化的理解？</h3>\n<ul>\n<li>去掉或丢失样式的时候能够让页面呈现出清晰的结构。</li>\n<li>有利于 SEO 和搜索引擎建立良好沟通, 有助于爬虫抓取更多的信息, 爬虫依赖于标签来确定上下文和各个关键字的权重。</li>\n<li>方便其它设备解析。</li>\n<li>便于团队开发和维护, 语义化根据可读性。</li>\n</ul>\n<h3 id=\"cookies-sessionstorage-和-localstorage-的区别？\">cookies, sessionStorage 和 localStorage 的区别？</h3>\n<p>共同点: 都是保存在浏览器端, 且是同源的。</p>\n<p>区别:</p>\n<ul>\n<li>cookies 是为了标识用户身份而存储在用户本地终端上的数据, 始终在同源 http 请求中携带, 即 cookies 在浏览器和服务器间来回传递, 而 sessionstorage 和 localstorage 不会自动把数据发给服务器, 仅在本地保存。</li>\n<li>存储大小的限制不同。cookie 保存的数据很小, 不能超过 4k, 而 sessionstorage 和 localstorage 保存的数据大, 可达到 5M。</li>\n<li>数据的有效期不同。cookie 在设置的 cookie 过期时间之前一直有效, 即使窗口或者浏览器关闭。sessionstorage 仅在浏览器窗口关闭之前有效。localstorage 始终有效, 窗口和浏览器关闭也一直保存, 用作长久数据保存。</li>\n<li>作用域不同。cookie 在所有的同源窗口都是共享；sessionstorage 不在不同的浏览器共享, 即使同一页面；localstorage 在所有同源窗口都是共享</li>\n</ul>\n<h3 id=\"iframe-框架有那些优缺点？\">iframe 框架有那些优缺点？</h3>\n<p>优点:</p>\n<ul>\n<li>iframe 能够原封不动的把嵌入的网页展现出来。</li>\n<li>如果有多个网页引用 iframe, 那么你只需要修改 iframe 的内容, 就可以实现调用的每一个页面内容的更改, 方便快捷。</li>\n<li>网页如果为了统一风格, 头部和版本都是一样的, 就可以写成一个页面, 用 iframe 来嵌套, 可以增加代码的可重用。</li>\n<li>如果遇到加载缓慢的第三方内容如图标和广告, 这些问题可以由 iframe 来解决。</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>搜索引擎的爬虫程序无法解读这种页面</li>\n<li>框架结构中出现各种滚动条</li>\n<li>使用框架结构时, 保证设置正确的导航链接。</li>\n<li>iframe 页面会增加服务器的 http 请求</li>\n</ul>\n<h3 id=\"html5-的-form-如何关闭自动完成功能？\">HTML5 的 form 如何关闭自动完成功能？</h3>\n<p>HTML 的输入框可以拥有自动完成的功能, 当你往输入框输入内容的时候, 浏览器会从你以前的同名输入框的历史记录中查找出类似的内容并列在输入框下面, 这样就不用全部输入进去了, 直接选择列表中的项目就可以了。但有时候我们希望关闭输入框的自动完成功能, 例如当用户输入内容的时候, 我们希望使用 AJAX 技术从数据库搜索并列举而不是在用户的历史记录中搜索。</p>\n<p>方法:</p>\n<ul>\n<li>在 IE 的 internet 选项菜单中里的自动完成里面设置</li>\n<li>设置 form 输入框的 autocomplete 为 on 或者 off 来来开启输入框的自动完成功能</li>\n</ul>\n<h3 id=\"如何实现浏览器内多个标签页之间的通信\">如何实现浏览器内多个标签页之间的通信?</h3>\n<ul>\n<li>WebSocket SharedWorker</li>\n<li>也可以调用 localstorge、cookies 等本地存储方式。 localstorge 在另一个浏览上下文里被添加、修改或删除时, 它都会触发一个事件, 我们通过监听事件, 控制它的值来进行页面信息通信。<br>\n注意: Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常</li>\n</ul>\n<h3 id=\"元素的-alt-和-title-有什么异同？\">元素的 alt 和 title 有什么异同？</h3>\n<p>在 alt 和 title 同时设置的时候, alt 作为图片的替代文字出现, title 是图片的解释文字。</p>\n<h2 id=\"css-概念\">CSS 概念</h2>\n<h3 id=\"盒模型概念\">盒模型概念</h3>\n<p>盒模型分为标准盒模型与怪异盒模型( 也称为 IE 盒模型 )</p>\n<p>标准盒模型下 width 和 height 为内容的宽高, 怪异盒模型下 width 和 height 为内容的宽高加上 border 的宽高, 再加上 padding 的宽高。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Chrome 默认标准盒模型 */</span></span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: <span class=\"string\">\"content-box\"</span>; <span class=\"comment\">/* 标准盒模型 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: <span class=\"string\">\"border-box\"</span>; <span class=\"comment\">/* 怪异盒模型 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大部分的开源组件库, 例如 ant-design 都使用怪异盒模型, 不会造成布局破坏。</p>\n<h3 id=\"常见的垂直水平居中方法\">常见的垂直水平居中方法</h3>\n<p>通过样式处理</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 方法一, 子级知道宽高 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 方法二, 使用 margin: auto */</span></span><br><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 方法三, 子级不知道宽高, 使用 transform  */</span></span><br><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-<span class=\"number\">50%</span>, -<span class=\"number\">50%</span>);</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 方法四, 使用 flex 布局 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 方法六, 利用 table-cell 布局 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">  <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 js 处理样式, 本质与 css 处理一致</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法五 js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> parentWidth = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"parent\"</span>).clientWidth,</span><br><span class=\"line\">  parentHeight = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"parent\"</span>).clientHeight,</span><br><span class=\"line\">  childWidth = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"child\"</span>).clientWidth,</span><br><span class=\"line\">  childHeight = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"child\"</span>).clientHeight;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"parent\"</span>).style.position = <span class=\"string\">\"relative\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"child\"</span>).style.position = <span class=\"string\">\"absolute\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((parentWidth - childWidth) / <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"child\"</span>).style.left =</span><br><span class=\"line\">  (parentWidth - childWidth) / <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"child\"</span>).style.top =</span><br><span class=\"line\">  (parentHeight - childHeight) / <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"px-em-rem-概念\">px, em, rem 概念</h3>\n<ul>\n<li>\n<p>px 像素。绝对单位, 像素 px 是相对于显示器屏幕分辨率而言的, 是一个虚拟单位。是计算机系统的数字化图像长度单位, 如果 px 要换算成物理长度, 需要指定精度 DPI。</p>\n</li>\n<li>\n<p>em 是相对长度单位, 相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置, 则相对浏览器的默认字体尺寸。它会继承父级元素的字体大小, 因此并不是一个固定的值。</p>\n</li>\n<li>\n<p>rem 是 CSS3 新增的一个相对单位(root em,根 em),使用 rem 为元素设定字体大小事, 仍然是相对大小但相对的只是 HTML 根元素。</p>\n<p>区别: IE 无法调用那些使用 px 作为单位的字体大小, 而 em 和 rem 可以缩放, rem 相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身, 通过它既可以做到只修改根元素就成比例地调整所有字体大小, 又可以避免字体大小逐层复合的连锁反应。目前, 除了 IE8 及更早版本外, 所有浏览器已支持 rem。</p>\n</li>\n</ul>\n<h3 id=\"css3-新特性\">CSS3 新特性</h3>\n<ul>\n<li>颜色: 新增 RGBA, HSLA 模式</li>\n<li>文字阴影(text-shadow)</li>\n<li>边框: 圆角（border-radius）边框阴影: box-shadow</li>\n<li>盒子模型: box-sizing</li>\n<li>背景: background-size 设置背景图片的尺寸, background-origin 设置背景图片的原点, background-clip 设置背景图片的裁剪区域, 以“, ”分隔可以设置多背景, 用于自适应布局</li>\n<li>渐变: linear-gradient, radial-gradient</li>\n<li>过渡: transition 可实现动画</li>\n<li>自定义动画</li>\n<li>在 CSS3 中唯一引入的伪元素是 <code>::selection</code></li>\n<li>多媒体查询, 多栏布局</li>\n<li>border-image</li>\n<li>2D 转换: transform:translate(x,y)rotate(x,y)skew(x,y)scale(x,y)</li>\n<li>3D 转换</li>\n</ul>\n<h3 id=\"display-none-与-visibility-hidden-的区别是什么\">display:none; 与 visibility:hidden 的区别是什么?</h3>\n<p><code>display:none;</code> 使用该属性后, HTML 元素（对象）的宽高, 高度等各种属性值都将“丢失”；<br>\n<code>visibility:hidden;</code> 使用该属性后, HTML 元素（对象）仅仅是在视觉上看不见（完全透明）, 而它所占据的空间位置仍然存在, 也即是说它仍然具有高度, 宽度等属性值。</p>\n<h3 id=\"css-选择符有哪些？优先级算法如何计算？内联和-important-哪个优先级高？\">css 选择符有哪些？优先级算法如何计算？内联和 !important 哪个优先级高？</h3>\n<p>css 选择符有: 类选择器、标签选择器、ID 选择器、后代选择器（派生选择器）、群组选择器<br>\n:link、:visited、:hover、:active 按照 LVHA（LoVe HAte）顺序定义</p>\n<table>\n<thead>\n<tr>\n<th>等级</th>\n<th>标签内选择符</th>\n<th>ID 选择符</th>\n<th>Class 选择符/属性选择符/伪类选择符</th>\n<th>元素选择符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>示例</td>\n<td><code>&lt;span style=&quot;color:red;&quot;&gt;</code></td>\n<td>#text{color:red;}</td>\n<td>.text{color:red;} [type=“text”]{color:red}</td>\n<td>span{color:red;}</td>\n</tr>\n<tr>\n<td>标记位</td>\n<td>x,0,0,0</td>\n<td>0,x,0,0</td>\n<td>0,0,x,0</td>\n<td>0,0,0,x</td>\n</tr>\n</tbody>\n</table>\n<p>特点:</p>\n<ul>\n<li>每个等级的初始值为 0,</li>\n<li>每个等级的叠加为选择器出现的次数相加</li>\n<li>不可进位, 比如 0,99,99,99</li>\n<li>依次表示为: 0,0,0,0</li>\n<li>每个等级计数之间没关联</li>\n<li>等级判断从左向右, 如果某一位数值相同, 则判断下一位数值</li>\n<li>如果两个优先级相同, 则最后出现的优先级高, !important 也适用</li>\n<li>通配符选择器的特殊性值为: 0,0,0,0</li>\n<li>继承样式优先级最低, 通配符样式优先级高于继承样式</li>\n</ul>\n<p>!important 优先级最高。</p>\n<h3 id=\"flex-布局概念\">FLEX 布局概念</h3>\n<p><img src=\"/img/blog_img/prototype.png\" alt=\"prototype\"></p>\n<h4 id=\"flex-容器的属性\">flex 容器的属性</h4>\n<ul>\n<li>flex-direction 属性决定主轴的方向（即项目的排列方向）。</li>\n<li>flex-wrap 定义如何换行</li>\n<li>flex-flow 是 flex-direction flex-wrap 的缩写</li>\n<li>justify-content 定义主轴的对齐方式</li>\n<li>align-items 定义交叉轴上的对齐方式</li>\n<li>align-content 定义多个轴的对齐方式</li>\n</ul>\n<h4 id=\"flex-item-的属性\">flex item 的属性</h4>\n<ul>\n<li>order 定义项目的排序, 越小越靠前</li>\n<li>flex-grow 定义 item 放大比例, 默认为 0</li>\n<li>flex-shrink 定义 item 缩小比例, 默认为 1</li>\n<li>flex-basis 定义了在分配多余空间之前, 项目占据的主轴空间（main size）。</li>\n<li>flex 是 flex-grow, flex-shrink 和 flex-basis 的简写, 默认值为 0 1 auto。</li>\n<li>align-self 允许单个项目有与其他项目不一样的对齐方式, 可覆盖 align-items 属性。</li>\n</ul>\n<h3 id=\"bfc\">BFC</h3>\n<p>BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域, 只有 Block-level box 参与, 它规定了内部的 Block-level Box 如何布局,</p>\n<p>并且与这个区域外部毫不相干。</p>\n<p>BFC 布局规则:</p>\n<ul>\n<li>内部的 Box 会在垂直方向, 一个接一个地放置。</li>\n<li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li>\n<li>每个元素的 margin box 的左边, 与包含块 border box 的左边相接触(对于从左往右的格式化, 否则相反)。即使存在浮动也是如此。</li>\n<li>BFC 的区域不会与 float box 重叠。</li>\n<li>BFC 就是页面上的一个隔离的独立容器, 容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算 BFC 的高度时, 浮动元素也参与计算</li>\n</ul>\n<h3 id=\"css-鼠标禁用事件\">css 鼠标禁用事件</h3>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">pointer-envets</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["front-end"],"tags":["前端面试题"]},{"title":"基于g6的流程图编辑器Demo","url":"/front-end/demo-of-flow-chart-editor-based-on-g6.html","content":"<h2 id=\"✨-特点\">✨ 特点</h2>\n<ul>\n<li>拖拽式更新工作流程图</li>\n<li>数据与图双向转换</li>\n</ul>\n<h2 id=\"📦-原理\">📦 原理</h2>\n<h3 id=\"拖拽\">拖拽</h3>\n<p>基于 <code>react-dnd</code> 和 <code>react-dnd-html5-backend</code> 创建拖拽节点与背景画布。</p>\n<h3 id=\"图\">图</h3>\n<p>基于 <code>g6</code> 创建可视化图，根据 api 提供的 <code>registerBehavior</code> 注册行为，监听鼠标事件，基于 g6 提供的 <code>ToolBar</code>, <code>Menu</code>, <code>Minimap</code>, <code>Grid</code> 等插件，提供更多功能。</p>\n<h3 id=\"样式\">样式</h3>\n<p>基于 <code>antd</code> 提供的 UI 组件优化样式。</p>\n<h2 id=\"💡-预览\">💡 预览</h2>\n<p>请查看 <a href=\"https://kavience.github.io/work-flow-editor\" target=\"_blank\" rel=\"noopener\">在线 Demo </a></p>\n<h2 id=\"🔨-说明\">🔨 说明</h2>\n<p>项目仅供学习和参考，或许不适合直接用于项目中，<a href=\"https://github.com/kavience/work-flow-editor\" target=\"_blank\" rel=\"noopener\">项目地址</a>;</p>\n","categories":["front-end"],"tags":["g6","流程图"]},{"title":"世界在发展，人类有进步吗","url":"/think/the-world-is-developing-mankind-progressing.html","content":"<p>本文是受阮一峰老师的博客 <a href=\"http://www.ruanyifeng.com/blog/2020/08/weekly-issue-121.html\" target=\"_blank\" rel=\"noopener\">为什么人类没有越来越闲？</a> 启发，于是想独立的思考更多这个问题。</p>\n<p>地球已经出现几十亿年，人类出现不过区区几百万年，而且真正开始在地球占领统治地位的时间则更短了。有时候我也时常在想，为什么我感觉现在人的生活并没有因为人类统治地位而更轻松？很明显，近现代一两百年的科技发展，将人类带上了一个新的台阶，我觉得这个变化不亚于人类第一次用火和人类第一次有国家、文明的概念。按理说，科技如此发展，人类不应该更加团结、和谐的发展吗？而现在这个世界却还存在战争、饥荒、种族歧视等等各种理应不出现在这个时代的东西。我想多思考思考。</p>\n<p>「科学发展快而人类发展慢」，最主要的，我认为就是这个原因了。有点德不配位的感觉。人类普及了电、石油等基础的元素，于是飞速发展了火车、轮船、飞机、电脑等各种缩短时间、空间的工具。那人类的本质有因为这些工具而改变吗？有，但是微不足道。</p>\n<p>因为这些工具，人类爆发了资源的掠夺战，爆发了有史以来最大的战争，发生了南京大屠杀、广岛与长崎原子弹等的人类悲剧。现阶段人类生活看似平稳，实际上也是非常脆弱的，中东现在还陷入战争泥沼，非洲饥荒灾难不断。</p>\n<p>因为这些工具，资本主义更加横行霸道，富的更富，穷的更穷。才会发生如现在这样，资本主义光明正大的宣传 996 ，竟然称之为福报，底层人民的需求得不到关注，花几十年工作，才能在大城市买房，社会矛盾越来越凸显。</p>\n<p>看似平稳的社会其实也是脆弱的很，一旦发生一些难以预测的灾难，例如传播性极强、致死率极高的疾病，难以想象的饥荒灾难等，世界一定会再陷入混乱，生灵涂炭未必不会再发生在地球，作为普通人，也只能默默祈祷了。如果真的发生这一切，感觉以目前人类的程度，是难以抵抗的。希望有招一日，人类真的能够大一统，抛开歧视，人人都能克服自己的虚荣、欲望，成为桃花源中的人，那个时候，人类就可以抵御大部分的灾难了。</p>\n<p>长路漫漫，希望世界永远和平，🙏。</p>\n","categories":["think"],"tags":["人类"]},{"title":"Jest单元测试","url":"/front-end/jest-unit-testing.html","content":"<h2 id=\"what\">What</h2>\n<p>采用 Jest 对 react 项目进行单元测试。</p>\n<h2 id=\"why\">Why</h2>\n<p>曾使用 Mocha 对项目进行过单元测试，但是 Mocha 需要配合一系列工具包( sinon, enzyme, chai, nyc )等，加上 Mocha 对 typescript 支持不是特别友好。所以打算采用 Jest 进行单元测试，目前的测试工具 Mocha、Jest、Ava 区别大致如下：</p>\n<table>\n<thead>\n<tr>\n<th>框架</th>\n<th>断言</th>\n<th>异步</th>\n<th>Mock</th>\n<th>代码覆盖率</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Mocha</td>\n<td>不支持（Chai/power-asset）</td>\n<td>友好</td>\n<td>不支持（Sinon）</td>\n<td>不支持（Istanbul）</td>\n</tr>\n<tr>\n<td>Jest</td>\n<td>默认支持</td>\n<td>友好</td>\n<td>默认支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>Ava</td>\n<td>默认支持</td>\n<td>友好</td>\n<td>不支持（Sinon)</td>\n<td>不支持（Istanbul)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"how\">How</h2>\n<h3 id=\"配置包与命令\">配置包与命令</h3>\n<p>安装所需依赖(采用的 typescript )</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add -D jest babel-jest jest-transform-stub ts-jest enzyme-to-json enzyme enzyme-adapter-react-16</span><br></pre></td></tr></table></figure>\n<p>配置命令</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"cross-env jest\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"test:with-coverage\"</span>: <span class=\"string\">\"cross-env TEST_COVERAGE=true jest\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-jest\">配置 Jest</h3>\n<p>根目录下编辑 jest.config.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  preset: <span class=\"string\">\"ts-jest\"</span>, <span class=\"comment\">// 采用 ts 测试</span></span><br><span class=\"line\">  setupFiles: [<span class=\"string\">\"./jest.setup.js\"</span>],</span><br><span class=\"line\">  transform: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"^.+\\\\.[tj]s?$\"</span>: <span class=\"string\">\"babel-jest\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"^.+\\\\.[tj]sx?$\"</span>: <span class=\"string\">\"babel-jest\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"^.+\\\\.(css|styl|less|sass|scss|png|jpg|ttf|woff|woff2|svg)$\"</span>:</span><br><span class=\"line\">      <span class=\"string\">\"jest-transform-stub\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  moduleNameMapper: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"^@/(.*)$\"</span>: <span class=\"string\">\"&lt;rootDir&gt;/src/$1\"</span>, <span class=\"comment\">// 用 @ 映射当前 src 下的路径</span></span><br><span class=\"line\">    <span class=\"string\">\"^.+.(css|styl|less|sass|scss|png|jpg|ttf|woff|woff2|svg)$\"</span>:</span><br><span class=\"line\">      <span class=\"string\">\"jest-transform-stub\"</span>, <span class=\"comment\">// stub 掉 css|styl|less|sass|scss|png|jpg|ttf|woff|woff2|svg 的测试</span></span><br><span class=\"line\">    <span class=\"string\">\"\\\\.worker.entry.js\"</span>: <span class=\"string\">\"&lt;rootDir&gt;/__mocks__/workerMock.js\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  globals: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"ts-jest\"</span>: &#123;</span><br><span class=\"line\">      tsConfig: <span class=\"string\">\"./tsconfig.test.json\"</span>, <span class=\"comment\">// 指定 ts 测试配置文件</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  collectCoverage: process.env.TEST_COVERAGE ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>, <span class=\"comment\">// 是否需要查看测试覆盖率</span></span><br><span class=\"line\">  collectCoverageFrom: [<span class=\"string\">\"&lt;rootDir&gt;/src/**/*.&#123;ts,tsx&#125;\"</span>, <span class=\"string\">\"!**/node_modules/**\"</span>],</span><br><span class=\"line\">  testPathIgnorePatterns: [<span class=\"string\">\"&lt;rootDir&gt;/dist/\"</span>, <span class=\"string\">\"&lt;rootDir&gt;/node_modules/\"</span>],</span><br><span class=\"line\">  snapshotSerializers: [<span class=\"string\">\"enzyme-to-json/serializer\"</span>],</span><br><span class=\"line\">  transformIgnorePatterns: [<span class=\"string\">\"&lt;rootDir&gt;/dist/\"</span>, <span class=\"string\">\"&lt;rootDir&gt;/node_modules/\"</span>],</span><br><span class=\"line\">  testURL: <span class=\"string\">\"http://localhost\"</span>,</span><br><span class=\"line\">  clearMocks: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>根目录下编辑 jest.setup.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 该文件是运行单元测试前会执行一遍，可以 mock 掉一些报错的东西</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">\"react\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">  global.window.resizeTo = <span class=\"function\">(<span class=\"params\">width, height</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    global.window.innerWidth = width || global.window.innerWidth;</span><br><span class=\"line\">    global.window.innerHeight = height || global.window.innerHeight;</span><br><span class=\"line\">    global.window.dispatchEvent(<span class=\"keyword\">new</span> Event(<span class=\"string\">\"resize\"</span>));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  global.window.scrollTo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">window</span>.matchMedia) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(global.window, <span class=\"string\">\"matchMedia\"</span>, &#123;</span><br><span class=\"line\">      value: jest.fn(<span class=\"function\">(<span class=\"params\">query</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">        matches: query.includes(<span class=\"string\">\"max-width\"</span>),</span><br><span class=\"line\">        addListener: jest.fn(),</span><br><span class=\"line\">        removeListener: jest.fn(),</span><br><span class=\"line\">      &#125;)),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> mockResponse = jest.fn();</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">window</span>, <span class=\"string\">\"location\"</span>, &#123;</span><br><span class=\"line\">    value: &#123;</span><br><span class=\"line\">      hash: &#123;</span><br><span class=\"line\">        endsWith: mockResponse,</span><br><span class=\"line\">        includes: mockResponse,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      assign: mockResponse,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Enzyme = <span class=\"built_in\">require</span>(<span class=\"string\">\"enzyme\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Adapter = <span class=\"built_in\">require</span>(<span class=\"string\">\"enzyme-adapter-react-16\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Enzyme.configure(&#123; <span class=\"attr\">adapter</span>: <span class=\"keyword\">new</span> Adapter() &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(Enzyme.ReactWrapper.prototype, &#123;</span><br><span class=\"line\">  findObserver() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.find(<span class=\"string\">\"ResizeObserver\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  triggerResize() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ob = <span class=\"keyword\">this</span>.findObserver();</span><br><span class=\"line\">    ob.instance().onResize([&#123; <span class=\"attr\">target</span>: ob.getDOMNode() &#125;]);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Current React Version:\"</span>, React.version);</span><br></pre></td></tr></table></figure>\n<p>至此 Jest 项目搭建就已经完成了, 比 Mocha 简单些。</p>\n<h3 id=\"jest-使用\">Jest 使用</h3>\n<p>编写测试文件</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; App <span class=\"keyword\">as</span> TargetComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"../App\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; shallow &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"enzyme\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">\"src &gt; APP\"</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> defaultProps = &#123;</span><br><span class=\"line\">    updateTabs: jest.fn(), <span class=\"comment\">// 模拟 updateTabs 函数</span></span><br><span class=\"line\">    user: &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// shallow 浅拷贝模拟 react 组件</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> render = <span class=\"function\">(<span class=\"params\">props: &#123;&#125; = &#123;&#125;</span>) =&gt;</span></span><br><span class=\"line\">    shallow(&lt;TargetComponent &#123;...defaultProps&#125; &#123;...props&#125; /&gt;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// describe 一个方法</span></span><br><span class=\"line\">  describe(<span class=\"string\">\"componentDidMount\"</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断行为</span></span><br><span class=\"line\">    it(<span class=\"string\">\"should direct return if no tab\"</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 实例化组件</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> component = render(&#123;</span><br><span class=\"line\">        user: &#123;</span><br><span class=\"line\">          permissionsMapping: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"/\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"comment\">// 执行方法</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = component.instance().componentDidMount();</span><br><span class=\"line\">      <span class=\"comment\">// 执行断言</span></span><br><span class=\"line\">      expect(component.instance().props.updateTabs).toBeCalledWith(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">      expect(result).toBeUndefined();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>执行单元测试</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>或者执行单个测试文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 采用 describe.only 方法不行，略坑</span></span><br><span class=\"line\">node_modules/.bin/jest src/components/BaseList/__test__/index.test.tsx</span><br></pre></td></tr></table></figure>\n<p>查看覆盖率</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn <span class=\"built_in\">test</span>:with-coverage</span><br></pre></td></tr></table></figure>\n<p>在跟目录下 coverage 下会生成 html 文件，在浏览器打开查看覆盖率即可，可以在 Jest 配置中配置测试率要求，具体可以查看官网文档。</p>\n<h2 id=\"总结\">总结</h2>\n<p>个人感觉 Jest 比 Mocha 配置简单些，易上手，Mocha 需要配合 sinon 进行 stub，配合 Chai 断言效果才会更好，在使用上 Jest 和 Mocha 并无太大区别。</p>\n<p>(完)</p>\n","categories":["front-end"],"tags":["JavaScript","jest"]},{"title":"一道有趣的JavaScript题","url":"/front-end/an-interesting-javascript-question.html","content":"<h2 id=\"题目\">题目</h2>\n<p>如下为一段代码, 请完善 sum 函数, 使得 sum(1, 2, 3, 4, 5, 6) 函数返回值为 21 , 需要在 sum 函数中调用 asyncAdd 函数, 且不能修改 asyncAdd 函数:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 请在 sum函数中调用此函数, 完成数值计算</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>a 要相加的第一个值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>b 要相加的第二个值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>callback 相加之后的回调函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncAdd</span>(<span class=\"params\">a, b, callback</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, a + b);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 请在此方法中调用asyncAdd方法, 完成数值计算</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;...any&#125;</span> </span>rest 传入的参数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">...rest</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请在此处完善代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> start = <span class=\"built_in\">window</span>.performance.now();</span><br><span class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请保证在调用sum方法之后, 返回结果21</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`程序执行共耗时: <span class=\"subst\">$&#123;<span class=\"built_in\">window</span>.performance.now() - start&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"自己的解决方法\">自己的解决方法</h2>\n<p>题目是在掘金上看到的, 立马开始动手做题, 第一时间想到的就是使用剩余参数, 然后配合 promise 做递归, 下面是我的实现方式:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">...rest</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>, ...others] = rest;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    asyncAdd(a, b, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg1, callBackResult</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (others.length !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        sum(callBackResult, ...others).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          resolve(res);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(callBackResult);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路很简单, 在 sum 函数中, 返回一个 promise , 如果剩余参数的长度为 0 , 则直接 resolve asyncAdd 函数执行的回调的结果, 否则递归调用 sum, 把结果作为第一个 sum 的第一个参数, 剩余参数直接展开, 然后在递归调用的回调中, 再 resolve 结果, 最终达到题目要求。</p>\n<h2 id=\"标准答案\">标准答案</h2>\n<p>比较满意的看了看自己的代码, 觉得不错, 然后看了一下标准答案, 发现, 自己的代码执行速度还是太慢, 看一下别人的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一, 和我的差不多, 但是比我的更简洁。。。</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum1</span>(<span class=\"params\">...rest</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = rest.shift();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> rest) &#123;</span><br><span class=\"line\">    result = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      asyncAdd(result, num, (_, res) =&gt; &#123;</span><br><span class=\"line\">        resolve(res);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二, 重点在于把参数两两分开, 使用 Promise.all 一次执行多个 promise</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum2</span>(<span class=\"params\">...rest</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rest.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rest[<span class=\"number\">0</span>] || <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; rest.length; i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    promises.push(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rest[i + <span class=\"number\">1</span>] === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">          resolve(rest[i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          asyncAdd(rest[i], rest[i + <span class=\"number\">1</span>], (_, result) =&gt; &#123;</span><br><span class=\"line\">            resolve(result);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> sum(...result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法三, 隐氏类型转换 和 promise.all 结合使用</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">...rest</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 隐氏类型转换, 对象 + 数字, 会先调用对象的toString 方法</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">  obj.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> rest) &#123;</span><br><span class=\"line\">    promises.push(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        asyncAdd(obj, num, (_, res) =&gt; &#123;</span><br><span class=\"line\">          resolve(res);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把回调的结果直接给 result, obj下次计算的时候, 会自动调用 toString 方法拿到最新的 result</span></span><br><span class=\"line\">        result = res;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上几种结果, 方法三是最快的, 本想给我的方法也做做优化, 发现我的方法确实没办法优化, 因为我是直接在 sum 里面返回 promise , 没有办法使用 promise.all 。 究其原因, 是因为我第一时间就想到用递归, 而不是 for 循环, 我发现在敲代码的过程中, 类似循环的问题, 能用递归的地方, 我第一想到的方案都是采用递归, 很少很少采用 for 循环去做某件事, 这是为什么呢？看来以后还是得转变一下思路, 递归的效率有的时候不一定是最高的。</p>\n","categories":["front-end"],"tags":["JavaScript"]},{"title":"生命的脆弱","url":"/think/fragility-of-life.html","content":"<blockquote>\n<p>树叶的一生，只是为了归根吗？ – 亚索</p>\n</blockquote>\n<h2 id=\"对生命的疑问\">对生命的疑问</h2>\n<p>每当想起人生的意义的时候，我总是会想起 LOL 中亚索的这句话「树叶的一生，只是为了归根吗？」。我觉得他说的这句话，似乎适合让任何一个失落的人发出这样的呐喊，同时也会产生共鸣，人的一生，其实不也像一片树叶吗？</p>\n<p>树叶源自于树枝，春天发芽，夏天茂盛，秋天落叶，冬天归根。而大多数人，少年时在家乡出生和长大，年轻时外出学习和工作，中年时成家立业，准备退休，年老时解甲归田。人生代代如此，反复循环，那人生究竟有何意义？</p>\n<h2 id=\"对人生的探究\">对人生的探究</h2>\n<p>有人希望大富大贵，有人希望平平淡淡一生，有人希望走遍世界。为什么大家会有这么多不同的想法？我其实一直认为人类，是一种特殊的动物，动物有的行为，人类基本都有。但唯独，好奇与恐惧是人类特有的。七情六欲，动物应该也有这样的行为，但是好奇心和恐惧心里远远不如人类。为什么有人喜欢大富大贵？他好奇那种拥有花不完的钱的感觉。为什么喜欢拥有强大的权力？他好奇那种强大权力的感觉。为什么想环游世界？他好奇那种走遍世界的感觉。为什么有人希望平平淡淡一生？因为恐惧接受一些事物。为什么你能在电影中看到有些人为了活下去，做出各种匪夷所思的事情？因为恐惧死亡。</p>\n<p>基本上，人类的行为大部分在动物身上也发生过，但唯独好奇与恐惧就像是人类特有的。好奇使人类进化的更聪明，恐惧使人类更加珍惜生命。如果生活中凡事发生了一些难以理解的事情，你只要把这件事当做发生在动物身上，基本就能说的通了。还真是有点细思极恐。</p>\n<h2 id=\"生命的脆弱\">生命的脆弱</h2>\n<p>年少时，我一直以为这个世界有鬼怪和神仙存在，我以为只有他们是永远存在的。恐怕，世界上，没有什么生命是永远存在的，人的一生短短几十年，其实脆弱的很。</p>\n<p>为什么我今天会写这么沉重的话题？一方面是因为我很早就自己想过这件事，另一方面是因为前两天去医院检查了一下腰，发现自己腰椎峡部断裂和腰椎滑脱。我相信大部分人，都应该把自己的生命看的非常非常重要，在没有大灾大难的时候，可能总觉得自己能活非常久，其实是我们大意了，生命发生意外的时候，很有可能招呼都不会和你打。我很早前做过一个手术，那种恐惧感可能这辈子都不会忘记，所以当医生说我的腰很严重的时候，我的心里有那么一瞬间非常失落，感觉就像是给我判了死刑一样。其实这还只是中等情况，不至于说威胁生命安全，但是如果真的有一天，人被宣告得了不治之症，有多少人能承受得住这个打击呢？</p>\n<p>我们总觉得发生在别人身上的，很难在自己身上重复，离自己太遥远，其实这就发生在身边。愿所有人，能早点意识到生命的脆弱，或许很多不必要发生的事情，就会少很多。</p>\n","categories":["think"],"tags":["生命"]},{"title":"如果坚持一个行业五年","url":"/think/if-you-stick-to-an-industry-for-five-years.html","content":"<h2 id=\"写在开头\">写在开头</h2>\n<p>这两天确实有点开始焦虑了，准确的来说，我好像一直都很焦虑。最近又有新想法了，想重新捡起 Android ，想做 APP 开发。回想起大学的时候，我一直都好想做 APP 开发，书也买了不少，视频也看了不少，但始终没有坚持下去。刚刚重新看了点关于 Android 的知识，回想起以前的一些‘经验’，不知怎的，有点黯然伤神。</p>\n<p>当初为什么没有坚持下去呢？我一直觉得自己是个很浮躁又很有想法的人，但也正是这种想法让我始终难以在某个领域特别突出。从上大学开始，到现今算算也已经五年了，如果我就一直在做 Android 开发，到今天会怎么样呢？我会不会是这个行业比较牛的人了？我觉得很有可能会。</p>\n<h2 id=\"定义下一个五年\">定义下一个五年</h2>\n<p>实际上我并非是个没有计划的人，相反，我非常喜欢做一些计划，也许计划没有完成，但是计划总能让事情做起来井然有序。我曾在大学的某天心里默默列下我的第一个五年计划，就是大学毕业的那年，存下五万块钱，虽然有点俗气，但好歹也算是完成目标了。我给自己的五年计划往往无关技术、工作、爱情等。很俗，可以说只有钱和人生，像国家的中心目标一样，要以经济建设为中心，如果离开经济，其它一切可能都是浮云。我的下一个人生五年计划，也非常简单，30 岁之前，结婚、生子、存款 30 万。不再不切实际，丢掉幻想。</p>\n<p>说的有点远了，我今天想说的是关于坚持一个行业的五年，我希望我能够坚持某个行业领域 5 年，然后在这个行业里面技术属于全国 20% 以上的水准。可惜的是我还没有确定好目标，这是非常非常不好的。我会一直坚持做前端 5 年吗？我会一直做医疗相关的系统吗？我会一直在广州做 IT 发展吗？这些我都不能确定。但我能确定一个目标，就是我想做自由职业者。而我给自己定义的工作是，不希望给任何人打工，我希望运营某些属于自己的产品，有着不错的收入，带着老婆孩子各个城市居住。</p>\n<h2 id=\"种下一棵树\">种下一棵树</h2>\n<p>人生可没有多少个五年十年可以奋斗，有句话说的好，<code>「种下一棵树最后的时间是十年前，其次是现在」</code>。我想在现在种下一颗树的种子，在五年后看看结果如何。为了自由职业而奋斗，当下我要做的应该就是一直保持奋斗精神，一直学习下去。</p>\n","categories":["think"],"tags":["坚持"]},{"title":"程序员的焦虑","url":"/think/programmers-anxiety.html","content":"<h2 id=\"写在开头\">写在开头</h2>\n<p>有时候我一直怀疑自己不适合做一个程序员，出身普普通通，小学六年从未接触过英语，接触计算机也是因为去网吧打游戏。小时候的我像大多数的人的童年一样，希望以后做个科学家，从没想过去做程序员，那时候连程序员这个职业是什么都不知道。一直到高中，吵着跟爸妈说要买电脑，说是为了学习，实则是为了打游戏。最疯狂的时候，痴迷到什么程度呢？高一高二每次开运动会的时候，我都是在家打游戏度过的。基本不参加一些这样的活动，每天中午回家吃饭的时候，要是没人管着，也会开一把游戏。每年的元旦都放一天假，年年都去网吧通宵。经常晚自习后，还去网吧打两把游戏。（主要是英雄联盟）</p>\n<p>那个时候互联网还不发达，智能手机也刚刚起步，马云的支付宝和淘宝也在那个时候开始火起来，比特币大约 200 多 RMB，虽然那个时候是高中生，但我总希望有一天靠电脑挣钱。在网上查资料，还用自己家的电脑去挖矿，虽然那个时候啥也不懂，但在网上看到说这个值钱。后来，高三毕业，高考总分 500 分，数学 120 多，语文 100 多，英语 120 多，理科才 150 几分，进入了一所二本学校，那个时候不顾任何人反对，就是要填计算机专业。</p>\n<p>在大学里面，学的关于计算机的理论知识太多，且丝毫难以提起学习的兴趣，只能花时间自学，而且还是在第二年才认真开始学习。我觉得这跟大学也有非常大的关系，当然了，主要还是自己的问题，就不展开细说了。</p>\n<p>以上是我的背景，就目前为止，我主要有哪些焦虑呢？</p>\n<h2 id=\"生活\">生活</h2>\n<h3 id=\"生活成本\">生活成本</h3>\n<p>我觉得一切的一切，都是为了生活，不管哪个行业。你想要好的生活，生活成本就会相应的变高，那就必须要好好工作，这是一切努力的前提。</p>\n<p>现在在国内，只要四肢健全，随便找份工作，应该就饿不死，但是大部分人应该都不仅仅想要饿不死吧。虚荣、贪婪等等欲望放大了生活成本。</p>\n<h3 id=\"生活节奏\">生活节奏</h3>\n<p>为了提高工资待遇，前往一线城市打拼，生活节奏就越来越快，就拿自己举例，我发现我的时间变得越来越少，每天都感觉时间不够用。</p>\n<h3 id=\"生活方式\">生活方式</h3>\n<p>每天三点一线，宿舍 - 上班/下班的路上 - 公司，虽然在楼下有办健身卡，但是难以提起动力，下班后就只想回家洗个澡躺着。在公司每天又坐着，腰又累。长此以往，恶性循环。</p>\n<h2 id=\"技术\">技术</h2>\n<p>在大学的时候，我学了汇编、C、C++、Java、安卓、PHP，还研究过微信小程序。学的杂，又学的不深，简直就是一个野生程序员，野蛮生长。</p>\n<p>与其它行业不一样，程序员是要一直保持学习的，倘若长时间不学习，动手能力就会衰退，这是对程序员最致命的一点，<br>\n我相信大部分的人应该意识到了这一点。昨天想学 ReactNative，今天又想学 flutter，明天又想学 kotlin。这简直就是我的写照，我想学好多好多东西，但说实在的，自己的学习能力和坚持能力，只能处于一个中等水平。导致自己在技术上的焦虑更深。</p>\n<h2 id=\"我该怎么做？\">我该怎么做？</h2>\n<p>我现在还是处于这个不定漂浮的状态，我还是没有找到解决的方式处理自己的焦虑，感觉自己就像是处于一个不断恶性循环的牢笼中。我不知道该怎么办，但是，我告诫自己，不要走极端。想起曾经看过的一句话，<code>如果不知道该做什么的时候，就去看书吧，这是唯一不会做错的事情</code>。嗯，于是我开始学起日语了（英语都还没学好，也不知道自己是咋想的）。我不断告诉自己，焦虑是没有用的，只能自己体会这份焦虑和孤独，时间会磨平这一切，我想我要做的应该就是默默努力，不要放弃自己，等待时机。</p>\n","categories":["think"],"tags":["焦虑"]},{"title":"未来的路","url":"/think/the-way-to-future.html","content":"<h2 id=\"序言\">序言</h2>\n<h3 id=\"初衷\">初衷</h3>\n<p>突然有那么一刻，我想写点什么，关于人生的一些思考。本来我曾希望只在博客里面写关于技术的东西，但是有的时候，我觉得总想写点什么才行，脑海里时不时会冒出一些 idea，如果不写下来，没过多久我觉得我就会忘记。所以，这将是我写这个系列的初衷，观点不一定正确，但从我开始写的时候，我也没想过让多少人看，也许根本没有人看，但这无关紧要，几十年后，让年纪大了的自己回头看看曾经 20 多岁的自己的一些想法，我想应该也是及其有趣的。</p>\n<h3 id=\"关于取名\">关于取名</h3>\n<p>为什么叫「 未来的路 」？我没有指明主语，所以我想写的这个系列，肯定不是只关于自己，这条路，也许关于在看这篇文章的你，或者你熟知的某个人，或者是我，亦或者是整个人类。受阮一峰老师的启发，他有一个系列名叫「 未来世界幸存者 」 ，看完后我也给我的这个系列取名为「 未来的路 」。</p>\n<h3 id=\"关于内容\">关于内容</h3>\n<p>我觉得内容将以生活中的小事为主，所谓见微知著，一些小事往往能展现一些大的人生与智慧。其次以国际政治、历史、文化等为背景，可能会谈到一些关乎人类命运的东西，我谈这些主要不是为了要说明什么，更多地可能是关于人性，在我眼里，我觉得有的时候人类与动物并无二样，通过所见所闻，剖析人类人性，直面人的本性，我觉得这也正是我想记录下来的。</p>\n<h3 id=\"关于计划\">关于计划</h3>\n<p>我也是临时起意，感觉并无具体的计划，也许写个三五年，也许写个八年十年，想到哪写到哪，随心所欲，唯一一点对自己的要求就是不写反人类的内容，在所有文章中，保持最中立的一面。</p>\n","categories":["think"],"tags":["路"]},{"title":"Terminal翻墙代理","url":"/tools/terminal-over-the-wall-proxy.html","content":"<h2 id=\"what？\">What？</h2>\n<blockquote>\n<p>通过 <a href=\"https://github.com/rofl0r/proxychains-ng\" target=\"_blank\" rel=\"noopener\">proxychains-ng</a> 实现 terminal 代理</p>\n</blockquote>\n<h2 id=\"why？\">Why？</h2>\n<blockquote>\n<p>目前的代理功能，大部分底层都是基于 socks5、http 等，然后配合插件如 SwitchyOmega 等，实现在浏览器端代理，或者是全局代理，但问题是在 terminal 下仍然不走代理。即使通过 <code>export http_proxy=http://127.0.0.1:1081 https_proxy=http://127.0.0.1:1081</code> 发现还是不行。这几天终于忍受不了，我觉得一定有人跟我一样的想法，肯定有人已经着手在做这件事情。果然，偶然发现 <a href=\"https://github.com/rofl0r/proxychains-ng\" target=\"_blank\" rel=\"noopener\">proxychains-ng</a> 这款开源软件，决定试一下。</p>\n</blockquote>\n<h2 id=\"how？\">How？</h2>\n<p>经过昨天的实践，经过一顿操作后，发现不行，然后就果断关机下班了。今早到公司再打开 terminal 试下，发现昨天已经成功了。</p>\n<h3 id=\"关闭-mac-的-sip\">关闭 Mac 的 SIP</h3>\n<p>重启 Mac，按住 Option 键进入启动盘选择模式，再按 <code>⌘ + R</code> 进入 Recovery 模式。实用工具( Utilities )-&gt; 终端( Terminal )。输入命令 <code>csrutil disable</code> 运行。重启进入系统后，终端里输入 <code>csrutil status</code>，结果中如果有 <code>System Integrity Protection status:disabled</code>。则说明关闭成功。</p>\n<h3 id=\"brew-安装-proxychains-ng\">brew 安装 proxychains-ng</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install proxychains-ng</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置代理\">配置代理</h3>\n<p>brew 安装后，proxychains-ng 的配置文件在 <code>/usr/local/etc/proxychains.conf</code> 下，在文件最后</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\"># 找到 ProxyList</span></span><br><span class=\"line\">[ProxyList]</span><br><span class=\"line\"><span class=\"comment\"># 配置本地已经有的 socks5代理</span></span><br><span class=\"line\">socks5  127.0.0.1 1086</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试效果\">测试效果</h3>\n<p>运行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 curl ipinfo.io</span><br></pre></td></tr></table></figure>\n<p>输出结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[proxychains] config file found: /usr/<span class=\"built_in\">local</span>/etc/proxychains.conf</span><br><span class=\"line\">[proxychains] preloading /usr/<span class=\"built_in\">local</span>/Cellar/proxychains-ng/4.14/lib/libproxychains4.dylib</span><br><span class=\"line\">[proxychains] DLL init: proxychains-ng 4.14</span><br><span class=\"line\">[proxychains] Strict chain  ...  127.0.0.1:1080  ...  ipinfo.io:80  ...  OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"ip\"</span>: <span class=\"string\">\"103.121.211.104\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"city\"</span>: <span class=\"string\">\"Tokyo\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"region\"</span>: <span class=\"string\">\"Tokyo\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"country\"</span>: <span class=\"string\">\"JP\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"loc\"</span>: <span class=\"string\">\"35.6895,139.6917\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"org\"</span>: <span class=\"string\">\"AS4785 xTom\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"postal\"</span>: <span class=\"string\">\"151-0052\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"timezone\"</span>: <span class=\"string\">\"Asia/Tokyo\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"readme\"</span>: <span class=\"string\">\"https://ipinfo.io/missingauth\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"增加别名\">增加别名</h3>\n<p>每次使用都需要输入 <code>proxychains4</code> ，显得太长了，增加别名在 .zshrc 下进行优化，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 增加 alias</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> out=<span class=\"string\">'proxychains4'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"结语\">结语</h3>\n<p>此后，每次在需要翻墙的情况下，只需要在命令前，加上 <code>out</code> 即可。</p>\n<p>当然 proxychains-ng 还有更加丰富的功能，貌似可以实现任意软件的翻墙，但由于我不需要，也没有去研究这个，以后有需要再说吧。</p>\n","categories":["tools"],"tags":["翻墙"]},{"title":"今年计划","url":"/think/plan-this-year.html","content":"<h2 id=\"what\">What?</h2>\n<p>工作闲暇之余想做的一些事。</p>\n<h2 id=\"why\">Why?</h2>\n<p>发现自己想做的事情实在是太多了，一直想做点什么属于自己的东西，零零散散之前一直没做，从现在开始专注于每件事吧！</p>\n<p>终身学习！</p>\n<h2 id=\"how\">How?</h2>\n<h3 id=\"运营一款关于家乡的论坛\">运营一款关于家乡的论坛</h3>\n<p>这个想法其实很早就有，也一直没有行动，现在终于下定决心了。</p>\n<p><a href=\"https://www.yichunbendi.com\" target=\"_blank\" rel=\"noopener\">宜春本地论坛</a> 是一款关于家乡本地的，涵盖交友、话题讨论、本地活动、本地资讯的论坛。配合公众号，推送一下关于家乡的东西。</p>\n<h3 id=\"开发一个通用的-cms-系统\">开发一个通用的 CMS 系统</h3>\n<p>这个想法也是刚刚冒出来的，这个 CMS 系统可能与其他系统不一样，我决定基于 Laravel + React 开发。</p>\n<p>主要功能是：</p>\n<ul>\n<li>包涵基本管理系统功能: RBAC、系统监控等基本功能</li>\n<li>基于 ant-design 和 React，开发一个动态表单功能，通过数据库配置生成表单</li>\n<li>基于配置生成数据列表</li>\n<li>除以上基本功能之外灵活度极高</li>\n</ul>\n<h3 id=\"其它\">其它</h3>\n<ul>\n<li>继续熟练 React 生态</li>\n<li>继续熟练 Laravel 生态</li>\n<li>偶尔看看 Spring Boot</li>\n<li>练习吉他（好久没练了）</li>\n</ul>\n","categories":["think"],"tags":["随笔闲谈","2020计划"]},{"title":"PSR-1基本规范","url":"/php/psr1-basic-specifications.html","content":"<h2 id=\"阅读建议\">阅读建议</h2>\n<blockquote>\n<p>本文是根据 PSR 规范英文文档翻译而来，建议多次阅读以便熟悉这些规范，并在工作中用到这些规范。</p>\n</blockquote>\n<h2 id=\"what\">What?</h2>\n<blockquote>\n<p>一篇翻译而来的 PSR-1 规范</p>\n</blockquote>\n<h2 id=\"why\">Why?</h2>\n<blockquote>\n<p>通过翻译 PSR 规范，掌握 PHP 的开发规范</p>\n</blockquote>\n<h2 id=\"how\">How?</h2>\n<h3 id=\"关键字\">关键字</h3>\n<p>本文中的关键词 <code>&quot;必须&quot;</code>, <code>&quot;禁止&quot;</code>, <code>&quot;必要&quot;</code>, <code>&quot;最好&quot;</code>, <code>&quot;最好不要&quot;</code>, <code>&quot;应该&quot;</code>, <code>&quot;不应该&quot;</code>, <code>&quot;建议&quot;</code>, <code>&quot;可以&quot;</code>, <code>&quot;可选&quot;</code> 应按照 <a href=\"https://www.ietf.org/rfc/rfc2119.txt\" target=\"_blank\" rel=\"noopener\">RFC 2119</a> 的规定进行解释。</p>\n<h3 id=\"概览\">概览</h3>\n<ul>\n<li>\n<p>PHP 文件<code>必须</code>使用 <code>&lt;?php</code> 或者 <code>&lt;?=</code> 标签开始</p>\n</li>\n<li>\n<p>PHP 文件<code>必须</code>使用不带 bom 的 UTF-8 编码</p>\n</li>\n<li>\n<p>PHP 文件<code>应该</code>要么只声明类、函数、变量等，要么引起副作用（例如生成输出，改变 .ini 配置文件等操作），但是<code>不应该</code>两者都做。</p>\n</li>\n<li>\n<p>命名空间和类<code>必须</code>遵循自动加载规范 [PSR-0, PSR-4]</p>\n</li>\n<li>\n<p>PHP 类名<code>必须</code>以大驼峰规范命名，例如 <code>HomeClass</code></p>\n</li>\n<li>\n<p>PHP 类文件中的常量<code>必须</code>使用下划线分隔且以大写形式声明，例如 <code>APP_KEY</code></p>\n</li>\n<li>\n<p>方法名<code>必须</code>以小驼峰规范命名，例如 <code>updateUser</code></p>\n</li>\n</ul>\n<h3 id=\"文件\">文件</h3>\n<h3 id=\"php-标签\">PHP 标签</h3>\n<p>PHP 便签<code>必须</code>使用 <code>&lt;?php ?&gt;</code> 或者 <code>&lt;?= ?&gt;</code> , <code>禁止</code>使用其它标签代替。</p>\n<h3 id=\"字符编码\">字符编码</h3>\n<p>PHP 代码<code>必须</code>使用不带 Bom 的 UTF-8 编码</p>\n<h3 id=\"副作用\">副作用</h3>\n<p>PHP 文件<code>应该</code>要么只声明类、函数、变量等，要么引起副作用（例如生成输出，改变 .ini 配置文件等操作），但是<code>不应该</code>两者都做。</p>\n<p>「副作用」(side effects) 一词的意思是，通过包含文件，但不直接声明类、函数、常量等而执行的逻辑操作。</p>\n<p>「副作用」包含却不仅限于：</p>\n<ul>\n<li>生成输出</li>\n<li>直接的 require 或 include</li>\n<li>连接外部服务</li>\n<li>修改 ini 配置</li>\n<li>抛出错误或异常</li>\n<li>修改全局或静态变量</li>\n<li>读或写文件等</li>\n</ul>\n<p>以下是一个违反此规范的例子：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// 副作用: 根本 ini 设置</span></span><br><span class=\"line\">ini_set(<span class=\"string\">'error_reporting'</span>, E_ALL);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 副作用: 加载文件</span></span><br><span class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">\"file.php\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 副作用: 生成输出</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">\"&lt;html&gt;\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是一个符合此规范的例子：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// 声明 foo 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有条件的声明不产生副作用</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (! function_exists(<span class=\"string\">'bar'</span>)) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名空间和类名\">命名空间和类名</h3>\n<p>命名空间和类<code>必须</code>遵循 PSR 自动加载规范：[PSR-0, PSR-4]。</p>\n<p>根据规范，每个类都独立为一个文件，且命名空间至少有一个层次：顶级的组织名称（vendor name）。</p>\n<p>类的命名<code>必须</code>遵循 StudlyCaps 大写开头的驼峰命名规范。</p>\n<p>PHP 5.3 及以后版本的代码<code>必须</code>使用正式的命名空间。</p>\n<p>例如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// PHP 5.3 以后版本:</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">Vendor</span>\\<span class=\"title\">Model</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.2.x 及之前的版本<code>应该</code>使用伪命名空间的写法，约定俗成使用顶级的组织名称（vendor name）如 Vendor_ 为类前缀。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// PHP 5.2.x 及更早版本:</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vendor_Model_Foo</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类常量-类属性-方法\">类常量、类属性、方法</h3>\n<p>此处的「类」指代所有的类、接口以及可复用代码块（traits）。</p>\n<h4 id=\"常量\">常量</h4>\n<ul>\n<li>PHP 类文件中的常量<code>必须</code>使用下划线分隔且以大写形式声明，例如:</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">Vendor</span>\\<span class=\"title\">Model</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> VERSION = <span class=\"string\">'1.0'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> DATE_APPROVED = <span class=\"string\">'2012-06-01'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"属性\">属性</h4>\n<p>类的属性命名<code>可以</code>遵循：</p>\n<ul>\n<li>大写开头的驼峰式 ($StudlyCaps)</li>\n<li>小写开头的驼峰式 ($camelCase)</li>\n<li>下划线分隔式 ($under_score)</li>\n<li>本规范不做强制要求，但无论遵循哪种命名方式，都<code>应该</code>在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。</li>\n</ul>\n<h4 id=\"方法\">方法</h4>\n<p>方法名<code>必须</code>为小驼峰命名</p>\n","categories":["php"],"tags":["PSR规范"]},{"title":"自建前端错误监控系统","url":"/tools/selfbuilt-frontend-error-monitoring-system.html","content":"<h2 id=\"阅读建议\">阅读建议</h2>\n<blockquote>\n<p>先整体快速阅读一遍，再回头看其中的配置。</p>\n</blockquote>\n<h2 id=\"what？\">What？</h2>\n<blockquote>\n<p>使用开源工具<a href=\"https://github.com/getsentry/sentry\" target=\"_blank\" rel=\"noopener\">sentry</a>，自建一套 bug 监控系统。</p>\n</blockquote>\n<h2 id=\"why？\">Why？</h2>\n<blockquote>\n<p>在日常前端的开发中，当产品部署到线上的时候，前端页面一旦发生错误往往是非常严重，并且难以重现 bug ，为了使得项目中的 bug 可控，bug 监控就显得尤其重要了。然而，现在市面上的 bug 监控软件，可以说并不便宜，这个时候我们可以选择自建一套监控系统。</p>\n</blockquote>\n<h2 id=\"how？\">How？</h2>\n<h3 id=\"准备工具\">准备工具</h3>\n<ul>\n<li>Docker 17.05.0+</li>\n</ul>\n<h3 id=\"下载项目\">下载项目</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:getsentry/onpremise.git</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置文件\">配置文件</h3>\n<ul>\n<li>复制 <strong>sentry/config.example.yml</strong> 为 config.yml</li>\n<li>复制 <strong>sentry/sentry.conf.example.py</strong> 为 <a href=\"http://sentry.conf.py\" target=\"_blank\" rel=\"noopener\">sentry.conf.py</a></li>\n<li>按需编辑 .env 文件</li>\n</ul>\n<p>配置文件上面都有相应的说明，这里就不赘述。</p>\n<p>执行目录下的 <a href=\"http://install.sh\" target=\"_blank\" rel=\"noopener\">install.sh</a> 。<strong>(执行前请调到下一步看常见错误，节省时间。)</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./install.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"常见错误\">常见错误</h3>\n<h4 id=\"数据库连接失败\">数据库连接失败</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">django.db.utils.OperationalError: could not connect to server: Connection refused</span><br></pre></td></tr></table></figure>\n<p>发生以上错误是由于数据库配置失败的问题，sentry 采用的是 postgresSQL ，我在安装的时候，数据库配置的是本机地址，之前也不怎么了解 postgresSQL ，下面是<br>\npostgresSQL 的一些安装配置</p>\n<ul>\n<li>安装 postgresSQL</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 我采用的是 brew 安装，便于管理</span></span><br><span class=\"line\">brew info postgresql@9.5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注意安装后的说明</span></span><br><span class=\"line\">...</span><br><span class=\"line\">If you need to have postgresql@9.5 first <span class=\"keyword\">in</span> your PATH run:</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">'export PATH=\"/usr/local/opt/postgresql@9.5/bin:$PATH\"'</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\">For compilers to find postgresql@9.5 you may need to <span class=\"built_in\">set</span>:</span><br><span class=\"line\">  <span class=\"built_in\">export</span> LDFLAGS=<span class=\"string\">\"-L/usr/local/opt/postgresql@9.5/lib\"</span></span><br><span class=\"line\">  <span class=\"built_in\">export</span> CPPFLAGS=<span class=\"string\">\"-I/usr/local/opt/postgresql@9.5/include\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">To have launchd start postgresql@9.5 now and restart at login:</span><br><span class=\"line\">  brew services start postgresql@9.5</span><br><span class=\"line\">Or, <span class=\"keyword\">if</span> you dont want/need a background service you can just run:</span><br><span class=\"line\">  pg_ctl -D /usr/<span class=\"built_in\">local</span>/var/postgresql@9.5 start</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里执行以下几个命令即可</span></span><br><span class=\"line\"><span class=\"comment\"># 输出到 zsh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export PATH=\"/usr/local/opt/postgresql@9.5/bin:$PATH\"'</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"><span class=\"comment\"># 更新环境</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装后我的文件目录为 /usr/local/var/postgresql@9.5</span></span><br><span class=\"line\"><span class=\"comment\"># 编辑 postgresql.conf ，修改 listen_addresses</span></span><br><span class=\"line\">listen_addresses = <span class=\"string\">'*'</span>          <span class=\"comment\"># what IP address(es) to listen on;</span></span><br><span class=\"line\"><span class=\"comment\"># 编辑 pg_hba.conf ，修改 listen_addresses</span></span><br><span class=\"line\"><span class=\"comment\"># 在文件最后添加</span></span><br><span class=\"line\">host  all  all 0.0.0.0/0 md5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动 postgresql</span></span><br><span class=\"line\">brew services start postgresql@9.5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建数据库用户</span></span><br><span class=\"line\">createuser <span class=\"built_in\">test</span> -P</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建数据库</span></span><br><span class=\"line\">createdb bug-monitor</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录数据库查看</span></span><br><span class=\"line\">psql -U <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># 进入后查看表</span></span><br><span class=\"line\">\\l</span><br><span class=\"line\"><span class=\"comment\"># 可以看到已经存在 bug-monitor 表了</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装 psequel 测试连接（这一步非必须）<br>\n下载安装 psequel ，查看局域网 ip 地址，我的 ip 地址为 192.168.123.95，输入局域网地址测试能否登录，如果可以就说明没什么问题了。</li>\n</ul>\n<h4 id=\"docker-服务未启动\">docker 服务未启动</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure>\n<p>检查 docker 服务是否正常启动</p>\n<p>(完)</p>\n","categories":["tools"],"tags":["sentry"]},{"title":"记一次React项目搭建","url":"/front-end/remember-to-build-a-react-project.html","content":"<h2 id=\"阅读建议\">阅读建议</h2>\n<blockquote>\n<p>先整体快速阅读一遍，再回头看其中的配置。</p>\n</blockquote>\n<h2 id=\"what？\">What？</h2>\n<blockquote>\n<p>通过 npm、webpack、babel、typescript 等工具，自己搭建一次 React 的 typescript 项目。</p>\n</blockquote>\n<h2 id=\"why？\">Why？</h2>\n<blockquote>\n<p>之前用过 next.js、ant-design-pro、create-react-app 等各种脚手架搭建过 react 项目，但是在使用过程中发现这些框架要么灵活性不足、要么打包后的文件过大等，所以决定手动搭建一次项目。</p>\n</blockquote>\n<h2 id=\"how？\">How？</h2>\n<h3 id=\"准备工具\">准备工具</h3>\n<ul>\n<li>node &gt; v10</li>\n</ul>\n<h3 id=\"所需依赖项\">所需依赖项</h3>\n<p>package.json 文件如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"react-demo\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"dev\"</span>: <span class=\"string\">\"cross-env ENVIRONMENT_MODE=dev env-cmd node index.js\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"start\"</span>: <span class=\"string\">\"cross-env ENVIRONMENT_MODE=production env-cmd node index.js\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"build\"</span>: <span class=\"string\">\"webpack --config webpack.product.config.js\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"build:dll\"</span>: <span class=\"string\">\"webpack --config webpack.config.dll.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"kavience\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"license\"</span>: <span class=\"string\">\"ISC\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// babel 包</span></span><br><span class=\"line\">    <span class=\"attr\">\"@babel/core\"</span>: <span class=\"string\">\"^7.10.2\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"@babel/plugin-proposal-class-properties\"</span>: <span class=\"string\">\"^7.10.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"@babel/plugin-proposal-object-rest-spread\"</span>: <span class=\"string\">\"^7.10.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"@babel/preset-env\"</span>: <span class=\"string\">\"^7.10.2\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"@babel/preset-react\"</span>: <span class=\"string\">\"^7.10.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"@babel/preset-typescript\"</span>: <span class=\"string\">\"^7.10.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"babel-loader\"</span>: <span class=\"string\">\"^8.1.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"babel-plugin-import\"</span>: <span class=\"string\">\"^1.13.0\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// koa 相关的包，用于启动服务，代替 webpack-dev-server</span></span><br><span class=\"line\">    <span class=\"attr\">\"koa\"</span>: <span class=\"string\">\"^2.12.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"koa-proxies\"</span>: <span class=\"string\">\"^0.11.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"koa-static\"</span>: <span class=\"string\">\"^5.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"koa2-connect-history-api-fallback\"</span>: <span class=\"string\">\"^0.1.2\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"koa-webpack\"</span>: <span class=\"string\">\"^5.3.0\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// react 相关</span></span><br><span class=\"line\">    <span class=\"attr\">\"react\"</span>: <span class=\"string\">\"^16.13.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"react-dom\"</span>: <span class=\"string\">\"^16.13.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"redux\"</span>: <span class=\"string\">\"^4.0.5\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"redux-thunk\"</span>: <span class=\"string\">\"^2.3.0\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// typescript相关</span></span><br><span class=\"line\">    <span class=\"attr\">\"typescript\"</span>: <span class=\"string\">\"^3.9.5\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"@types/react\"</span>: <span class=\"string\">\"^16.9.35\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"@types/react-dom\"</span>: <span class=\"string\">\"^16.9.8\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"@types/react-redux\"</span>: <span class=\"string\">\"^7.1.9\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"@types/react-router-dom\"</span>: <span class=\"string\">\"^5.1.5\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// webpack 相关</span></span><br><span class=\"line\">    <span class=\"attr\">\"webpack\"</span>: <span class=\"string\">\"^4.43.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"webpack-cli\"</span>: <span class=\"string\">\"^3.3.11\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"webpack-merge\"</span>: <span class=\"string\">\"^4.2.2\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"webpack-bundle-analyzer\"</span>: <span class=\"string\">\"^3.8.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"clean-webpack-plugin\"</span>: <span class=\"string\">\"^3.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"copy-webpack-plugin\"</span>: <span class=\"string\">\"^6.0.2\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"css-loader\"</span>: <span class=\"string\">\"^3.5.3\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"file-loader\"</span>: <span class=\"string\">\"^6.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"html-webpack-plugin\"</span>: <span class=\"string\">\"^4.3.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"less\"</span>: <span class=\"string\">\"^3.11.3\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"less-loader\"</span>: <span class=\"string\">\"^6.1.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"less-vars-to-js\"</span>: <span class=\"string\">\"^1.3.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"mini-css-extract-plugin\"</span>: <span class=\"string\">\"^0.9.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"optimize-css-assets-webpack-plugin\"</span>: <span class=\"string\">\"^5.0.3\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"postcss-loader\"</span>: <span class=\"string\">\"^3.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"url-loader\"</span>: <span class=\"string\">\"^4.1.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"compression\"</span>: <span class=\"string\">\"^1.7.4\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"cross-env\"</span>: <span class=\"string\">\"^7.0.2\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"env-cmd\"</span>: <span class=\"string\">\"^10.1.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"terser-webpack-plugin\"</span>: <span class=\"string\">\"^3.0.3\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// prettierrc 格式化，直接引用 umijs</span></span><br><span class=\"line\">    <span class=\"attr\">\"@umijs/fabric\"</span>: <span class=\"string\">\"^2.1.0\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上这些包，直接网上搜这些就能明白其用处，在此就不赘述。</p>\n<h3 id=\"配置-babel\">配置 babel</h3>\n<p>在根目录下新建 .babelrc 文件：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"@babel/preset-env\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"@babel/preset-typescript\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"@babel/preset-react\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"@babel/proposal-class-properties\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"@babel/proposal-object-rest-spread\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 这里是配置 antd 按需加载</span></span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"import\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"libraryName\"</span>: <span class=\"string\">\"antd\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"style\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-tsconfig-json\">配置 tsconfig.json</h3>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"outDir\"</span>: <span class=\"string\">\"build/dist\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"module\"</span>: <span class=\"string\">\"esnext\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"target\"</span>: <span class=\"string\">\"esnext\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"lib\"</span>: [<span class=\"string\">\"esnext\"</span>, <span class=\"string\">\"dom\"</span>],</span><br><span class=\"line\">    <span class=\"attr\">\"sourceMap\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"allowUnreachableCode\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"allowUnusedLabels\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"baseUrl\"</span>: <span class=\"string\">\".\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"jsx\"</span>: <span class=\"string\">\"preserve\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"allowSyntheticDefaultImports\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"moduleResolution\"</span>: <span class=\"string\">\"node\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"forceConsistentCasingInFileNames\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"noImplicitReturns\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"suppressImplicitAnyIndexErrors\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"noUnusedLocals\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"allowJs\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"skipLibCheck\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"experimentalDecorators\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"strict\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"paths\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这里是添加别名，用 @ 代替 src 目录</span></span><br><span class=\"line\">      <span class=\"attr\">\"@/*\"</span>: [<span class=\"string\">\"./src/*\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"noEmit\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"esModuleInterop\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"resolveJsonModule\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"isolatedModules\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"exclude\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"node_modules\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dist\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"scripts\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"acceptance-tests\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"jest\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"src/setupTests.ts\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"tslint:latest\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"tslint-config-prettier\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-webpack-基本配置\">配置 webpack 基本配置</h3>\n<p>在根目录下新建 webpack.base.config.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; CleanWebpackPlugin &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'clean-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> miniCssExtractPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'mini-css-extract-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> lessToJS = <span class=\"built_in\">require</span>(<span class=\"string\">'less-vars-to-js'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> FilterWarningsPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-filter-warnings-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里是替换 ant-design 的less 样式变量，新建 variables.less</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> themeVariables = lessToJS(fs.readFileSync(path.resolve(__dirname, <span class=\"string\">'./src/assets/less/variables.less'</span>), <span class=\"string\">'utf8'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: [<span class=\"string\">'./src/index.tsx'</span>],</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'js/vendor.[hash].js'</span>,</span><br><span class=\"line\">    path: path.join(__dirname, <span class=\"string\">'/dist'</span>),</span><br><span class=\"line\">    publicPath: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 配置别名</span></span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      <span class=\"string\">'@'</span>: path.resolve(__dirname, <span class=\"string\">'src'</span>),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    extensions: [<span class=\"string\">'.ts'</span>, <span class=\"string\">'.tsx'</span>, <span class=\"string\">'.js'</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(ts|js)x?$/</span>,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif|svg|jpeg)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              name: <span class=\"string\">'img/[name]_[hash:6].[ext]'</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: miniCssExtractPlugin.loader,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: miniCssExtractPlugin.loader,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'less-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              lessOptions: &#123;</span><br><span class=\"line\">                javascriptEnabled: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                modifyVars: themeVariables,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有按需加载，这句是为了忽略浏览器警告</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> FilterWarningsPlugin(&#123;</span><br><span class=\"line\">      exclude: <span class=\"regexp\">/mini-css-extract-plugin[^]*Conflicting order between:/</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"comment\">// 配置 html</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      template: <span class=\"string\">'./public/index.html'</span>,</span><br><span class=\"line\">      favicon: <span class=\"string\">'./public/assets/favicon.png'</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"comment\">// 采用 css 就好了，不用 style-loader ，把 css 统一压缩放入 dist/css 文件夹即可</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> miniCssExtractPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'css/[name].css'</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"comment\">// 配置 dll，基本不会修改的包，采用 dll 的方式引入，</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">      manifest: path.resolve(__dirname, <span class=\"string\">'dist'</span>, <span class=\"string\">'dll'</span>, <span class=\"string\">'manifest.json'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"comment\">// 重新打包的时候，忽略这些文件</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> CleanWebpackPlugin(&#123;</span><br><span class=\"line\">      cleanOnceBeforeBuildPatterns: [<span class=\"string\">'**/*'</span>, <span class=\"string\">'!dll'</span>, <span class=\"string\">'!dll/**'</span>],</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-webpack-开发环境\">配置 webpack 开发环境</h3>\n<p>在根目录下新建 webpack.dev.config.js，直接合并，设置 mode ，打开 source-map 即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> baseConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base.config.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(baseConfig, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'development'</span>,</span><br><span class=\"line\">  devtool: <span class=\"string\">'inline-source-map'</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-webpack-生产环境\">配置 webpack 生产环境</h3>\n<p>在根目录下新建 webpack.production.config.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> baseConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base.config.js'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> opimizeCss = <span class=\"built_in\">require</span>(<span class=\"string\">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> TerserPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'terser-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> BundleAnalyzerPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = merge(baseConfig, &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    runtimeChunk: &#123;</span><br><span class=\"line\">      name: <span class=\"string\">'manifest'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 拆分打包后的 js 文件</span></span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">          filename: <span class=\"string\">'common.js'</span>,</span><br><span class=\"line\">          chunks: <span class=\"string\">'initial'</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">-20</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        vendors: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">'initial'</span>,</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/]/</span>,</span><br><span class=\"line\">          filename: <span class=\"string\">'vendor.js'</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">-10</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        vendorsAsync: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">'async'</span>,</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/]/</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'vendorsAsync'</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        antv: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">'async'</span>,</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/]@antv[\\\\/]/</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'antv'</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">10</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        antd: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">'initial'</span>,</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/]antd[\\\\/]/</span>,</span><br><span class=\"line\">          filename: <span class=\"string\">'antd.js'</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">20</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        moment: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">'async'</span>,</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/]moment[\\\\/]/</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'moment'</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">30</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    minimizer: [</span><br><span class=\"line\">      <span class=\"keyword\">new</span> opimizeCss(),</span><br><span class=\"line\">      <span class=\"keyword\">new</span> TerserPlugin(&#123;</span><br><span class=\"line\">        cache: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        parallel: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        sourceMap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      &#125;),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 打包后分析文件</span></span><br><span class=\"line\">  plugins: [<span class=\"keyword\">new</span> BundleAnalyzerPlugin()],</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-webpack-dll-编译\">配置 webpack dll 编译</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CopyWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'copy-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把 react、react-dom 作为 dll 文件引入</span></span><br><span class=\"line\">    react: [<span class=\"string\">'react'</span>, <span class=\"string\">'react-dom'</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mode: <span class=\"string\">'production'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].dll.[hash:6].js'</span>,</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>, <span class=\"string\">'dll'</span>),</span><br><span class=\"line\">    library: <span class=\"string\">'[name]_dll'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DllPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'[name]_dll'</span>,</span><br><span class=\"line\">      path: path.resolve(__dirname, <span class=\"string\">'dist'</span>, <span class=\"string\">'dll'</span>, <span class=\"string\">'manifest.json'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加项目启动文件\">添加项目启动文件</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cp = <span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> os = <span class=\"built_in\">require</span>(<span class=\"string\">'os'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">static</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-static'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-proxies'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.dev.config.js'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> koaWebpack = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; historyApiFallback &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa2-connect-history-api-fallback'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从 process 中获取变量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  HOST_URL = <span class=\"string\">'http://api.example.com'</span>,</span><br><span class=\"line\">  FORM_DESCRIPTION_URL = <span class=\"string\">'http://api-form.example.com/'</span>,</span><br><span class=\"line\">  APP_PORT = <span class=\"number\">3333</span>,</span><br><span class=\"line\">  ENVIRONMENT_MODE = <span class=\"string\">'dev'</span>,</span><br><span class=\"line\">&#125; = process.env;</span><br><span class=\"line\"><span class=\"keyword\">const</span> isDev = ENVIRONMENT_MODE === <span class=\"string\">'dev'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"><span class=\"comment\">// 打包后的文件的目录</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> staticPath = <span class=\"string\">'./dist'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理白名单</span></span><br><span class=\"line\">server.use(historyApiFallback(&#123; <span class=\"attr\">whiteList</span>: [<span class=\"string\">'/api/*'</span>] &#125;));</span><br><span class=\"line\"><span class=\"comment\">// 指向静态文件</span></span><br><span class=\"line\">server.use(<span class=\"keyword\">static</span>(path.join(__dirname, staticPath)));</span><br><span class=\"line\"><span class=\"comment\">// proxy 代理</span></span><br><span class=\"line\">server.use(</span><br><span class=\"line\">  proxy(<span class=\"string\">'/api/form-descriptions(.*)'</span>, &#123;</span><br><span class=\"line\">    target: FORM_DESCRIPTION_URL,</span><br><span class=\"line\">    changeOrigin: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    logs: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    secure: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">);</span><br><span class=\"line\">server.use(</span><br><span class=\"line\">  proxy(<span class=\"string\">'/api/(.*)'</span>, &#123;</span><br><span class=\"line\">    target: HOST_URL,</span><br><span class=\"line\">    changeOrigin: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    logs: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    secure: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取本机地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getIPAdress</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> interfaces = os.networkInterfaces();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> devName <span class=\"keyword\">in</span> interfaces) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iface = interfaces[devName];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; iface.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> alias = iface[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (alias.family === <span class=\"string\">'IPv4'</span> &amp;&amp; alias.address !== <span class=\"string\">'127.0.0.1'</span> &amp;&amp; !alias.internal) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> alias.address;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (isDev) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> compiler = webpack(config);</span><br><span class=\"line\">  <span class=\"comment\">// 支持热更新</span></span><br><span class=\"line\">  koaWebpack(&#123;</span><br><span class=\"line\">    configPath: path.join(__dirname, <span class=\"string\">'.'</span>, <span class=\"string\">'webpack.dev.config.js'</span>),</span><br><span class=\"line\">  &#125;).then(<span class=\"function\">(<span class=\"params\">middleware</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    server.use(middleware);</span><br><span class=\"line\">    server.listen(APP_PORT, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`apiHostUrl: <span class=\"subst\">$&#123;HOST_URL&#125;</span>, formDescriptionUrl: <span class=\"subst\">$&#123;FORM_DESCRIPTION_URL&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`App running at: http://localhost:<span class=\"subst\">$&#123;APP_PORT&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`- Local: http://localhost:<span class=\"subst\">$&#123;APP_PORT&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`- Network: http://<span class=\"subst\">$&#123;getIPAdress()&#125;</span>:<span class=\"subst\">$&#123;APP_PORT&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isDev) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (process.platform) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">'darwin'</span>:</span><br><span class=\"line\">            cp.exec(<span class=\"string\">`open http://localhost:<span class=\"subst\">$&#123;APP_PORT&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">'win32'</span>:</span><br><span class=\"line\">            cp.exec(<span class=\"string\">`start http://localhost:<span class=\"subst\">$&#123;APP_PORT&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            cp.exec(<span class=\"string\">`open http://localhost:<span class=\"subst\">$&#123;APP_PORT&#125;</span>`</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  server.listen(APP_PORT, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`apiHostUrl: <span class=\"subst\">$&#123;HOST_URL&#125;</span>, formDescriptionUrl: <span class=\"subst\">$&#123;FORM_DESCRIPTION_URL&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`App running at: http://localhost:<span class=\"subst\">$&#123;APP_PORT&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`- Local: http://localhost:<span class=\"subst\">$&#123;APP_PORT&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`- Network: http://<span class=\"subst\">$&#123;getIPAdress()&#125;</span>:<span class=\"subst\">$&#123;APP_PORT&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编辑-env-文件\">编辑 .env 文件</h3>\n<p>.env 文件主要是为了通过配置文件的方式配置变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口</span></span><br><span class=\"line\">APP_PORT=3333</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># api 接口地址</span></span><br><span class=\"line\">HOST_URL=<span class=\"string\">\"http://api.example.com\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 表单配置</span></span><br><span class=\"line\">FORM_DESCRIPTION_URL=<span class=\"string\">\"http://api-form.example.com\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"启动命令\">启动命令</h3>\n<p>再回到 script 命令：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开发模式</span></span><br><span class=\"line\">    <span class=\"attr\">\"dev\"</span>: <span class=\"string\">\"cross-env ENVIRONMENT_MODE=dev env-cmd node index.js\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 生产模式</span></span><br><span class=\"line\">    <span class=\"attr\">\"start\"</span>: <span class=\"string\">\"cross-env ENVIRONMENT_MODE=production env-cmd node index.js\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 打包文件</span></span><br><span class=\"line\">    <span class=\"attr\">\"build\"</span>: <span class=\"string\">\"webpack --config webpack.product.config.js\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 打包 dll 文件</span></span><br><span class=\"line\">    <span class=\"attr\">\"build:dll\"</span>: <span class=\"string\">\"webpack --config webpack.config.dll.js\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(完)</p>\n","categories":["front-end"],"tags":["Reactjs"]},{"title":"Mocha单元测试","url":"/front-end/mocha-unit-test.html","content":"<h2 id=\"什么是单元测试\">什么是单元测试?</h2>\n<p>单元测试( unit testing )，是指对软件中的最小可测试单元进行检查和验证。在前端领域来说，我们主要是针对 JavaScript 的类( class ) 或者方法( function ) 进行单元测试，以增强代码的可靠性和可维护性。下面介绍的是 mocha 单元测试框架。</p>\n<h2 id=\"mocha-测试框架\">mocha 测试框架</h2>\n<p>mocha 是一个测试框架，可以通过 npm 全局安装在本地，或者是局部安装在项目中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局安装</span></span><br><span class=\"line\">npm i -g mocha</span><br><span class=\"line\"><span class=\"comment\"># 局部安装在 dev 环境下</span></span><br><span class=\"line\">npm i --save-dev mocha</span><br></pre></td></tr></table></figure>\n<p>在测试文件中，写入如下代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">n, m</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">\"add\"</span>, () =&gt; &#123;</span><br><span class=\"line\">    it(<span class=\"string\">'should return 2'</span>, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> count = add(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( count !== <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"1 + 1 应该等于2\"</span>)；</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行 mocha</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mocha</span><br><span class=\"line\"><span class=\"comment\"># 或</span></span><br><span class=\"line\">./node_modules/.bin/mocha</span><br><span class=\"line\"><span class=\"comment\"># 或指定文件</span></span><br><span class=\"line\">./node_modules/.bin/mocha --file ./src/__test__/*.test.js</span><br></pre></td></tr></table></figure>\n<p>mocha 命令常用参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Options:</span><br><span class=\"line\"></span><br><span class=\"line\">    -h, --help                  输出帮助信息</span><br><span class=\"line\">    -V, --version               输出mocha的版本号</span><br><span class=\"line\">    -A, --async-only            强制所有的测试用例必须使用callback或者返回一个promise的格式来确定异步的正确性</span><br><span class=\"line\">    -c, --colors                在报告中显示颜色</span><br><span class=\"line\">    -C, --no-colors             在报告中禁止显示颜色</span><br><span class=\"line\">    -g, --growl                 在桌面上显示测试报告的结果</span><br><span class=\"line\">    -O, --reporter-options &lt;k&#x3D;v,k2&#x3D;v2,...&gt;  设置报告的基本选项</span><br><span class=\"line\">    -R, --reporter &lt;name&gt;       指定测试报告的格式</span><br><span class=\"line\">    -S, --sort                  对测试文件进行排序</span><br><span class=\"line\">    -b, --bail                  在第一个测试没有通过的时候就停止执行后面所有的测试</span><br><span class=\"line\">    -d, --debug                 启用node的debugger功能</span><br><span class=\"line\">    -g, --grep &lt;pattern&gt;        用于搜索测试用例的名称，然后只执行匹配的测试用例</span><br><span class=\"line\">    -f, --fgrep &lt;string&gt;        只执行测试用例的名称中含有string的测试用例</span><br><span class=\"line\">    -gc, --expose-gc            展示垃圾回收的log内容</span><br><span class=\"line\">    -i, --invert                只运行不符合条件的测试用例，必须和--grep或--fgrep之一同时运行</span><br><span class=\"line\">    -r, --require &lt;name&gt;        require指定模块</span><br><span class=\"line\">    -s, --slow &lt;ms&gt;             指定slow的时间，单位是ms，默认是75ms</span><br><span class=\"line\">    -t, --timeout &lt;ms&gt;          指定超时时间，单位是ms，默认是200ms</span><br><span class=\"line\">    -u, --ui &lt;name&gt;             指定user-interface (bdd|tdd|exports)中的一种</span><br><span class=\"line\">    -w, --watch                 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha</span><br><span class=\"line\">    --check-leaks               检测全局变量造成的内存泄漏问题</span><br><span class=\"line\">    --full-trace                展示完整的错误栈信息</span><br><span class=\"line\">    --compilers &lt;ext&gt;:&lt;module&gt;,...  使用给定的模块来编译文件</span><br><span class=\"line\">    --debug-brk                 启用nodejs的debug模式</span><br><span class=\"line\">    --es_staging                启用全部staged特性</span><br><span class=\"line\">    --harmony&lt;_classes,_generators,...&gt;     all node --harmony* flags are available</span><br><span class=\"line\">    --preserve-symlinks                     告知模块加载器在解析和缓存模块的时候，保留模块本身的软链接信息</span><br><span class=\"line\">    --icu-data-dir                          include ICU data</span><br><span class=\"line\">    --inline-diffs              用内联的方式展示actual&#x2F;expected之间的不同</span><br><span class=\"line\">    --inspect                   激活chrome浏览器的控制台</span><br><span class=\"line\">    --interfaces                展示所有可用的接口</span><br><span class=\"line\">    --no-deprecation            不展示warning信息</span><br><span class=\"line\">    --no-exit                   require a clean shutdown of the event loop: mocha will not call process.exit</span><br><span class=\"line\">    --no-timeouts               禁用超时功能</span><br><span class=\"line\">    --opts &lt;path&gt;               定义option文件路径</span><br><span class=\"line\">    --perf-basic-prof           启用linux的分析功能</span><br><span class=\"line\">    --prof                      打印出统计分析信息</span><br><span class=\"line\">    --recursive                 包含子目录中的测试用例</span><br><span class=\"line\">    --reporters                 展示所有可以使用的测试报告的名称</span><br><span class=\"line\">    --retries &lt;times&gt;           设置对于失败的测试用例的尝试的次数</span><br><span class=\"line\">    --throw-deprecation         无论任何时候使用过时的函数都抛出一个异常</span><br><span class=\"line\">    --trace                     追踪函数的调用过程</span><br><span class=\"line\">    --trace-deprecation         展示追踪错误栈</span><br><span class=\"line\">    --use_strict                强制使用严格模式</span><br><span class=\"line\">    --watch-extensions &lt;ext&gt;,... --watch监控的扩展</span><br><span class=\"line\">    --delay                     异步测试用例的延迟时间</span><br><span class=\"line\">    --extension                 指定测试文件后缀</span><br><span class=\"line\">    --file                      指定测试文件目录</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>除了以上命令参数外，可以输入 <code>mocha -h</code> 查看更多命令参数。更多关于 mocha 的使用，请看<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"chai-断言库\">chai 断言库</h2>\n<p>为了更友好的显示测试结果，可以使用 chai 断言库:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 chai</span></span><br><span class=\"line\">npm i --save-dev chai</span><br></pre></td></tr></table></figure>\n<p>使用方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里是 es5 的使用方法，使用 ES6 在下面会讲到</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">\"chai\"</span>).expect;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">n, m</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">\"add\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  it(<span class=\"string\">\"should return 2\"</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = add(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    expect(count).to.eqls(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>更多关于 chai 的使用请看<a href=\"https://www.chaijs.com/\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"使用-es6\">使用 ES6</h2>\n<p>如果我们要在测试文件中写 ES6 语法的话，需要通过 <code>@babel/register</code> 编译</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 babel</span></span><br><span class=\"line\">npm i @babel/register</span><br><span class=\"line\"><span class=\"comment\"># 运行时添加 --require</span></span><br><span class=\"line\">./node_modules/.bin/mocha --require @babel/register --file ./src/__test__/*.js</span><br></pre></td></tr></table></figure>\n<p>这个时候测试文件就可以写 ES6 的语法了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; expect &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"chai\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; add &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./add\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">\"add\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  it(<span class=\"string\">\"should return 2\"</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = add(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    expect(count).to.eqls(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-sinon-进行截取和模拟函数\">使用 sinon 进行截取和模拟函数</h2>\n<p>sinon 提供 stub 和 spy 等函数进行截取和模拟真实函数，以更简单的方式进行测试:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; expect &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"chai\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; stub &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"sinon\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> calc <span class=\"keyword\">from</span> <span class=\"string\">\"./calc\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// describe 可以嵌套，通常一个测试只测试某一个文件，现在测试 calc 整个文件</span></span><br><span class=\"line\">describe(<span class=\"string\">\"calc\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 最好不要这样直接 stub 要测试的方法，不然还测试什么呢？</span></span><br><span class=\"line\">  decribe(<span class=\"string\">\"add\"</span>, () =&gt; &#123;</span><br><span class=\"line\">    it(<span class=\"string\">\"should return 2\"</span>, () =&gt; &#123;</span><br><span class=\"line\">      calcAddStub = stub(calc, <span class=\"string\">\"add\"</span>).returns(<span class=\"number\">2</span>); <span class=\"comment\">// 仅仅为了举例</span></span><br><span class=\"line\">      expect(calcAddStub()).to.eqls(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// 还可以通过 resolves 模拟异步操作</span></span><br><span class=\"line\">  decribe(<span class=\"string\">\"calc time\"</span>, () =&gt; &#123;</span><br><span class=\"line\">    it(<span class=\"string\">\"should return correct time\"</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> calcTimeStub = stub(calc, <span class=\"string\">\"add\"</span>).resolves(<span class=\"number\">2</span>); <span class=\"comment\">// 仅仅为了举例</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> count = <span class=\"keyword\">await</span> calcTimeStub();</span><br><span class=\"line\">      expect(count).to.eqls(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>更多关于 sinon 的使用请看<a href=\"https://sinonjs.org/\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"使用-enzyme-浅拷贝-react-组件\">使用 enzyme 浅拷贝 React 组件</h2>\n<p>如果要测试 React 组件，可以使用 enzyme 进行模拟</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; expect &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"chai\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; stub &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"sinon\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; shallow &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"enzyme\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">\"./App\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">\"App\"</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> defaultProps = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> render = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> shallow(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> &#123;<span class=\"attr\">...props</span>&#125; &#123;<span class=\"attr\">...defaultProps</span>&#125; /&gt;</span></span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  decribe(<span class=\"string\">\"add\"</span>, () =&gt; &#123;</span><br><span class=\"line\">    it(<span class=\"string\">\"should return 2\"</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> component = render();</span><br><span class=\"line\">      <span class=\"keyword\">const</span> count = component.instance().add(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">      expect(count).to.eqls(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>更多关于 enzyme 的使用请看<a href=\"https://airbnb.io/enzyme/\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"使用-istanbul-查看测试覆盖率\">使用 Istanbul 查看测试覆盖率</h2>\n<p>一般项目都需要达到某一覆盖率以上，以确保代码的健壮性，可以使用 Istanbul (伊斯坦布尔) 包。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装，Istanbul 包改名了，叫 nyc</span></span><br><span class=\"line\">npm i --save-dev nyc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行</span></span><br><span class=\"line\">./node_modules/.bin/nyc ./node_modules/.bin/mocha --require @babel/register --file ./src/__test__/*.test.js</span><br></pre></td></tr></table></figure>\n<p>运行会重新跑一次测试，并且在当前目录生成 .coverage 目录，可以直接在浏览器打开并且查看覆盖率。</p>\n<p>更多关于 enzyme 的使用请看<a href=\"https://istanbul.js.org/\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"结语\">结语</h2>\n<p>本篇文章只是简单介绍 js 的单元测试流程，使用的技术包括但不限于 mocha (测试框架), chai (断言库), sinon (截取和模拟函数), enzyme (测试 React 等库), Istanbul (查看覆盖率)。在实际应用中，还需要更多的实际操作，例如测试流程和规范，有的项目中需要测试 渲染的 dom 和 dom 中的属性是否正确，有的仅测试方法，当然还有其他的测试框架例如 jest 等，由于 <s>太懒</s> 篇幅有限，点到为止。</p>\n<p>(done)</p>\n","categories":["front-end"],"tags":["mocha","单元测试"]},{"title":"Js 进阶之执行上下文和执行栈","url":"/front-end/js-advanced-execution-context-and-stack.html","content":"<h2 id=\"什么是-javascript-执行上下文？\">什么是 JavaScript 执行上下文？</h2>\n<blockquote>\n<p>执行上下文是评估和执行 JavaScript 代码的环境的抽象概念，Javascript 代码都是在执行上下文中运行。</p>\n</blockquote>\n<h2 id=\"什么是-javascript-执行栈？\">什么是 JavaScript 执行栈？</h2>\n<blockquote>\n<p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。<br>\n首次运行 JS 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。<br>\n根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文控制权将移到当前执行栈的下一个执行上下文。</p>\n</blockquote>\n<h2 id=\"执行上下文的类型\">执行上下文的类型</h2>\n<p>执行上下文总共有三种类型</p>\n<ul>\n<li>全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，nodejs 中的全局对象就是 module 对象, this 指向这个全局对象。</li>\n<li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</li>\n<li>Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用。</li>\n</ul>\n<h2 id=\"执行上下文的创建\">执行上下文的创建</h2>\n<p>执行上下文分两个阶段创建：</p>\n<ol>\n<li>创建阶段</li>\n<li>执行阶段</li>\n</ol>\n<h3 id=\"创建阶段\">创建阶段</h3>\n<p>1、确定 this 的值，也被称为 This Binding。<br>\n2、LexicalEnvironment（词法环境） 组件被创建。<br>\n3、VariableEnvironment（变量环境） 组件被创建。</p>\n<h4 id=\"this-binding\">This Binding</h4>\n<ul>\n<li>全局执行上下文中， this 的值指向全局对象，在浏览器中 this 的值指向 window 对象，而在 nodejs 中指向这个文件的 module 对象。</li>\n<li>函数执行上下文中， this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new 绑定、箭头函数等，详情请看<a href=\"#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87\">函数执行上下文</a></li>\n</ul>\n<h4 id=\"词法环境-lexical-environment\">词法环境（Lexical Environment）</h4>\n<p>词法环境有两个组成部分</p>\n<ol>\n<li>\n<p>环境记录：存储变量和函数声明的实际位置</p>\n</li>\n<li>\n<p>对外部环境的引用：可以访问其外部词法环境</p>\n</li>\n</ol>\n<p>词法环境有两种类型</p>\n<ol>\n<li>\n<p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null 。拥有一个全局对象（ window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量， this 的值指向这个全局对象。</p>\n</li>\n<li>\n<p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p>\n</li>\n</ol>\n<h4 id=\"变量环境\">变量环境</h4>\n<p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p>\n<p>在 ES6 中，词法环境和变量环境的区别在于前者用于存储 <strong>函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）</strong> 绑定。</p>\n<blockquote>\n<p><strong>变量提升</strong>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// foo2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"foo1\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// foo1，foo重新赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"foo2\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// foo1</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 函数声明优先级高于变量声明，同一作用域下存在多个同名函数声明，后面的会替换前面的函数声明。</p>\n<h3 id=\"执行阶段\">执行阶段</h3>\n<p>此阶段，完成对所有变量的分配，最后执行代码。</p>\n<p>如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。</p>\n<h2 id=\"执行上下文栈\">执行上下文栈</h2>\n<p>因为 JS 引擎创建了很多的执行上下文，所以 JS 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p>\n<p>当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext 。</p>\n<p>观察以下两段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">\"global scope\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope = <span class=\"string\">\"local scope\"</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">\"global scope\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope = <span class=\"string\">\"local scope\"</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope()();</span><br></pre></td></tr></table></figure>\n<p>它们的运行结果是一样的，但执行上下文栈的变化不一样。<br>\n第一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">ECStack.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">checkscope</span>&gt;</span> functionContext);</span></span><br><span class=\"line\">ECStack.push(&lt;f&gt; functionContext);</span><br><span class=\"line\">ECStack.pop();</span><br><span class=\"line\">ECStack.pop();</span><br></pre></td></tr></table></figure>\n<p>第二段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">ECStack.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">checkscope</span>&gt;</span> functionContext);</span></span><br><span class=\"line\"><span class=\"xml\">ECStack.pop();</span></span><br><span class=\"line\">ECStack.push(&lt;f&gt; functionContext);</span><br><span class=\"line\">ECStack.pop();</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数执行上下文\">函数执行上下文</h2>\n<p>上面提到过<a href=\"#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%B1%BB%E5%9E%8B\">执行上下文的类型</a>有全局执行上下文和函数执行上下文。</p>\n<p>在函数上下文中，用活动对象( activation object, AO )来表示变量对象。</p>\n<p>活动对象和变量对象的区别在于</p>\n<p>1、变量对象（ VO ）是规范上或者是 JS 引擎上实现的，并不能在 JS 环境中直接访问。<br>\n2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（ AO ），这时候活动对象上的各种属性才能被访问。<br>\n调用函数时，会为其创建一个 Arguments 对象，并自动初始化局部变量 arguments ，指代该 Arguments 对象。所有作为参数传入的值都会成为 Arguments 对象的数组元素。</p>\n<h3 id=\"执行过程\">执行过程</h3>\n<p>执行上下文的代码会分成两个阶段进行处理</p>\n<ol>\n<li>进入执行上下文</li>\n<li>代码执行</li>\n</ol>\n<h4 id=\"进入执行上下文\">进入执行上下文</h4>\n<p>很明显，这个时候还没有执行代码，此时的变量对象会包括（如下顺序初始化）：</p>\n<ol>\n<li><strong>函数的所有形参 ( only 函数上下文)</strong>：没有实参，属性值设为 undefined 。</li>\n<li><strong>函数声明</strong>：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</li>\n<li><strong>变量声明</strong>：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</li>\n</ol>\n<h4 id=\"代码执行\">代码执行</h4>\n<p>这个阶段会顺序执行代码，修改变量对象的值，执行完成后 AO 如下</p>\n<h3 id=\"总结如下：\">总结如下：</h3>\n<ol>\n<li>全局上下文的变量对象初始化是全局对象</li>\n<li>函数上下文的变量对象初始化只包括 Arguments 对象</li>\n<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li>\n<li>在代码执行阶段，会再次修改变量对象的属性值</li>\n</ol>\n<p>(done)</p>\n","categories":["front-end"],"tags":["JavaScript"]},{"title":"Hello World","url":"/think/hello-world.html","content":"<h2 id=\"hello-world\">Hello World</h2>\n<p>试过各种各样的博客搭建平台，最终还是决定依托 HEXO 搭建，我觉得我的博客不需要有多少多复杂的功能，只需要简单清新一点就好了。</p>\n<h2 id=\"目的\">目的</h2>\n<p>做事总是带点目的性，个人博客于我而言，就像是网络上的一个家，这是属于自己的地盘，在网络上有了归属感，我想写点什么、记录点什么，都是自己决定。</p>\n<p>希望能一直纯粹下去。^_^</p>\n","categories":["think"],"tags":["开始"]}]