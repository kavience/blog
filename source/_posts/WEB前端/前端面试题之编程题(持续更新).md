---
title: 前端面试题之编程题(持续更新)
catalog: true
date: 2020-11-12 19:05:46
subtitle:
header-img:
tags:
  - 前端面试题
catagories:
  - JavaScript
---

## 原型链

> 概要：每个构造函数( construct ) 都有一个原型对象，原型对象( prototype )都包含一个指向构造函数的内部指针，而实例( instance ) 都包含指向原型对象的内部指针。实例与原型的链条称作`原型链`。

网上看到一张图，感觉很全面的描述了原型链之间的关系：

![prototype](/img/blog_img/prototype.png)

注意：`prototype` 是函数(ES6 中箭头函数除外)特有的属性，实例对象不存在该属性，`__proto__` 则在两者内都存在，因为函数也是对象。

## 继承的实现

七种 JS 继承方式分别是：

- 原型链继承
- 构造函数式继承
- 组合式继承
- 原型式继承
- 寄生式继承
- 寄生组合式继承
- ES6 关键字 extends 继承

### 原型链继承

基本思想：通过直接改变子类的 prototype 实现。

优点：实例可继承的属性有：实例的构造函数的属性，父类构造函数的属性，父类原型上的属性（新实例不会继承父类实例的属性）。

缺点：新实例无法向父类构造函数传参，继承单一，所有新实例都会共享父类实例的属性。

```js
function Person(name) {
  this.name = name;
}
Person.prototype.job = "frontend";
function Child() {
  this.name = "child";
}
Child.prototype = new Person();
var child = new Child();
console.log(child.job); // frontend
console.log(child instanceof Person); // true
```

### 构造函数式继承

基本思想：在子类型构造函数的内部调用超类型构造函数.

优点：保证了原型链中引用类型值的独立，不再被所有实例共享，子类型创建时也能够向父类型传递参数。

缺点：方法都在构造函数中定义， 函数难以复用，而且父类中定义的方法，对子类而言也是不可见的。

```js
function Father() {
  this.colors = ["red", "blue", "green"];
}
function Son() {
  Father.call(this); //继承了Father,且向父类型传递参数
}
var instance1 = new Son();
instance1.colors.push("black");
console.log(instance1.colors); //"red,blue,green,black"

var instance2 = new Son();
console.log(instance2.colors); //"red,blue,green" 可见引用类型值是独立的
```

### 组合式继承

基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。

优点：通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。

缺点：调用了两次父类构造函数，造成了不必要的消耗。

```js
function Father(name) {
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
Father.prototype.sayName = function () {
  alert(this.name);
};
function Son(name, age) {
  Father.call(this, name); //继承实例属性，第一次调用Father()
  this.age = age;
}
Son.prototype = new Father(); //继承父类方法,第二次调用Father()
Son.prototype.sayAge = function () {
  alert(this.age);
};
var instance1 = new Son("louis", 5);
instance1.colors.push("black");
console.log(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //louis
instance1.sayAge(); //5

var instance1 = new Son("zhai", 10);
console.log(instance1.colors); //"red,blue,green"
instance1.sayName(); //zhai
instance1.sayAge(); //10
```

### 原型式继承

基本思想：也是通过 prototype 完成继承，只不过在多了一层函数调用。

优点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了可以随意增添属性的实例或对象。`Object.create()` 就是这个原理。

缺点：所有的实例都会继承原型上的属性，无法实现复用。

```js
// 先封装一个函数容器，用来承载继承的原型和输出对象
function object(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}
function Person(name) {
  this.name = name;
}
var super0 = new Person();
var super1 = object(super0);
console.log(super1 instanceof Person); // true
```

### 寄生式继承

基本思想：寄生式继承的思路与(寄生)构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。

优点：借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型。

缺点：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率，这一点与构造函数模式类似。

```js
function object(obj) {
  // 通过 prototype 继承
  function F() {}
  F.prototype = obj;
  return new F();
}
function Person(name) {
  this.name = name;
}
var sup = new Person();
function subobject(obj) {
  var sub = object(obj);
  sub.name = "ming";
  return sub;
}
var sup2 = subobject(sup);
// 这个函数经过声明后就成了可增添属性的对象
console.log(sup2.name); // 'ming'
console.log(sup2 instanceof Person); // true
```

### 寄生组合式继承

基本思想：不必为了指定子类型的原型而调用超类型的构造函数。

优点：集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方法。

```js
function Person(name) {
  this.name = name;
}
// 寄生
function object(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}
// object是F实例的另一种表示方法
var obj = object(Person.prototype);
// obj实例（F实例）的原型继承了父类函数的原型
// 上述更像是原型链继承，只不过只继承了原型属性

// 组合
function Sub() {
  this.age = 100;
  Person.call(this); // 这个继承了父类构造函数的属性
} // 解决了组合式两次调用构造函数属性的特点

Sub.prototype = obj;
console.log(Sub.prototype.constructor); // Person
obj.constructor = Sub; // 重点，一定要修复实例
console.log(Sub.prototype.constructor); // Sub
var sub1 = new Sub();
// Sub实例就继承了构造函数属性，父类实例，object的函数属性
console.log(sub1.job); // frontend
console.log(sub1 instanceof Person); // true
```

### ES6 关键字 extends 继承

ES6 关键字 extends 继承本质也是组合式继承。

## 数据类型

## var 、const、let

## new 的过程

## this 的指向

## bind 的实现

## 闭包

## 时间循环

## 类型判断

## 手写 promise

## 垃圾回收机制
